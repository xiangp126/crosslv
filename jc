#!/bin/bash
# shellcheck disable=SC2155 disable=SC2120 disable=SC2024
# set -x

# Tracking directories
fMainDir=$(cd "$(dirname "$(readlink -f "$0")")" || exit; pwd)
fTKFilesDir=$fMainDir/track-files
fTKCompDir=$fMainDir/completion
fTKVimColorsDir=$fMainDir/assets/vim-colors
fTKBatThemeDir=$fMainDir/assets/bat-themes
fTKFontDir=$fMainDir/assets/fonts
fTKFontConfigDir=$fMainDir/assets/fontconfig
fTKClangdConfig=$fMainDir/assets/clangd/config.yaml
fTKtemplateDir=$fMainDir/template
fTKToolsDir=$fMainDir/ftnt-tools
fDownloads=$HOME/Downloads
fJCPath=$fMainDir/jc
fFirstTimeFile=$fMainDir/".has_been_invoked"
# Misc
fVimPlugsManagerPath=$HOME/.vim/autoload/plug.vim
fzfBinPath=$HOME/.vim/bundle/fzf/bin/fzf
# A fzf plugin: fzf-tab-completion
fzfTabCompPath=$HOME/.vim/bundle/fzf-tab-completion/bash/fzf-bash-completion.sh
fBackupDir="$HOME/Public/env.bak"
fOSCategory=debian # ubuntu/debian is the default OS type
fArch=
fNoInstallTools=
# VNC server
fVncSimplePort=9
fVncRealPort="590${fVncSimplePort}"
fVncResolution=2060x1080
fVncServer= # 1: start VNC server; 2: kill VNC server 3: restart VNC server
# Docker Container: OpenGrok
fOpenGrokContainer= # 1: start container; 2: stop container 3: restart container 4: start indexer
OPENGROK_IMAGE_NAME="opengrok/docker:latest" # You can pin to a specific version, e.g., opengrok/docker:1.7.30
OPENGROK_CONTAINER_NAME="opengrok"
OPENGROK_SRC_VOLUME="$HOME/.usr/local/opengrok/src" # User puts source code here on the host
OPENGROK_DATA_VOLUME="$HOME/.usr/local/opengrok/data" # Docker named volume for OpenGrok data/indexes
OPENGROK_ETC_VOLUME="$HOME/.usr/local/opengrok/etc"   # Docker named volume for OpenGrok configuration
OPENGROK_HOST_PORT="8080"
OPENGROK_CONTAINER_PORT="8080"
fLinkClangFormatPath= # Link clang-format to this path
fLinkNodeJs= # Link Node.js from VSCode Server
fPrerequisitesForce=
fGitLfsForce=
fClangdForce=
fDockerForce=
fWiresharkForce=
fFirefoxForce=
fChinesePinyinForce=
fSambaServer= # Samba Server: 1: Start samba server; 2: Start samba server without setting password
fLiteLLMService= # LiteLLM: 1: Start LiteLLM 2: Stop LiteLLM 3: Restart LiteLLM
LITELLM_DIR="$fDownloads/litellm"
# Constants
SCRIPT_NAME=$(basename $0)
# Colors
RED='\033[31m'
GREEN='\033[32m'
MAGENTA='\033[35m'
LIGHTYELLOW='\033[93m'
BOLD='\033[1m'
NORMAL='\033[0m'
BLUE='\033[34m'
GREY='\033[90m'
CYAN='\033[36m'
RESET='\033[0m'
COLOR=$MAGENTA

usage() {
    cat << _EOF
Usage: $SCRIPT_NAME [OPTIONS]

This script is used to set up the coding environment in my predefined way.

Common Options:
    -h, --help                      Print this help message
    -n, --no-tools                  Don't install tools
    -d, --debug                     Enable debug mode
    --link-clang-format             Link clang-format to current path
    --link-nodejs                   Link nodejs from VsCode Server to current path
    --auto-remove                   Remove unused packages
    --update                        Update all packages
    --upgrade                       Upgrade all packages

VNC Options:
    --vnc,--vnc-start               Start VNC server
    --vnc-stop                      Stop VNC server
    --vnc-restart                   Restart VNC server
    --lock-vnc                      Lock VNC
    --unlock-vnc                    Unlock VNC

LiteLLM Options:
    --litellm,--litellm-start       Start LiteLLM Service
    --litellm-stop                  Stop LiteLLM Service
    --litellm-restart               Restart LiteLLM Service

OpenGrok Options:
    --opengrok,--opengrok-start     Start OpenGrok Docker container
    --opengrok-stop                 Stop OpenGrok Docker container
    --opengrok-restart              Restart OpenGrok Docker container
    --opengrok-indexer              Start OpenGrok indexer

Samba Options:
    --samba                         Install and configure Samba Server
    --samba-bypass-password         Don't set password for Samba Server again

The following options force updates or re-installation (installed by default):
    --git-lfs                       Force update Git LFS from PackageCloud
    --prerequisite                  Force update prerequisites
    --chinese-pinyin                Force Update Rime Pinyin
    --docker                        Force update Docker from Docker PPA
    --wireshark                     Force update wireshark from Wireshark PPA
    --firefox                       Force update firefox from Mozilla PPA
    --clangd                        Force update clangd from Github

Examples:
    $SCRIPT_NAME -h
    $SCRIPT_NAME --link-clang-format \$HOME/crosslv

_EOF
exit 0
}

SHORTOPTS="hdnf"
LONGOPTS="help,debug,no-tools,clangd,docker,link-clang-format::,link-nodejs,auto-remove,\
          upgrade,chinese-pinyin,prerequisite,vnc-restart,vnc-stop,unlock-vnc,\
          lock-vnc,vnc-start,vnc,firefox,update,opengrok,opengrok-start,opengrok-stop,\
          opengrok-restart,opengrok-indexer,samba,samba-bypass-password,wireshark,git-lfs\
          litellm-start,litellm-stop,litellm-restart,litellm"

# Use getopt to parse command-line options
if ! PARSED=$(getopt --options $SHORTOPTS --longoptions "$LONGOPTS" --name "$0" -- "$@"); then
    echo -e "${COLOR}Error: Failed to parse command-line options.${RESET}" >&2
    exit 1
fi

# Reset positional parameters to the parsed values
eval set -- "$PARSED"

while true; do
    case "$1" in
        -n|--no-tools)
            fNoInstallTools=true
            shift
            ;;
        --prerequisite)
            fPrerequisitesForce=true
            shift
            ;;
        --git-lfs)
            fGitLfsForce=true
            shift
            ;;
        --docker)
            fDockerForce=true
            shift
            ;;
        --wireshark)
            fWiresharkForce=true
            shift
            ;;
        --firefox)
            fFirefoxForce=true
            shift
            ;;
        --clangd)
            fClangdForce=true
            shift
            ;;
        --opengrok|--opengrok-start)
            fOpenGrokContainer=1
            shift
            ;;
        --opengrok-stop)
            fOpenGrokContainer=2
            shift
            ;;
        --opengrok-restart)
            fOpenGrokContainer=3
            shift
            ;;
        --opengrok-indexer)
            fOpenGrokContainer=4
            shift
            ;;
        --samba)
            fSambaServer=1
            shift
            ;;
        --samba-bypass-password)
            fSambaServer=2
            shift
            ;;
        --vnc|--vnc-start)
            fVncServer=1
            shift
            ;;
        --vnc-stop)
            fVncServer=2
            shift
            ;;
        --vnc-restart)
            fVncServer=3
            shift
            ;;
        --unlock-vnc)
            set -x
            loginctl unlock-session
            exit 0
            ;;
        --lock-vnc)
            set -x
            loginctl lock-session
            exit 0
            ;;
        --litellm|--litellm-start)
            fLiteLLMService=1
            shift
            ;;
        --litellm-stop)
            fLiteLLMService=2
            shift
            ;;
        --litellm-restart)
            fLiteLLMService=3
            shift
            ;;
        --chinese-pinyin)
            fChinesePinyinForce=true
            shift
            ;;
        --link-clang-format)
            # $1 is '--link-clang-format'
            # $2 is an empty string '' no matter whether it has an argument
            # The argument if provided will be put in sequence in the positional parameters
            # Exp: $ jc huhu --link-clang-format ~/ he
            #          --link-clang-format '' -- 'huhu' '/home/user1/' 'he'
            # CRITICAL: Always shift 2 to consume both the option token ($1)
            # and its argument/empty placeholder token ($2).
            fLinkClangFormatPath="$PWD"
            shift 2
            ;;
        --link-nodejs)
            fLinkNodeJs=true
            shift
            ;;
        --auto-remove)
            echo -e "${COLOR}Removing unused packages${RESET}"
            sudo apt autoremove -y
            shift
            exit 0
            ;;
        --update)
            echo -e "${COLOR}Updating all packages${RESET}"
            sudo apt update -y
            shift
            exit 0
            ;;
        --upgrade)
            echo -e "${COLOR}Updating all packages${RESET}"
            sudo apt update -y
            echo -e "${COLOR}Upgrading all packages${RESET}"
            sudo apt upgrade -y
            shift
            exit 0
            ;;
        -d|--debug)
            set -x
            echo -e "${COLOR}Debug mode enabled${RESET}"
            shift
            ;;
        -h|--help)
            usage
            ;;
        --)
            shift
            break
            ;;
        *)
            echo -e "${RED}Error: Invalid option: $1${RESET}" >&2
            exit 1
            ;;
    esac
done

checkSudoPrivilege() {
    echo -e "${COLOR}Checking Sudo Privilege${RESET}"
    if sudo -n true 2>/dev/null; then
        echo -e "${GREEN}✔${GREY} User has passwordless sudo access.${RESET}"
    else
        echo -e "${RED}✗${GREY} User does not have passwordless sudo access. Please run the script with sudo.${RESET}"
        exit 0
    fi
}

checkTlsConnection() {
    if ! command -v curl &> /dev/null; then
        echo -e "${LIGHTYELLOW}curl is not installed. Aborting.${RESET}"
        exit 1
    fi
    local targetHost=${1:-"github.com"}
    echo -e "${COLOR}Checking TLS Certificate Trust for: ${NORMAL}${targetHost}${RESET}"

    local curlOutput
    # -fsS = --fail --silent --show-error
    curlOutput=$(curl --head -fsS --connect-timeout 5 "https://${targetHost}" 2>&1)
    local curlExitCode=$?

    # Exit code 60 is specifically for peer certificate verification failure.
    if [ $curlExitCode -eq 0 ]; then
        echo -e "${GREEN}✔${GREY} TLS connection successful. Certificate is trusted.${RESET}"
    elif [ $curlExitCode -eq 60 ]; then
        echo -e "${RED}✗${GREY} TLS connection failed: Certificate validation error.${RESET}"
        echo -e "${RED}  This is often due to a corporate proxy (Man-in-the-Middle).${RESET}"
        echo -e "${GREY}☞ Details: \n$(echo "$curlOutput" | sed 's/curl: (60) //')${RESET}"
        exit 1
    else
        echo -e "${RED}✗${GREY} TLS connection failed for another reason (Exit Code: $curlExitCode).${RESET}"
        echo -e "${GREY}☞ Details: \n$(echo "$curlOutput" | sed 's/curl: ([0-9]\+) //')${RESET}"
    fi
}

checkOSAndArch() {
    echo -e "${COLOR}Checking OS and Architecture${RESET}"
    fArch=$(uname -m)
    if [[ -f /etc/os-release ]]; then
        local prettyName=$(awk -F= '/^PRETTY_NAME=/{print $2}' /etc/os-release)
        local idLike=$(awk -F= '/^ID_LIKE=/{print $2}' /etc/os-release)
        case "$idLike" in
            "debian")
                fOSCategory=$idLike
                echo -e "${GREEN}✔${GREY} The current OS type is ${LIGHTYELLOW}$prettyName${RESET}. ${GREY}The Arch is ${LIGHTYELLOW}$fArch${RESET}"
                ;;
            *)
                fOSCategory=$idLike
                echo -e "${GREEN}❌${GREY} The current OS type is ${LIGHTYELLOW}$prettyName${RESET}. ${GREY}The Arch is ${LIGHTYELLOW}$fArch${RESET}"
                echo "  We currently do not support this OS type."
                exit
                ;;
        esac
    elif [[ $(uname) == "Darwin" ]]; then
        fOSCategory=mac
        echo -e "${GREEN}✔${GREY} The current OS type is ${LIGHTYELLOW}macOS${RESET}. ${GREY}The Arch is ${LIGHTYELLOW}$fArch${RESET}"
    else
        echo -e "${GREEN}❌${GREY} The OS type is not supported or could not be determined."
        exit 1
    fi
}

removeInstalledPackages() {
        local packagesToCheck=("$@")
        local packagesToRemove=()

        for pkg in "${packagesToCheck[@]}"; do
            if dpkg-query -W -f='${Status}' "$pkg" 2>/dev/null | grep -q "ok installed"; then
                packagesToRemove+=("$pkg")
            fi
        done

        if [ ${#packagesToRemove[@]} -gt 0 ]; then
            echo -e "${LIGHTYELLOW}Removing conflicting/unwanted packages: ${packagesToRemove[*]}${RESET}"
            sudo apt remove --purge -y "${packagesToRemove[@]}"
        fi
}

aptInstallPrerequisites() {
    [ ! -f "$fFirstTimeFile" ] && fPrerequisitesForce=true
    [ -z "$fPrerequisitesForce" ] && return
    checkSudoPrivilege
    local prerequisitesForUbuntu=(
        tmux # Terminal multiplexer
        vim
        rsync # Remote file sync
        fd-find # fd
        ripgrep # rg
        universal-ctags
        openssl
        libssl-dev
        bat
        curl
        netcat-openbsd # netcat
        socat  # socat
        fonts-noto-cjk # Recommended Chinese fonts
        fonts-wqy-microhei
        fonts-wqy-zenhei
        jq # JSON parser
        xsel # X11 clipboard
        xclip
        libcurl4
        libcurl4-openssl-dev
        dos2unix
        expect
        sshfs
        sshpass
        shellcheck
        net-tools
        nftables
        inetutils-traceroute
        bash-completion
        openssh-server
        python3-dev
        ffmpeg
        nodejs # Node.js
        npm
        build-essential # build essentials
        gdb
        cmake
        libboost-all-dev
        gnupg
        lsb-release
        ragel
        sqlite3
        libsqlite3-dev
        libpcap-dev
        qemu-kvm # QEMU and KVM
        qemu-utils
        libvirt-daemon-system # libvirt
        libvirt-clients
        virt-manager
        texinfo
        libisl-dev
        libgmp-dev
        libncurses-dev
        source-highlight
        libsource-highlight-dev
        libmpfr-dev
        libtool
        autoconf
        gettext
        autopoint
        ifupdown
        bridge-utils
        bear # llvm & clangd
        libear
        gdm3 # gnome display manager
        ubuntu-desktop
        gnome-keyring
        network-manager-gnome
        xfce4 # xfce
        xfce4-goodies
        xfce4-screensaver
        tigervnc-standalone-server # TigerVNC
        tigervnc-xorg-extension
        tigervnc-viewer
        remmina # remote desktop client
    )
    echo -e "${COLOR}Updating Prerequisites for Ubuntu${RESET}"
    sudo apt update
    if ! removeInstalledPackages thunderbird lightdm xrdp xorgxrdp; then
        echo -e "${RED}Error: Failed to remove one or more conflicting packages. Aborting prerequisite installation.${RESET}"
        return 1
    fi
    echo "gdm3 shared/default-x-display-manager select gdm3" | sudo debconf-set-selections
    # echo "wireshark-common wireshark-common/install-setuid boolean true" | sudo debconf-set-selections
    sudo DEBIAN_FRONTEND=noninteractive apt install -y --no-install-recommends "${prerequisitesForUbuntu[@]}"
    # sudo DEBIAN_FRONTEND=noninteractive dpkg-reconfigure gdm3
    sudo apt autoremove -y
}

updatePrequesitesForMac() {
    checkSudoPrivilege
    prerequisitesForMac=(
        yt-dlp
        fzf
        fd
        bat
        vim
    )

    echo -e "${COLOR}Updating Prerequisites for MacOS${RESET}"
    brew update
    brew install "${prerequisitesForMac[@]}"
}

setTimeZone() {
    if [ "$(timedatectl | grep "Time zone" | awk '{print $3}')" == "America/Vancouver" ]; then
        # echo -e "${GREEN}✔${GREY} Time zone is already vancouver${RESET}"
        return
    fi
    echo -e "${COLOR}Setting Timezone to Vancouver${RESET}"
    sudo timedatectl set-timezone America/Vancouver
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Success!${RESET}"
    else
        echo -e "${RED}Failed!${RESET}"
        exit 1
    fi
}

stopAndDisableDaemonService() {
    local targetServiceName="${1:-networking.service}"
    if ! systemctl cat "$targetServiceName" >/dev/null 2>&1; then
        return 1
    fi
    # Stop the service
    local targetServiceStatus=$(systemctl is-active "$targetServiceName" 2>&1)
    if [ "$targetServiceStatus" == "active" ]; then
        echo -e "${LIGHTYELLOW}Service '${targetServiceName}' is active. Attempting to stop it...${RESET}"
        if sudo systemctl stop "$targetServiceName"; then
            echo -e "${GREEN}✔${GREY} Successfully stopped service '${targetServiceName}'.${RESET}"
        else
            echo -e "${RED}Failed to stop service '${targetServiceName}'.${RESET}"
        fi
    elif [ "$targetServiceStatus" == "inactive" ] || [ "$targetServiceStatus" == "failed" ]; then
        echo -e "${GREEN}✔${GREY} Service '${targetServiceName}' is inactive (status: $targetServiceStatus).${RESET}"
    else
        echo -e "${RED}Failed to check status for service '${targetServiceName}'.${RESET}"
        return 1
    fi

    # Disable the service
    local targetServiceEnabledStatus=$(systemctl is-enabled "$targetServiceName" 2>&1)
    case "$targetServiceEnabledStatus" in
        "disabled")
            echo -e "${GREEN}✔${GREY} Service '${targetServiceName}' is already disabled.${RESET}"
            return 0
            ;;
        "static")
            echo -e "${GREEN}✔${GREY} Service '${targetServiceName}' is static (cannot be enabled/disabled conventionally). No action needed.${RESET}"
            return 0
            ;;
        "masked")
            echo -e "${GREEN}✔${GREY} networking.service is masked. No disable action needed.${RESET}"
            return 0
            ;;
        *)
            echo -e "${LIGHTYELLOW}Attempting to disable service '${targetServiceName}' (current status: '$targetServiceEnabledStatus')...${RESET}"
            if sudo systemctl disable "$targetServiceName"; then
                echo -e "${GREEN}✔${GREY} Successfully disabled service '${targetServiceName}'.${RESET}"
            else
                echo -e "${RED}Failed to disable service '${targetServiceName}'. It might be already disabled or an error occurred.${RESET}"
                return 1
            fi
            ;;
    esac
}

# There are two primary services associated with networking in Debian/Ubuntu-based systems:
# 1. networking.service:
#    - This is the traditional System V init-style networking service.
#    - It primarily manages network interfaces configured in `/etc/network/interfaces`.
#    - It's often used for statically configured interfaces or simpler network setups.
#    - On modern systems, especially desktops and laptops, NetworkManager often takes precedence.
#
# 2. NetworkManager.service:
#    - This is a more dynamic and feature-rich network management daemon.
#    - It's the default on most modern desktop Linux distributions, including Ubuntu Desktop.
#    - It provides automatic detection and configuration for various network types (Ethernet, Wi-Fi, VPNs, etc.).
#    - It manages connections through profiles and can handle roaming, multiple connections, and user-specific settings.
#    - It usually takes control of interfaces *not* explicitly managed by `/etc/network/interfaces` (unless configured otherwise).
#
# Coexistence and Conflicts:
# - Generally, it's recommended to use *either* `networking.service` (via `/etc/network/interfaces`) *or* `NetworkManager.service` to manage a particular network interface, but not both.
# - Having both active and attempting to manage the same interfaces can lead to conflicts, unpredictable behavior, or connection issues.
# - For desktop environments, NetworkManager is usually preferred for its ease of use and dynamic capabilities.
# - For servers, especially with static IPs, `networking.service` with `/etc/network/interfaces` is often sufficient and more straightforward.
# - The script below checks if NetworkManager is active. If it is, and `networking.service` is also active,
#   it attempts to stop and disable `networking.service` to prevent potential conflicts, assuming NetworkManager
#   is the intended primary network manager.
checkNetworkManagerStatus() {
    # echo -e "${COLOR}Checking NetworkManager.service status...${RESET}"
    local nmServiceStatus=$(systemctl is-active NetworkManager.service 2>&1)
    if [ "$nmServiceStatus" == "active" ]; then
        echo -e "${GREEN}✔${GREY} NetworkManager is active.${RESET}"
        stopAndDisableDaemonService "networking.service"
    elif [ "$nmServiceStatus" == "inactive" ] || [ "$nmServiceStatus" == "failed" ]; then
        echo -e "${LIGHTYELLOW}NetworkManager is not active (status: ${nmServiceStatus}).${RESET}"
        echo -e "${LIGHTYELLOW}Consider enabling and starting NetworkManager if it's intended to manage network connections.${RESET}"
        if [ "$(systemctl is-active networking.service 2>/dev/null)" == "active" ]; then
            echo -e "${GREY}networking.service is active. This might be intentional if NetworkManager is not used.${RESET}"
        fi
    else
        echo -e "${RED}Could not determine status of NetworkManager (status: '$nmServiceStatus').${RESET}"
    fi
}

stopUnnecessaryServices() {
    echo -e "${COLOR}Stopping Unnecessary Services${RESET}"
    checkNetworkManagerStatus
    local services_to_manage=(
        "cups.service"          # CUPS (Common UNIX Printing System)
        "nmbd.service"          # NetBIOS Name Service
        "xrdp.service"          # Remote Desktop Protocol
        # "ufw.service"           # Uncomplicated Firewall
    )
    for service in "${services_to_manage[@]}"; do
        stopAndDisableDaemonService "$service"
    done
}

installTmuxPluginsManager() {
    echo -e "${COLOR}Installing Tmux Plugins Manager${RESET}"
    if [ -d ~/.tmux/plugins/tpm ]; then
        echo -e "${GREEN}✔${GREY} Tmux Plug Manager is already installed${RESET}"
        return
    fi
    git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Success!${RESET}"
    else
        echo -e "${RED}Failed!${RESET}"
        exit 1
    fi
}

installVimPluginsManager (){
    echo -e "${COLOR}Installing Vim Plugins Manager${RESET}"

    if [ ! -f ~/.vimrc ]; then
        echo "No .vimrc found, Abort!"
        exit 1
    fi

    if [ ! -f "$fVimPlugsManagerPath" ]; then
        # use the --insecure option to avoid certificate check
        curl -fLo "$fVimPlugsManagerPath" --create-dirs \
        https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
    else
        echo -e "${GREEN}✔${GREY} Vim Plug Manager is already installed${RESET}"
    fi

    echo -e "${COLOR}Updating Vim Plugins${RESET}"
    vim +PlugInstall +PlugUpdate +qall
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}✔ Success!${RESET}"
    else
        echo -e "${RED}✗ Failed!${RESET}"
        exit 1
    fi
}

# linkFile: Creates a symbolic link for a file or command to a destination directory.
#
# It can link a source file by its path or a command from the system's PATH.
# The function will back up any existing non-link file at the destination.
#
# Usage:
#   linkFile <target_path_or_cmd> <destination_dir> [new_link_name] [type]
#
# Example (file):
#   linkFile ~/myfile.txt /data/backup
# Example (file with new name):
#   linkFile ~/myfile.txt /data/backup my-renamed-file.txt
# Example (command):
#   linkFile batcat ~/.usr/bin bat command
#
# Arguments:
#   $1 - The source file path or command name.
#   $2 - The destination directory where the link will be created.
#   $3 - New link name (optional, defaults to the basename of the source).
#   $4 - Type of source: 'file' (default) or 'command' (optional).
#
# Returns:
#   0 on successful link creation.
#   1 if the link is already up to date.
#   2 if the source command is not found.
#   Exits the script if a source file does not exist.
#
linkFile() {
    local src="$1"         # Source file or command
    local linkPath="$2"    # Destination directory to link to
    local newLinkName="$3" # New link name (optional, default: as is)
    local type=${4:-file}  # Type of source

    if [[ "$type" == "command" ]]; then
        src=$(command -v "$src")
        if [ -z "$src" ]; then
            echo -e "${RED}${src} is not installed${RESET}"
            return 2
        fi
    fi
    if [ ! -d "$linkPath" ]; then
        mkdir -p "$linkPath"
    fi

    local filename=$(basename "$src")
    local linkName=${newLinkName:-$filename}
    local dst="$linkPath/${linkName}"
    [ ! -e "$src" ] && echo -e "${RED}Error: $src does not exist${RESET}" && return 1
    if [ -f "$dst" ] && [ ! -L "$dst" ]; then
        [ ! -d "$fBackupDir" ] && mkdir -p "$fBackupDir"
        echo -e "${CYAN}Warning: $dst is not a link, backing it up into $fBackupDir${RESET}"
        mv "$dst" "$fBackupDir/${linkName}.bak"
    fi

    if [ -L "$dst" ] && [ "$(readlink "$dst")" == "$src" ]; then
        echo -e "${GREEN}✔${GREY} Link ${BLUE}${linkName}${GREY} is already up to date.${RESET}"
        return 1
    fi

    echo -e "🔗 ${LIGHTYELLOW}Creating Symlink${RESET}"
    echo -e "   ├─ ${GREY}Source:${RESET} ${CYAN}$src${RESET}"
    echo -e "   └─ ${GREY}Target:${RESET} ${CYAN}$dst${RESET}"

    local success=false
    local execPrefix=
    for _ in {1..2}; do
        if $execPrefix ln -sf "$src" "$dst" &> /dev/null; then
            success=true
            break
        fi
        if [ -z "$execPrefix" ]; then
            echo -e "   ├─ ${GREY}Info:${RESET}   ${RED}Failed! Retrying with sudo...${RESET}"
            execPrefix="sudo "
        else
            break
        fi
    done
    if [ "$success" = true ]; then
        echo -e "   └─ ${GREY}Status:${RESET} ✔  ${GREEN}Success!${RESET}"
    else
        echo -e "   └─ ${GREY}Status:${RESET} ❌ ${RED}Failed!${RESET}"
    fi
}

# linkFiles: Creates symbolic links for all files from a source directory to a destination directory.
#
# This function iterates through all files in a source directory and creates a
# symbolic link for each in the destination directory. After linking, it also
# removes any broken symbolic links found in the destination directory (this
# cleanup is skipped if the destination is the user's home directory).
#
# Usage:
#   linkFiles <source_dir> <destination_dir> [link_name_prefix]
#
# Example:
#   # Link files from a config folder to the home directory, creating dotfiles.
#   linkFiles ~/dotfiles/config ~/. "."
#
# Arguments:
#   $1 - The source directory containing the files to be linked.
#   $2 - The destination directory where the symbolic links will be created.
#   $3 - An optional prefix to add to the created link names (e.g., ".").
#
# Exits:
#   The script will exit if the source directory does not exist.
linkFiles() {
    local srcDir="$1"           # Source directory
    local linkPath="$2"         # Destination directory
    local linknamePrefix="$3"   # Prefix for destination filename. Exp: . for hidden files

    [ ! -d "$srcDir" ] && echo "Source directory $srcDir does not exist, abort!" && exit 1
    [ ! -d "$linkPath" ] && mkdir -p "$linkPath"

    for file in "$srcDir"/*; do
        linkFile "$file" "$linkPath" "${linknamePrefix}$(basename "$file")"
    done

    if [ "$linkPath" == "$HOME" ]; then
        return
    fi
    # Remove broken symlinks
    find "$linkPath" -type l ! \
            -exec test -e {} \; \
            -exec rm -f {} \; \
            -exec echo -e "${CYAN}Deleting broken link: {}${RESET}" \;
}

buildBatTheme() {
    # https://github.com/sharkdp/bat/tree/master/assets/themes
    echo -e "${COLOR}Building Bat Themes${RESET}"
    local batThemeDir=$HOME/.config/bat/themes
    local needBuild=
    [ ! -d "$batThemeDir" ] && mkdir -p "$batThemeDir"

    for theme in "$fTKBatThemeDir"/*; do
        linkFile "$theme" "$batThemeDir"
        if [ $? -eq 1 ]; then
            continue
        fi
        needBuild=true
    done

    [ -z "$needBuild" ] && return
    bat cache --build
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Success!${RESET}"
    else
        echo -e "${RED}Failed!${RESET}"
        exit 1
    fi
}

buildExtraFonts() {
    echo -e "${COLOR}Building Extra Fonts${RESET}"
    local needBuild=
    local fontConfigDir="$HOME/.config/fontconfig/conf.d"
    local fontDir=$HOME/.local/share/fonts
    [ ! -d "$fontDir" ] && mkdir -p "$fontDir"
    [ ! -d "$fontConfigDir" ] && mkdir -p "$fontConfigDir"

    for fontConfig in "$fTKFontConfigDir"/*; do
        linkFile "$fontConfig" "$fontConfigDir"
        if [ $? -eq 1 ]; then
            continue
        fi
    done

    for font in "$fTKFontDir"/*; do
        local fontFile=$(basename "$font")
        local fontExists=$(fc-list | grep -i "$fontFile")
        if [ -n "$fontExists" ]; then
            echo -e "${GREEN}✔${GREY} Font ${BLUE}${fontFile}${GREY} is already up to date.${RESET}"
            continue
        fi

        linkFile "$font" "$fontDir"
        if [ $? -eq 1 ]; then
            continue
        fi
        needBuild=true
    done

    [ -z "$needBuild" ] && return
    echo -e "${COLOR}Building font cache...${RESET}"
    sudo fc-cache -fv
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Success!${RESET}"
    else
        echo -e "${RED}Failed!${RESET}"
        exit 1
    fi
}

changeTMOUTToWritable() {
    # TMOUT is readonly in /etc/profile, change it to writable so that we can unset it in .bashrc
    if ! grep -q "TMOUT" /etc/profile; then
        return
    fi
    echo -e "${COLOR}Changing TMOUT to Writable${RESET}"
    if grep -q "^readonly TMOUT" /etc/profile; then
        echo -e "${GREY}TMOUT is readonly in /etc/profile, change it to writable${RESET}"
    else
        echo -e "${GREEN}✔${GREY} TMOUT is already writable$ in /etc/profile${RESET}"
        return
    fi

    sudo sed -i 's/^readonly TMOUT/# readonly TMOUT/g' /etc/profile
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Success!${RESET}"
    else
        echo -e "${RED}Failed!${RESET}"
        exit 1
    fi
}

linkNodeJsFromCodeServer() {
    [ -z $fLinkNodeJs ] && return
    local vscodeServerDir="$HOME/.vscode-server"
    if [ ! -d "$vscodeServerDir" ]; then
        echo -e "${LIGHTYELLOW}VSCode Server directory not found: ${BLUE}$vscodeServerDir${RESET}"
        echo -e "${LIGHTYELLOW}Skipping linking Node.js from VSCode Server.${RESET}"
        return
    fi
    echo -e "${LIGHTYELLOW}Searching for Node.js executable in ${BLUE}$vscodeServerDir${RESET}..."
    local latestNodeJsPath=$(find "$vscodeServerDir" -name "node" -type f -executable \
            -exec stat -c '%W %n' {} \; 2>/dev/null | sort -nr | cut -d' ' -f2- | head -n1)

    echo -e "${GREEN}Found latest Node.js executable at: ${BLUE}$latestNodeJsPath${RESET}"
    linkFile "$latestNodeJsPath" "$HOME/.usr/bin" "node"
}

createTKSymlinks() {
    # The directories are guaranteed to exist when this function is called.
    echo -e "${COLOR}Creating Home Directory Symlinks${RESET}"
    linkFiles "$fTKFilesDir" "$HOME" "."
    echo -e "${COLOR}Creating Completion Symlinks${RESET}"
    linkFiles "$fTKCompDir" "$HOME/.bash_completion.d"
    echo -e "${COLOR}Creating Vim Colorscheme Symlinks${RESET}"
    linkFiles "$fTKVimColorsDir" "$HOME/.vim/colors"
}

createToolsSymlinks() {
    [ -n "$fNoInstallTools" ] && return
    echo -e "${COLOR}Creating Tool Symlinks${RESET}"
    linkFiles "$fTKToolsDir" "$HOME/.usr/bin"
    echo -e "${COLOR}Creating template symlinks${RESET}"
    linkFiles "$fTKtemplateDir" "$HOME/Templates"
}

relinkSysCmds() {
    echo -e "${COLOR}Relinking System Commands${RESET}"
    linkFile "batcat" "$HOME/.usr/bin" "bat" "command"
    linkFile "fdfind" "$HOME/.usr/bin" "fd" "command"
    linkFile "bash" "/bin" "sh" "command"
}

createExtraSymlinks() {
    echo -e "${COLOR}Creating Extra Symlinks${RESET}"
    # The directories are guaranteed to exist when this function is called.
    linkFile "$fTKClangdConfig" "$HOME/.config/clangd"
    linkFile "$fzfTabCompPath" "$HOME/.bash_completion.d" "fzf_tab_completion.bash"
    linkFile "$fzfBinPath" "$HOME/.usr/bin"
    linkFile "$fJCPath" "$HOME/.usr/bin"
    linkFile "$fMainDir"/assets/vscode/remote.settings.json "$HOME"/.vscode-server/data/Machine "settings.json"
    linkNodeJsFromCodeServer # Link Node.js from VSCode Server
}

createEssentialPaths() {
    local dirsToCheck=(
        "$fBackupDir"
        "$HOME/Downloads"
        "$HOME/Templates"
        "$HOME/Media"
        "$HOME/.vnc"
        "$HOME/.bash_completion.d"
        "$HOME/.usr/bin"
        "$HOME/.local/share/fonts"
        "$HOME/.config/bat/themes"
        "$HOME/.config/fontconfig/conf.d"
        "$HOME/.config/clangd"
    )

    for dir in "${dirsToCheck[@]}"; do
        if [ ! -d "$dir" ]; then
            echo -e "${LIGHTYELLOW}  Creating directory: ${BLUE}$dir${RESET}"
            mkdir -p "$dir"
            if [ $? -ne 0 ]; then
                echo -e "${RED}  Error: Failed to create directory $dir${RESET}"
                exit 1
            fi
        fi
    done

    cd "$fMainDir" || exit
}

installLatestGithubClangd() {
    echo -e "${COLOR}Checking for Github Clangd (Github Release)${RESET}"
    if [ -z "$fClangdForce" ] && command -v clangd &> /dev/null; then
        echo -e "${GREEN}✔${GREY} Clangd is already installed.${RESET}"
        printf "  "
        clangd --version | head -n 1 | sed 's/ (.*//'
        return 0
    fi

    # Github clangd is only available for x86_64
    if [ "$fArch" == "aarch64" ]; then
        echo -e "${LIGHTYELLOW}Github clangd is not available for $fArch architecture.${RESET}"
        echo -e "${LIGHTYELLOW}Installing clangd from apt package manager.${RESET}"
        sudo apt install clangd -y
        return
    fi

    if ! command -v jq &> /dev/null; then
        echo -e "${RED}Error: jq is required but not installed. Please install jq first.${RESET}"
        return 1
    fi

    local currentVersion="0.0.0"
    local clangdPath=$(command -v clangd 2>/dev/null)
    if [ -n "$clangdPath" ]; then
        currentVersion=$($clangdPath --version | head -n1 | grep -oP 'version \K[0-9]+\.[0-9]+\.[0-9]+' || echo "")
        echo -e "Current clangd version: ${BLUE}$currentVersion${RESET}"
    fi

    # Get the latest stable release version and download URL
    echo -e "${LIGHTYELLOW}Fetching latest Clangd binary information${RESET}"
    # 20.1.0
    # https://github.com/clangd/clangd/releases/download/20.1.0/clangd-linux-20.1.0.zip
    local output=$(curl -s https://api.github.com/repos/clangd/clangd/releases |
        jq -r '[.[] | select(.prerelease == false)] | .[0] |
               .name, (.assets[] | select(.name | contains("clangd-linux")) | .browser_download_url)')
    mapfile -t lines <<< "$output"
    local latestVersion="${lines[0]}"
    local downloadUrl="${lines[1]}"
    if [ -z "$latestVersion" ] || [ "$latestVersion" == "null" ]; then
        echo -e "${RED}Error: Failed to get latest version information${RESET}"
        return 1
    fi

    echo -e "Latest available clangd version: ${COLOR}$latestVersion${RESET}"
    if [ -n "$currentVersion" ]; then
        if [ "$(printf '%s\n' "$latestVersion" "$currentVersion" | sort -V -r | head -n1)" == "$currentVersion" ]; then
            echo -e "${GREY}No update needed. Current version is up to date.${RESET}"
            return 0
        fi
    fi

    echo -e "${LIGHTYELLOW}Downloading latest version of Clangd${RESET}"
    local fileName=$(basename "$downloadUrl")
    local downloadDst="$fDownloads/$fileName"
    if [ -f "$downloadDst" ]; then
        echo -e "${GREY}File $fileName already exists in $fDownloads, skipping download.${RESET}"
    else
        curl -Lo "$downloadDst" "$downloadUrl"
        if [ $? -ne 0 ]; then
            echo -e "${RED}Error: Failed to download the latest version${RESET}"
            return 1
        fi
    fi

    cd "$fDownloads" || exit 1
    local peekInfo=$(zipinfo -1 "$downloadDst" | head -n 1)
    local extractDir="$fDownloads/$(dirname "$peekInfo")"
    if [ -d "$extractDir" ]; then
        echo -e "${GREY}Directory $extractDir already exists, skipping extraction.${RESET}"
    else
        echo -e "${LIGHTYELLOW}Extracting Clangd${RESET}"
        unzip "$downloadDst"
        if [ ! -d "$extractDir" ]; then
            echo -e "${RED}Error: Failed to extract the downloaded file${RESET}"
            exit 1
        fi
        echo -e "${GREEN}Successfully extracted to $extractDir${RESET}"
    fi

    # find binary named clangd under the extracted directory
    local clangdBinary=$(find "$extractDir" -type f -name "clangd" -executable | head -n 1)
    if [ -z "$clangdBinary" ]; then
        echo -e "${RED}Error: Failed to find the clangd binary in the extracted directory${RESET}"
        return 1
    fi

    linkFile "$clangdBinary" "$HOME/.usr/bin"
}

createFirstTimeFile() {
    [ -f "$fFirstTimeFile" ] && return
    touch "$fFirstTimeFile"
}

installLatestGitLfs() {
    echo -e "${COLOR}Checking for Git LFS (PackageCloud)${RESET}"

    if [ -z "$fGitLfsForce" ] && command -v git-lfs &>/dev/null; then
        local lfsPolicy
        lfsPolicy=$(apt-cache policy git-lfs)
        local installedVersion candidateVersion
        installedVersion=$(echo "$lfsPolicy" | grep "Installed:" | awk '{print $2}')
        candidateVersion=$(echo "$lfsPolicy" | grep "Candidate:" | awk '{print $2}')

        if [ "$installedVersion" != "(none)" ] && [ "$installedVersion" == "$candidateVersion" ]; then
            if echo "$lfsPolicy" | grep -q "packagecloud.io"; then
                echo -e "${GREEN}✔${GREY} Git LFS (from PackageCloud) is already installed and up-to-date.${RESET}"
                printf "  "
                git-lfs --version | head -n 1
                return 0
            fi
        fi
    fi

    echo -e "${LIGHTYELLOW}Proceeding with Git LFS installation/update from PackageCloud...${RESET}"

    # 1. Add the Git LFS repository
    echo -e "${LIGHTYELLOW}Checking for Git LFS repository (packagecloud.io)...${RESET}"
    if grep -qr "packagecloud.io/github/git-lfs" /etc/apt/sources.list /etc/apt/sources.list.d/ 2>/dev/null; then
        echo -e "${GREEN}✔${GREY} Git LFS repository already configured.${RESET}"
    else
        echo -e "${LIGHTYELLOW}Adding the Git LFS repository script from packagecloud.io...${RESET}"
        if ! curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash; then
            echo -e "${RED}Error: Failed to add Git LFS repository. Aborting.${RESET}"
            return 1
        fi
        echo -e "${GREEN}Git LFS repository added successfully.${RESET}"
    fi

    # 2. Create the preference file to prioritize PackageCloud Git LFS
    local preferenceFilePath="/etc/apt/preferences.d/git-lfs-ppa-priority"
    local preferenceContent
    preferenceContent=$(cat <<'EOF'
Package: git-lfs
Pin: origin packagecloud.io
Pin-Priority: 1001

Package: git-lfs
Pin: release o=Ubuntu*
Pin-Priority: -1
EOF
)
    echo -e "${LIGHTYELLOW}Setting up APT preferences to prioritize Git LFS from PackageCloud...${RESET}"
    if [ -f "$preferenceFilePath" ] && cmp -s <(echo "$preferenceContent") "$preferenceFilePath"; then
        echo -e "${GREY}APT preference file '$preferenceFilePath' already exists and is correctly configured.${RESET}"
    else
        echo "$preferenceContent" | sudo tee "$preferenceFilePath" > /dev/null
        if [ $? -eq 0 ]; then
            echo -e "${GREEN}APT preference file '$preferenceFilePath' created/updated successfully.${RESET}"
        else
            echo -e "${RED}Failed to create/update APT preference file '$preferenceFilePath'. Aborting.${RESET}"
            return 1
        fi
    fi

    # 3. Update package list and install
    echo -e "${LIGHTYELLOW}Updating package lists...${RESET}"
    if ! sudo apt update; then
        echo -e "${RED}Error: Failed to update apt package list. Aborting.${RESET}"
        return 1
    fi

    echo -e "${LIGHTYELLOW}Installing Git LFS...${RESET}"
    if ! sudo DEBIAN_FRONTEND=noninteractive apt install -y git-lfs; then
        echo -e "${RED}Error: Failed to install git-lfs. Aborting.${RESET}"
        return 1
    fi
    echo -e "${GREEN}Git LFS installed successfully.${RESET}"

    # 4. Initialize Git LFS for the user
    echo -e "${LIGHTYELLOW}Running 'git lfs install' to initialize Git LFS...${RESET}"
    if git lfs install; then
        echo -e "${GREEN}Git LFS initialized successfully for the current user.${RESET}"
    else
        echo -e "${RED}Warning: 'git lfs install' command failed. You may need to run it manually.${RESET}"
    fi

    echo -e "\n${GREEN}--- Git LFS Installation Process Completed ---${RESET}"
    git-lfs --version
    return 0
}

installLatestPPaDocker() {
    echo -e "${COLOR}Checking for Docker${RESET}"
    if command -v docker &> /dev/null && [ -z "$fDockerForce" ]; then
        echo -e "${GREEN}✔${GREY} Docker is already installed.${RESET}"
        printf "  "
        docker --version
        return 0
    fi

    # 1. Uninstall old versions
    echo -e "${LIGHTYELLOW}Uninstalling old Docker versions (if any)...${RESET}"
    sudo apt-get remove -y docker docker-engine docker.io containerd runc > /dev/null 2>&1
    sudo apt-get autoremove -y > /dev/null 2>&1
    echo -e "${GREY}Old versions uninstalled/autoremoved (if any existed).${RESET}"

    # 2. Set up the repository
    echo -e "${LIGHTYELLOW}Setting up Docker repository...${RESET}"
    if ! sudo apt-get update; then
        echo -e "${RED}Failed to update apt package list.${RESET}"
        exit 1
    fi

    if [ ! -d /etc/apt/keyrings ] && ! sudo install -m 0755 -d /etc/apt/keyrings; then
        echo -e "${RED}Failed to create /etc/apt/keyrings directory.${RESET}"
        exit 1
    fi

    # Step 2a: Add Docker's official GPG key
    local dockerGpgKey="/etc/apt/keyrings/docker.gpg"
    if [ -f "$dockerGpgKey" ]; then
        echo -e "${GREEN}✔${GREY} Docker GPG key already exists.${RESET}"
    else
        echo -e "${LIGHTYELLOW}Downloading Docker's official GPG key...${RESET}"
        # Download Docker's official GPG key
        if ! curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o "$dockerGpgKey"; then
            echo -e "${RED}Failed to download or dearmor Docker GPG key.${RESET}"
            exit 1
        fi
        if ! sudo chmod a+r "$dockerGpgKey"; then
        echo -e "${RED}Failed to set permissions for Docker GPG key.${RESET}"
        exit 1
    fi
        echo -e "${GREEN}Docker GPG key downloaded and configured successfully.${RESET}"
    fi

    # Step 2b: Add the Docker repository to Apt sources.
    # This command creates the repository source file and points to Docker's official repository.
    # The `signed-by` option tells apt to verify packages from this repo using the key we just downloaded.
    # This now uses the official recommended method from Docker's documentation.
    if ! echo \
      "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
      $(lsb_release -cs) stable" | \
      sudo tee /etc/apt/sources.list.d/docker.list > /dev/null; then
        echo -e "${RED}Failed to add Docker repository to apt sources.${RESET}"
        exit 1
    fi
    echo -e "${GREEN}Docker repository set up successfully.${RESET}"

    # Step 3: Install Docker Engine.
    echo -e "${LIGHTYELLOW}Updating package list and installing Docker Engine...${RESET}"
    if ! sudo apt-get update; then
        echo -e "${RED}Failed to update apt package list after adding Docker repo.${RESET}"
        exit 1
    fi
    if ! sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin; then
        echo -e "${RED}Failed to install Docker Engine packages.${RESET}"
        exit 1
    fi
    echo -e "${GREEN}Docker Engine installed successfully.${RESET}"

    # Step 4: Verify installation by running the hello-world container.
    echo -e "${LIGHTYELLOW}Verifying Docker installation by running hello-world...${RESET}"
    if sudo docker run hello-world; then
        echo -e "${GREEN}Docker hello-world container ran successfully.${RESET}"
    else
        echo -e "${RED}Docker hello-world container failed to run. Docker might be installed but requires attention.${RESET}"
    fi

    # Step 5: Post-installation steps (run Docker as a non-root user).
    echo -e "${LIGHTYELLOW}Configuring Docker to run without sudo for current user ($USER)...${RESET}"
    # Create the 'docker' group if it doesn't exist.
    if ! getent group docker > /dev/null; then
        echo -e "${GREY}Docker group does not exist, creating it...${RESET}"
        if ! sudo groupadd docker; then
            echo -e "${RED}Failed to create 'docker' group. You may need to do this manually.${RESET}"
        else
            echo -e "${GREEN}'docker' group created.${RESET}"
        fi
    else
        echo -e "${GREY}'docker' group already exists.${RESET}"
    fi

    # Add the current user to the 'docker' group.
    if getent group docker > /dev/null; then
        if sudo usermod -aG docker "$USER"; then
            echo -e "${GREEN}User '$USER' added to the 'docker' group.${RESET}"
            echo -e "${BOLD}${MAGENTA}IMPORTANT: You must log out and log back in, or run 'newgrp docker', for this change to take effect.${RESET}"
        else
            echo -e "${RED}Failed to add user $USER to the 'docker' group. You may need to do this manually (e.g., sudo usermod -aG docker \"\$USER\").${RESET}"
        fi
    else
        echo -e "${RED}Cannot add user to 'docker' group as the group does not exist or could not be created.${RESET}"
    fi

    echo -e "${GREEN}Docker installation and basic configuration process completed.${RESET}"
}

installLatestRimePinyin() {
    echo -e "${COLOR}Checking Rime Pinyin Input Method${RESET}"
    if [ -z "$fChinesePinyinForce" ]; then
        for cmd in fcitx5 fcitx; do
            if command -v "${cmd}-configtool" &>/dev/null; then
                echo -e "${GREEN}✔${GREY} Rime Pinyin input method is already installed.${RESET}"
                printf "  "
                "$cmd" --version
                return 0
            fi
        done
    fi

    echo -e "${LIGHTYELLOW}Updating package lists...${RESET}"
    if ! sudo apt update; then
        echo -e "${RED}Failed to update apt package list. Aborting Rime installation.${RESET}"
        return 1
    fi

    local fcitxXProfilePath=$fMainDir/assets/vnc/fcitx5.xprofile
    # --- Attempt Fcitx5-Rime first ---
    echo -e "${COLOR}Checking for Fcitx5-Rime availability...${RESET}"
    if apt-cache show fcitx5-rime > /dev/null 2>&1; then
        echo -e "${GREEN}Fcitx5-Rime (fcitx5-rime) appears to be available. Attempting installation.${RESET}"
        local packagesToInstallFcitx5=(
            fcitx5
            fcitx5-rime
            fcitx5-chinese-addons # Provides general Chinese support, dictionaries, etc.
            # fcitx5-configtool     # GUI configuration tool (e.g., fcitx5-config-qt)
            fcitx5-config-qt      # GUI configuration tool
            im-config             # Input method configuration tool (sets fcitx5 as default)
        )

        # Link the xprofile file
        linkFile "$fcitxXProfilePath" "$HOME" .xprofile
        echo -e "${LIGHTYELLOW}Installing Fcitx5 packages: ${packagesToInstallFcitx5[*]}${RESET}"
        if sudo DEBIAN_FRONTEND=noninteractive apt install -y "${packagesToInstallFcitx5[@]}"; then
            echo -e "${GREEN}Successfully installed Fcitx5 and Rime packages.${RESET}"
            echo -e "${LIGHTYELLOW}Setting fcitx5 as the default input method system-wide using im-config...${RESET}"
            if sudo im-config -n fcitx5; then
                echo -e "${GREEN}Successfully configured fcitx5 as the default input method via im-config.${RESET}"
                echo -e "${GREY}(im-config handles setting environment variables like XMODIFIERS, GTK_IM_MODULE, QT_IM_MODULE for graphical sessions)${RESET}"
            else
                echo -e "${RED}Failed to set fcitx5 as the default input method using im-config.${RESET}"
                echo -e "${LIGHTYELLOW}You might need to run 'im-config' (as a regular user, not sudo) to select fcitx5, or configure it via your desktop environment's settings.${RESET}"
                echo -e "${LIGHTYELLOW}Alternatively, for X11 sessions, ensure these lines are in your ~/.xprofile or similar (e.g., ~/.profile, ~/.xinitrc):${RESET}"
                echo -e "${LIGHTYELLOW}  export GTK_IM_MODULE=fcitx5${RESET}"
                echo -e "${LIGHTYELLOW}  export QT_IM_MODULE=fcitx5${RESET}"
                echo -e "${LIGHTYELLOW}  export XMODIFIERS=@im=fcitx5${RESET}"
            fi

            echo -e "${GREEN}Fcitx5-Rime installation and basic configuration process completed.${RESET}"
            echo -e "${BOLD}${MAGENTA}IMPORTANT: A system REBOOT or RE-LOGIN is REQUIRED for all changes to take full effect.${RESET}"
            echo -e "${LIGHTYELLOW}After rebooting/re-logging in:${RESET}"
            echo -e "${LIGHTYELLOW}1. Fcitx5 should start automatically. If not, add 'fcitx5' to your session's startup applications.${RESET}"
            echo -e "${LIGHTYELLOW}2. Open 'Fcitx 5 Configuration' (command: ${BLUE}fcitx5-configtool${RESET}).${RESET}"
            echo -e "${LIGHTYELLOW}3. In the 'Input Method' tab, ensure 'Pinyin' (from Rime) is in the list of active input methods. ${RESET}"
            echo -e "${LIGHTYELLOW}   If not, click the '+' button, uncheck 'Only Show Current Language' if needed, find 'Pinyin' (Rime), and add it.${RESET}"
            echo -e "${LIGHTYELLOW}4. You can switch input methods using the configured hotkey (often Ctrl+Space or Super+Space). Check 'Global Options' tab in fcitx5-configtool for 'Trigger Input Method'.${RESET}"
            echo -e "${LIGHTYELLOW}5. For Rime specific settings (e.g., traditional Chinese, fuzzy pinyin), create/edit files in ${BLUE}~/.local/share/fcitx5/rime/${RESET} (e.g., default.custom.yaml). Refer to Rime documentation.${RESET}"
            return 0
        else
            echo -e "${RED}Failed to install Fcitx5-Rime packages. Will try Fcitx4-Rime as a fallback.${RESET}"
        fi
    else
        echo -e "${LIGHTYELLOW}Fcitx5-Rime (fcitx5-rime) not found in official repositories. Checking for Fcitx4-Rime.${RESET}"
    fi

    # --- Attempt Fcitx4-Rime (fcitx) if Fcitx5-Rime was not available or failed ---
    echo -e "${COLOR}Checking for Fcitx4-Rime (fcitx-rime) availability...${RESET}"
    if apt-cache show fcitx-rime > /dev/null 2>&1; then
        echo -e "${GREEN}Fcitx4-Rime (fcitx-rime) appears to be available. Attempting installation.${RESET}"
        local packagesToInstallFcitx4=(
            fcitx
            fcitx-rime
            fcitx-table-all       # Common tables for fcitx4, includes pinyin etc.
            fcitx-frontend-gtk3
            fcitx-frontend-qt5    # Or fcitx-libs-qt5 on older systems
            fcitx-config-gtk      # GUI config tool for fcitx4 (or fcitx-configtool)
            im-config
        )

        # Link .xprofile to ~/.xprofile
        fcitxXProfilePath=$fMainDir/assets/vnc/fcitx.xprofile
        linkFile "$fcitxXProfilePath" "$HOME" .xprofile
        echo -e "${LIGHTYELLOW}Installing Fcitx4 packages: ${packagesToInstallFcitx4[*]}${RESET}"
        if sudo DEBIAN_FRONTEND=noninteractive apt install -y "${packagesToInstallFcitx4[@]}"; then
            echo -e "${GREEN}Successfully installed Fcitx4 and Rime packages.${RESET}"

            echo -e "${LIGHTYELLOW}Setting fcitx as the default input method system-wide using im-config...${RESET}"
            if sudo im-config -n fcitx; then # Note: 'fcitx' for fcitx4
                echo -e "${GREEN}Successfully configured fcitx as the default input method via im-config.${RESET}"
            else
                echo -e "${RED}Failed to set fcitx as the default input method using im-config.${RESET}"
                echo -e "${LIGHTYELLOW}You might need to run 'im-config' (as a regular user) to select fcitx, or configure it via your desktop environment's settings.${RESET}"
                echo -e "${LIGHTYELLOW}Alternatively, for X11 sessions, ensure these lines are in your ~/.xprofile or similar:${RESET}"
                echo -e "${LIGHTYELLOW}  export GTK_IM_MODULE=fcitx${RESET}"
                echo -e "${LIGHTYELLOW}  export QT_IM_MODULE=fcitx${RESET}"
                echo -e "${LIGHTYELLOW}  export XMODIFIERS=@im=fcitx${RESET}"
            fi

            echo -e "${GREEN}Fcitx4-Rime installation and basic configuration process completed.${RESET}"
            echo -e "${BOLD}${MAGENTA}IMPORTANT: A system REBOOT or RE-LOGIN is REQUIRED for all changes to take full effect.${RESET}"
            echo -e "${LIGHTYELLOW}After rebooting/re-logging in:${RESET}"
            echo -e "${LIGHTYELLOW}1. Fcitx should start automatically. If not, add 'fcitx' to your session's startup applications.${RESET}"
            echo -e "${LIGHTYELLOW}2. Open 'Fcitx Configuration' (command: ${BLUE}fcitx-config-gtk${RESET} or ${BLUE}fcitx-configtool${RESET}).${RESET}"
            echo -e "${LIGHTYELLOW}3. Ensure 'Rime' is in the list of active input methods. If not, add it.${RESET}"
            echo -e "${LIGHTYELLOW}4. Switch input methods using the configured hotkey (e.g., Ctrl+Space).${RESET}"
            echo -e "${LIGHTYELLOW}5. Rime user data for fcitx4 is typically in ${BLUE}~/.config/fcitx/rime/${RESET}. Check Rime documentation.${RESET}"
            return 0
        else
            echo -e "${RED}Failed to install Fcitx4-Rime packages.${RESET}"
        fi
    else
        echo -e "${LIGHTYELLOW}Fcitx4-Rime (fcitx-rime) not found in official repositories.${RESET}"
    fi

    echo -e "${RED}Could not install Rime (neither Fcitx5-Rime nor Fcitx4-Rime) from official repositories.${RESET}"
    echo -e "${LIGHTYELLOW}Please ensure your system is Ubuntu/Debian based and your package sources are correctly configured.${RESET}"
    echo -e "${LIGHTYELLOW}No Rime input method was installed.${RESET}"
    return 1
}

installLatestPPaFirefox() {
    echo -e "${COLOR}Checking for Firefox (Mozilla PPA)${RESET}"
    if ! apt-cache show fcitx5-rime > /dev/null 2>&1; then
        echo -e "${GREEN}✔${GREY} The current version of Firefox is acceptable.${RESET}"
        return 0
    fi

    # Check if Firefox is installed and if it's the DEB version from Mozilla PPA
    if [ -z "$fFirefoxForce" ] && command -v firefox &>/dev/null; then
        firefoxPolicy=$(apt-cache policy firefox)
        if echo "$firefoxPolicy" | grep -q "mozillateam/ppa"; then
            installedVersion=$(echo "$firefoxPolicy" | grep "Installed:" | awk '{print $2}')
            candidateVersion=$(echo "$firefoxPolicy" | grep "Candidate:" | awk '{print $2}')
            if [ "$installedVersion" != "(none)" ] && [ "$installedVersion" == "$candidateVersion" ]; then
                echo -e "${GREEN}✔${GREY} Firefox (Mozilla PPA) is already installed and up-to-date.${RESET}"
                echo "  $installedVersion"
                return 0
            fi
        elif echo "$firefoxPolicy" | grep -q "snap"; then
            echo -e "${LIGHTYELLOW}Snap version of Firefox found. Will attempt to replace with DEB version.${RESET}"
        fi
    fi

    # 1. Add the Mozilla PPA
    echo -e "${LIGHTYELLOW}Checking for Mozilla PPA (ppa:mozillateam/ppa)...${RESET}"
    if grep -qr "mozillateam/ppa" /etc/apt/sources.list /etc/apt/sources.list.d/ 2>/dev/null; then
        echo -e "${GREEN}✔${GREY} Mozilla PPA already configured.${RESET}"
    else
        echo -e "${LIGHTYELLOW}Adding the Mozilla PPA...${RESET}"
        if ! sudo add-apt-repository -y ppa:mozillateam/ppa; then
            echo -e "${RED}Failed to add Mozilla PPA. Aborting Firefox DEB installation.${RESET}"
            return 1
        fi
        echo -e "${GREEN}Mozilla PPA added successfully.${RESET}"
    fi

    # 2. Create the preference file to prioritize PPA Firefox
    local preferenceFilePath="/etc/apt/preferences.d/mozilla-firefox-nosnap"
    local preferenceContent=$(cat <<EOF
Package: *
Pin: release o=LP-PPA-mozillateam
Pin-Priority: 1001

Package: firefox
Pin: release o=Ubuntu*
Pin-Priority: -1
EOF
)
    echo -e "${LIGHTYELLOW}Setting up APT preferences to prioritize Mozilla PPA Firefox...${RESET}"
    if [ -f "$preferenceFilePath" ] && cmp -s <(echo "$preferenceContent") "$preferenceFilePath"; then
        echo -e "${GREY}APT preference file '$preferenceFilePath' already exists and is correctly configured.${RESET}"
    else
        echo "$preferenceContent" | sudo tee "$preferenceFilePath" > /dev/null
        if [ $? -eq 0 ]; then
            echo -e "${GREEN}APT preference file '$preferenceFilePath' created/updated successfully.${RESET}"
        else
            echo -e "${RED}Failed to create/update APT preference file '$preferenceFilePath'. Aborting.${RESET}"
            return 1
        fi
    fi

    # 3. Uninstall Snap Firefox (if present)
    if snap list firefox &>/dev/null; then
        echo -e "${LIGHTYELLOW}Uninstalling Snap version of Firefox...${RESET}"
        if ! sudo snap remove firefox; then
            echo -e "${RED}Failed to remove Snap Firefox. This might interfere. Continuing, but manual removal might be needed.${RESET}"
        else
            echo -e "${GREEN}Snap Firefox removed successfully.${RESET}"
        fi
    else
        echo -e "${GREY}Snap version of Firefox not found. Skipping removal.${RESET}"
    fi

    # 4. Install DEB Firefox
    echo -e "${LIGHTYELLOW}Updating package lists...${RESET}"
    if ! sudo apt update; then
        echo -e "${RED}Failed to update apt package list after PPA and preference changes. Aborting Firefox installation.${RESET}"
        return 1
    fi

    echo -e "${LIGHTYELLOW}Installing Firefox from Mozilla PPA...${RESET}"
    if ! sudo apt install -y firefox; then
        echo -e "${RED}Failed to install Firefox from Mozilla PPA.${RESET}"
        echo -e "${LIGHTYELLOW}Attempting to install specific components that might be missing (e.g., language packs)...${RESET}"
        sudo apt install -y firefox-locale-en # Example for English, adjust if needed
        if ! sudo apt install -y firefox; then # Retry main installation
             echo -e "${RED}Still failed to install Firefox after attempting component install.${RESET}"
             return 1
        fi
    fi

    # 5. Verify installation
    if command -v firefox &>/dev/null; then
        firefoxVersion=$(firefox --version)
        firefoxPolicyAfter=$(apt-cache policy firefox)
        if echo "$firefoxPolicyAfter" | grep -q "mozillateam/ppa"; then
            echo -e "${GREEN}Firefox installed successfully! Version: $firefoxVersion${RESET}"
            echo -e "${GREY}Policy check confirms it's from Mozilla PPA.${RESET}"
        else
            echo -e "${RED}Firefox installed, but it might not be the DEB version from Mozilla PPA. Please check 'apt-cache policy firefox'.${RESET}"
        fi
    else
        echo -e "${RED}Firefox installation failed or binary not found in PATH.${RESET}"
        return 1
    fi
    return 0
}

linkClangFormat() {
    local argVal="$1"
    if [ -n "$argVal" ]; then
        if [ ! -d "$argVal" ]; then
            echo -e "${RED}Error: Link path '$argVal' is not a valid directory.${RESET}" >&2
            exit 1
        fi
        fLinkClangFormatPath="$argVal"
    fi

    local realClangFormatPath=$fMainDir/assets/clangd/clang-format
    echo -e "${LIGHTYELLOW}Linking clang-format to $fLinkClangFormatPath/.clang-format${RESET}"
    linkFile "$realClangFormatPath" "$fLinkClangFormatPath" .clang-format
}

isVncServerRunning() {
    if ! command -v tigervncserver &> /dev/null; then
        echo -e "${RED}Error: vncserver is not installed.${RESET}" >&2
        exit 1
    fi
    if lsof -i :$fVncRealPort | grep --quiet LISTEN; then
        return 0
    else
        return 1
    fi
}

stopVncServer() {
    if isVncServerRunning; then
        echo -e "${LIGHTYELLOW}Stopping VNC server on port $fVncRealPort...${RESET}"
        tigervncserver -kill :$fVncSimplePort
    else
        echo -e "${LIGHTYELLOW}VNC server on port $fVncRealPort is not running.${RESET}"
    fi
}

startVncServer() {
    if isVncServerRunning; then
        echo -e "${LIGHTYELLOW}VNC server on port $fVncRealPort is already running.${RESET}"
        return 0
    fi
    local hostIpAddress=$(hostname -I | awk '{print $1}')
    local hostUsername=$(whoami)
    local xstartupPath=$fMainDir/assets/vnc/xstartup
    local xstartupDest=$HOME/.vnc/xstartup
    [ -d "$HOME"/.vnc ] || mkdir -p "$HOME"/.vnc
    cd "$HOME"/.vnc || exit
    linkFile "$xstartupPath" "$HOME/.vnc" xstartup
    linkFile "$fMainDir/assets/gdm3/custom.conf" "/etc/gdm3" custom.conf
    echo -e "${GREEN}Starting VNC server...${RESET}"
    local startCmd="tigervncserver :$fVncSimplePort -geometry $fVncResolution -SecurityTypes None -localhost yes -xstartup $xstartupDest"
    echo -e "${MAGENTA}$startCmd${RESET}"
    $startCmd
    if [ $? -ne 0 ]; then
        echo -e "${RED}Failed to start VNC server.${RESET}"
        return 1
    fi
    echo -e "${MAGENTA}VNC server started successfully:${RESET}"
    sudo lsof -i :5909
    echo -e "${CYAN}===================================================${RESET}"
    echo -e "${BOLD}${LIGHTYELLOW}- On your local machine, setup the SSH tunnel as follows:${RESET}"
    echo -e "  ${GREEN}Option 1.${RESET} Use Vs Code Port Forward feature to forward the port ${MAGENTA}$fVncRealPort${RESET}"
    echo -e "  ${GREEN}Option 2.${RESET} Open a terminal and run the following command:"
    echo -e "    ${BLUE}ssh -NL ${MAGENTA}$fVncRealPort${BLUE}:localhost:${MAGENTA}$fVncRealPort ${MAGENTA}$hostUsername@$hostIpAddress${RESET}"
    echo -e "    ${GREY}or simply:${RESET} ${BLUE}ssh -NL ${MAGENTA}$fVncRealPort${BLUE}:localhost:${MAGENTA}$fVncRealPort ${MAGENTA}droplet1${RESET}"
    echo -e "${BOLD}${LIGHTYELLOW}- Connect to the VNC server using a VNC viewer:${RESET}"
    echo -e "  ${BLUE}vncviewer localhost:${MAGENTA}$fVncRealPort${RESET}"
    echo -e "${CYAN}===================================================${RESET}"
}

restartVncServer() {
    stopVncServer
    sleep 1
    startVncServer
}

isOpenGrokContainerRunning() {
    if ! command -v docker &> /dev/null; then
        echo -e "${RED}Error: Docker is not installed. Please install Docker first.${RESET}"
        exit 1
    fi
    if ! docker info > /dev/null 2>&1; then
        echo -e "${RED}Error: Docker daemon does not seem to be running or accessible.${RESET}"
        echo -e "${LIGHTYELLOW}Please ensure Docker is started and you have permissions (e.g., current user in 'docker' group, or running commands with sudo).${RESET}"
        exit 1
    fi
    if docker ps -q --filter "name=^/${OPENGROK_CONTAINER_NAME}$" | grep -q .; then
        return 0
    else
        return 1
    fi
}

startOpenGrokIndexer() {
    # docker exec -it opengrok bash
    if ! isOpenGrokContainerRunning; then
        echo -e "${GREEN}✔${GREY} OpenGrok container ('${OPENGROK_CONTAINER_NAME}') is not running.${RESET}"
        return 0
    fi
    echo -e "${MAGENTA}Starting OpenGrok indexer...${RESET}"
    docker exec $OPENGROK_CONTAINER_NAME java \
    -Djava.util.logging.config.file=/opengrok/etc/logging.properties \
    -jar /opengrok/lib/opengrok.jar \
    -c /usr/local/bin/ctags \
    -s /opengrok/src \
    -d /opengrok/data \
    -H -P -S -G \
    -W /opengrok/etc/configuration.xml
}

stopOpenGrokContainer() {
    if ! isOpenGrokContainerRunning; then
        echo -e "${GREEN}✔${GREY} OpenGrok container ('${OPENGROK_CONTAINER_NAME}') is not running.${RESET}"
        return 0
    fi
    echo -e "${MAGENTA}Stopping OpenGrok Docker container...${RESET}"
    docker stop $OPENGROK_CONTAINER_NAME &> /dev/null
}

startOpenGrokContainer() {
    if isOpenGrokContainerRunning; then
        echo -e "${GREEN}✔${GREY} OpenGrok container ('${OPENGROK_CONTAINER_NAME}') is already running.${RESET}"
        echo -e "${LIGHTYELLOW}Access it at: ${BOLD}http://localhost:${OPENGROK_HOST_PORT}${RESET}"
        return 0
    fi

    echo -e "${MAGENTA}Deploying and starting OpenGrok Docker container...${RESET}"
    for dirPath in $OPENGROK_SRC_VOLUME $OPENGROK_DATA_VOLUME $OPENGROK_ETC_VOLUME; do
        if [ ! -d "$dirPath" ]; then
            echo -e "${GREY}Creating directory with sudo: ${BLUE}$dirPath${RESET}"
            if ! mkdir -p "$dirPath"; then
                echo -e "${RED}Error: Failed to create host directory ${BLUE}$dirPath${RED} with sudo.${RESET}"
                return 1
            fi
            echo -e "${GREEN}✔${GREY} Directory ${BLUE}$dirPath${GREY} created.${RESET}"
        fi
    done
    echo -e "${GREEN}✔${GREY} Host source directory ensured: ${BLUE}$OPENGROK_SRC_VOLUME${RESET}"
    echo -e "${LIGHTYELLOW}IMPORTANT: Place your source code repositories inside ${BOLD}$OPENGROK_SRC_VOLUME${LIGHTYELLOW} for OpenGrok to index.${RESET}"
    echo -e "${GREY}OpenGrok data and configuration will be stored in Docker managed volumes ('${OPENGROK_DATA_VOLUME}', '${OPENGROK_ETC_VOLUME}').${RESET}"

    # Check if container exists (but is stopped) and remove it to avoid conflicts
    if docker ps -aq --filter "name=^/${OPENGROK_CONTAINER_NAME}$" | grep -q .; then
        echo -e "${LIGHTYELLOW}Found existing stopped OpenGrok container ('${OPENGROK_CONTAINER_NAME}'). Removing it...${RESET}"
        if sudo docker rm "$OPENGROK_CONTAINER_NAME"; then
            echo -e "${GREEN}✔${GREY} Successfully removed existing container '${OPENGROK_CONTAINER_NAME}'.${RESET}"
        else
            echo -e "${RED}Error: Failed to remove existing container '${OPENGROK_CONTAINER_NAME}'.${RESET}"
            return 1
        fi
    fi

    # Pull the latest OpenGrok image
    echo -e "${LIGHTYELLOW}Checking for OpenGrok image (${OPENGROK_IMAGE_NAME})...${RESET}"
    if docker image inspect "$OPENGROK_IMAGE_NAME" &> /dev/null; then
        echo -e "${GREEN}✔${GREY} Image '${OPENGROK_IMAGE_NAME}' already exists locally.${RESET}"
    else
        echo -e "${LIGHTYELLOW}Pulling the latest OpenGrok image (${OPENGROK_IMAGE_NAME})...${RESET}"
        if ! docker pull "$OPENGROK_IMAGE_NAME"; then
            echo -e "${RED}Error: Failed to pull OpenGrok image '${OPENGROK_IMAGE_NAME}'.${RESET}"
            return 1
        fi
    fi
    echo -e "${GREEN}✔${GREY} Image '${OPENGROK_IMAGE_NAME}' pulled successfully.${RESET}"

    # Start the OpenGrok container
    echo -e "${LIGHTYELLOW}Starting OpenGrok container ('${OPENGROK_CONTAINER_NAME}')...${RESET}"
    local params=(
        run -d
        --name "$OPENGROK_CONTAINER_NAME"
        "--restart=unless-stopped"  # Restart the container automatically
        -e "NOMIRROR=yes"
        -p "127.0.0.1:${OPENGROK_HOST_PORT}:${OPENGROK_CONTAINER_PORT}/tcp" # Map host port to container port (localhost only)
        -v "${OPENGROK_SRC_VOLUME}:/opengrok/src:ro"  # Mount host source directory as read-only
        -v "${OPENGROK_DATA_VOLUME}:/opengrok/data"   # Use a named volume for OpenGrok data (indexes)
        -v "${OPENGROK_ETC_VOLUME}:/opengrok/etc"     # Use a named volume for OpenGrok configuration
        "$OPENGROK_IMAGE_NAME"
    )

    # The current user is in the 'docker' group
    echo -e "${GREY}Executing: docker ${params[*]}${RESET}"
    if docker "${params[@]}"; then
        echo -e "${GREEN}✔${GREY} OpenGrok container '${OPENGROK_CONTAINER_NAME}' started successfully.${RESET}"
        echo -e "${LIGHTYELLOW}It might take a few minutes for OpenGrok to initialize and index your source code from ${BOLD}$OPENGROK_SRC_VOLUME${LIGHTYELLOW}.${RESET}"
        echo -e "${LIGHTYELLOW}Once ready, access OpenGrok at: ${BOLD}http://localhost:${OPENGROK_HOST_PORT}${RESET}"
        echo -e "${LIGHTYELLOW}To view container logs: ${BLUE}docker logs -f ${OPENGROK_CONTAINER_NAME}${RESET}"
    else
        echo -e "${RED}Error: Failed to start OpenGrok container '${OPENGROK_CONTAINER_NAME}'.${RESET}"
        echo -e "${LIGHTYELLOW}Check container logs for details: ${BLUE}sudo docker logs ${OPENGROK_CONTAINER_NAME}${RESET}"
        return 1
    fi

    return 0
}

restartOpenGrokContainer() {
    stopOpenGrokContainer
    startOpenGrokContainer
}

addUserIntoLibvirtGrp() {
    echo -e "${COLOR}Configuring Libvirt Group Membership for Current User...${RESET}"

    if ! getent group libvirt > /dev/null; then
        echo -e "${RED}Error: The 'libvirt' group does not exist.${RESET}"
        echo -e "${LIGHTYELLOW}This might indicate that 'libvirt-daemon-system' or similar packages are not installed or not installed correctly.${RESET}"
        echo -e "${LIGHTYELLOW}Please verify libvirt installation. Skipping group membership addition.${RESET}"
        return 1
    fi

    if id -nG "$USER" | grep -qw libvirt; then
        echo -e "${GREEN}✔${GREY} User '$USER' is already a member of the 'libvirt' group.${RESET}"
        printf "  "
        libvirtd --version
        return 0
    fi

    echo -e "${LIGHTYELLOW}Attempting to add user '$USER' to the 'libvirt' group...${RESET}"
    if sudo usermod -aG libvirt "$USER"; then
        echo -e "${GREEN}Successfully added user '$USER' to the 'libvirt' group.${RESET}"
        echo -e "${BOLD}${MAGENTA}IMPORTANT: You must log out and log back in, or open a new shell session (or run 'newgrp libvirt'), for this group membership change to take effect.${RESET}"
    else
        echo -e "${RED}Failed to add user '$USER' to the 'libvirt' group.${RESET}"
        echo -e "${LIGHTYELLOW}Please try adding the user manually: ${BLUE}sudo usermod -aG libvirt $USER${RESET}"
        return 1
    fi

    return 0
}

installSambaServer() {
    echo -e "${COLOR}Starting Samba Server Installation/Configuration${RESET}"
    # Step 1: Check if Samba is already installed
    if command -v smbd &> /dev/null; then
        echo -e "${GREEN}✔${GREY} Samba (smbd) is already installed.${RESET}"
    else
        echo -e "${LIGHTYELLOW}Samba (smbd) not found. Attempting installation...${RESET}"
        if ! sudo apt update; then
            echo -e "${RED}Error: Failed to update apt package list. Aborting Samba installation.${RESET}"
            return 1
        fi
        if ! sudo DEBIAN_FRONTEND=noninteractive apt install -y samba smbclient; then
            echo -e "${RED}Error: Failed to install Samba packages. Aborting.${RESET}"
            return 1
        fi
        echo -e "${GREEN}Samba installed successfully.${RESET}"
    fi

    # Step 2: Configure Samba
    local sambaSysConfFile="/etc/samba/smb.conf"
    local mySambaConfSource="$fMainDir/assets/samba/ubuntu.smb.conf"
    if [ ! -f "$mySambaConfSource" ]; then
        echo -e "${RED}Error: Source Samba configuration file ('smb.conf') not found at ${BLUE}$mySambaConfSource${RESET}"
        echo -e "${LIGHTYELLOW}This script expects a custom 'smb.conf' to be present in the assets.${RESET}"
        exit 1
    fi
    echo -e "${LIGHTYELLOW}Validating Samba configuration with 'testparm'...${RESET}"
    if testparm -s "$mySambaConfSource"; then
        echo -e "${GREEN}✔${GREY} Samba configuration appears valid.${RESET}"
    else
        echo -e "${RED}Error: Samba configuration validation failed (testparm reported errors).${RESET}"
        echo -e "${LIGHTYELLOW}Please review '${BLUE}$mySambaConfSource${LIGHTYELLOW}' and the output above.${RESET}"
        exit 1
    fi
    linkFile "$mySambaConfSource" /etc/samba smb.conf

    # Step 3: Configure Samba to use the current user
    local smbUser="$USER"
    local smbShareGroup=$(id -gn "$USER")

    if [ -z "$smbUser" ]  || [ -z "$smbShareGroup" ]; then
        echo -e "${RED}Error: Could not determine current user or their primary group. Aborting Samba setup.${RESET}"
        return 1
    fi

    echo -e "${LIGHTYELLOW}Samba will be configured for the current user: ${BOLD}$smbUser${RESET}"
    echo -e "${LIGHTYELLOW}The user's primary group will be used for file sharing: ${BOLD}$smbShareGroup${RESET}"

    # Set Samba password for the Samba user, who will be authenticating
    echo -e "${LIGHTYELLOW}Setting Samba password for user '${BOLD}$smbUser${LIGHTYELLOW}'...${RESET}"
    local sambaPassword=""
    local sambaPasswordConfirm=""
    if [[ "$fSambaServer" != "2" ]]; then # Do not set password again
        while true; do
            echo -en "${GREY}Enter new Samba password for user ${BOLD}$smbUser${LIGHTYELLOW} (must not be empty): ${RESET}"
            read -r -s sambaPassword
            echo
            if [ -z "$sambaPassword" ]; then
                echo -e "${RED}Password cannot be empty. Please try again.${RESET}"
                continue
            fi
            echo -en "${GREY}Confirm Samba password: ${RESET}"
            read -r -s sambaPasswordConfirm
            echo
            if [ "$sambaPassword" = "$sambaPasswordConfirm" ]; then
                break
            else
                echo -e "${RED}Passwords do not match. Please try again.${RESET}"
            fi
        done
        # Add/update the Samba user in Samba's database and set the password
        if (echo "$sambaPassword"; echo "$sambaPassword") | sudo smbpasswd -a "$smbUser" -s; then
            echo -e "${GREEN}✔${GREY} Samba password for user '$smbUser' set successfully.${RESET}"
        else
            echo -e "${RED}Error: Failed to set Samba password for user '$smbUser'.${RESET}"
            echo -e "${LIGHTYELLOW}Ensure '$smbUser' is a valid system user and you have sudo privileges.${RESET}"
            return 1
        fi
    fi

    # Step 4: Enable and start Samba services
    # local servicesToManage=("smbd" "nmbd")
    local servicesToManage=("smbd")
    local overallSuccess=true
    for service in "${servicesToManage[@]}"; do
        echo -e "${LIGHTYELLOW}Managing service: $service...${RESET}"
        if sudo systemctl restart "$service"; then
            echo -e "  ${GREEN}✔${GREY} $service restarted successfully.${RESET}"
        else
            echo -e "  ${RED}Error: Failed to restart $service.${RESET}"
            echo -e "  ${LIGHTYELLOW}Check with: sudo systemctl status $service && journalctl -xeu $service${RESET}"
            if [ "$service" == "smbd" ]; then
                overallSuccess=false;
            fi # Critical
        fi
        if sudo systemctl is-enabled "$service" | grep -q "enabled"; then
            echo -e "  ${GREEN}✔${GREY} $service is already enabled to start on boot.${RESET}"
        else
            if sudo systemctl enable "$service"; then
                echo -e "  ${GREEN}✔${GREY} $service enabled successfully for boot start.${RESET}"
            else
                echo -e "  ${RED}Error: Failed to enable $service for boot start.${RESET}"
                if [ "$service" == "smbd" ]; then
                    overallSuccess=false;
                fi # Critical
            fi
        fi
    done
    if [ "$overallSuccess" = false ]; then
        echo -e "${RED}Critical error managing Samba services. Aborting further Samba setup.${RESET}"
        exit 1
    fi

    # Step 5: Configuring Firewall (UFW)
    if command -v ufw &> /dev/null; then
        if sudo ufw status | grep -qw "Status: active"; then
            echo -e "${LIGHTYELLOW}UFW firewall is active. Checking/Adding rules for Samba...${RESET}"
            if sudo ufw status | grep -Ewq "Samba|ALLOW IN.*137,138/(udp|UDP)|ALLOW IN.*139,445/(tcp|TCP)"; then
                 echo -e "${GREEN}✔${GREY} UFW rule for 'Samba' or its specific ports already seems to exist or is allowed.${RESET}"
            else
                echo -e "${LIGHTYELLOW}Attempting to allow Samba through UFW (using 'samba' application profile)...${RESET}"
                if sudo ufw allow 445/tcp; then
                    echo -e "${GREEN}✔${GREY} UFW rule for Samba added successfully.${RESET}"
                    echo -e "${GREY}Current UFW status: ${RESET}"
                    sudo ufw status
                else
                    echo -e "${RED}Warning: Failed to add UFW rule for Samba using 'ufw allow samba'.${RESET}"
                    echo -e "${LIGHTYELLOW}You may need to manually allow TCP ports 445: sudo ufw allow 445/tcp${RESET}"
                fi
            fi
        else
            echo -e "${GREY}UFW firewall is installed but not active. Skipping UFW rule configuration.${RESET}"
        fi
    else
        echo -e "${GREY}UFW firewall manager not found. Skipping UFW configuration.${RESET}"
    fi

    # 6. Final message
    echo -e "\n${GREEN}--- Samba Server Installation/Configuration Process Completed ---${RESET}"
    echo -e "${LIGHTYELLOW}Summary:${RESET}"
    echo -e "  - Samba packages checked/installed."
    echo -e "  - Configuration '${BLUE}$sambaSysConfFile${RESET}' applied/validated."
    echo -e "  - Samba password set for user '${BOLD}$smbUser${RESET}'."
    echo -e "  - Services ${servicesToManage[*]} restarted and enabled."
    echo -e "  - Firewall rules for Samba (if UFW active) checked/added."
    echo -e "\n${BOLD}${LIGHTYELLOW}Next Steps & Testing:${RESET}"
    echo -e "  1. Ensure your share definitions in '$sambaSysConfFile' are correct for your needs."
    echo -e "  2. ${LIGHTYELLOW}Test connection from this machine: ${BLUE}smbclient -L localhost -U $smbUser${RESET}"
    echo -e "     (You will be prompted for the Samba password you just set)."
    echo -e "  3. Test from another client machine on the network using this server's IP address."
    echo -e "     - ${BOLD}On Linux/macOS:${RESET}"
    echo -e "       - Example (list shares): ${BLUE}smbclient --list //SERVER_IP_ADDRESS -U $smbUser${RESET}"
    echo -e "       - Example (connect to a share): ${BLUE}smbclient //SERVER_IP_ADDRESS/sharename -U $smbUser${RESET}"
    echo -e "     - ${BOLD}On Windows:${RESET}"
    echo -e "       - In File Explorer, type ${BLUE}\\\\\\SERVER_IP_ADDRESS${RESET} in the address bar."
    echo -e "       - When prompted, use username '${BOLD}$smbUser${RESET}' and the password you set."
    echo -e "     Or map a network drive via your client OS's file explorer."
    echo -e "  4. Remember to change the ownership of the share directory to '${BOLD}$smbUser${RESET}'."
    echo -e "     You can do this using the '${BLUE}chown -R $smbUser:$smbShareGroup /path/to/share/directory${RESET}' command."
    echo -e "${GREY}If issues arise, check Samba logs (e.g., 'journalctl -u smbd -u nmbd', '/var/log/samba/log.<client_hostname_or_ip>') and 'sudo smbstatus'.${RESET}"

    return 0
}

installLatestPPaWireshark() {
    echo -e "${COLOR}Checking for Wireshark (Wireshark PPA)${RESET}"

    if [ -z "$fWiresharkForce" ] && command -v wireshark &>/dev/null; then
        local wiresharkPolicy
        wiresharkPolicy=$(apt-cache policy wireshark)
        if echo "$wiresharkPolicy" | grep -q "wireshark-dev/stable"; then
            local installedVersion candidateVersion
            installedVersion=$(echo "$wiresharkPolicy" | grep "Installed:" | awk '{print $2}')
            candidateVersion=$(echo "$wiresharkPolicy" | grep "Candidate:" | awk '{print $2}')
            if [ "$installedVersion" != "(none)" ] && [ "$installedVersion" == "$candidateVersion" ]; then
                echo -e "${GREEN}✔${GREY} Wireshark (from PPA) is already installed and up-to-date.${RESET}"
                printf "  "
                wireshark --version | head -n 1
                return 0
            fi
        fi
    fi

    # 1. Add the Wireshark PPA repository
    if grep -qr "wireshark-dev/stable" /etc/apt/sources.list /etc/apt/sources.list.d/ 2>/dev/null; then
        echo -e "${GREEN}✔${GREY} Wireshark PPA already configured.${RESET}"
    else
        echo -e "${LIGHTYELLOW}Adding the Wireshark PPA...${RESET}"
        if ! sudo add-apt-repository -y ppa:wireshark-dev/stable; then
            echo -e "${RED}Error: Failed to add Wireshark PPA. Aborting.${RESET}"
            return 1
        fi
        echo -e "${GREEN}Wireshark PPA added successfully.${RESET}"
    fi

    # 2. Create the preference file to prioritize PPA Wireshark
    local preferenceFilePath="/etc/apt/preferences.d/wireshark-ppa-priority"
    # The 'o' value can be found with 'apt-cache policy wireshark' -> 'LP-PPA-wireshark-dev-stable'
    local preferenceContent
    preferenceContent=$(cat <<'EOF'
Package: *
Pin: release o=LP-PPA-wireshark-dev-stable
Pin-Priority: 1001

Package: wireshark*
Pin: release o=Ubuntu*
Pin-Priority: -1
EOF
)
    echo -e "${LIGHTYELLOW}Setting up APT preferences to prioritize Wireshark PPA...${RESET}"
    if [ -f "$preferenceFilePath" ] && cmp -s <(echo "$preferenceContent") "$preferenceFilePath"; then
        echo -e "${GREY}APT preference file '$preferenceFilePath' already exists and is correctly configured.${RESET}"
    else
        echo "$preferenceContent" | sudo tee "$preferenceFilePath" > /dev/null
        if [ $? -eq 0 ]; then
            echo -e "${GREEN}APT preference file '$preferenceFilePath' created/updated successfully.${RESET}"
        else
            echo -e "${RED}Failed to create/update APT preference file '$preferenceFilePath'. Aborting.${RESET}"
            return 1
        fi
    fi

    # 3. Update package list
    echo -e "${LIGHTYELLOW}Updating package lists...${RESET}"
    if ! sudo apt update; then
        echo -e "${RED}Error: Failed to update apt package list. Aborting.${RESET}"
        return 1
    fi

    # 4. Pre-configure wireshark-common to allow non-root users to capture packets.
    # This avoids the interactive prompt during installation.
    echo -e "${LIGHTYELLOW}Pre-configuring wireshark-common to allow non-root packet capture...${RESET}"
    if ! echo "wireshark-common wireshark-common/install-setuid boolean true" | sudo debconf-set-selections; then
        echo -e "${RED}Warning: Failed to pre-configure wireshark-common via debconf. The installation might prompt for input.${RESET}"
    fi

    # 5. Install Wireshark
    echo -e "${LIGHTYELLOW}Installing Wireshark...${RESET}"
    if ! sudo DEBIAN_FRONTEND=noninteractive apt install -y wireshark; then
        echo -e "${RED}Error: Failed to install Wireshark. Aborting.${RESET}"
        return 1
    fi
    echo -e "${GREEN}Wireshark installed successfully.${RESET}"

    # 6. Add user to the 'wireshark' group
    if ! getent group wireshark > /dev/null; then
        echo -e "${RED}Error: The 'wireshark' group was not created by the installation. Manual configuration may be needed.${RESET}"
    elif id -nG "$USER" | grep -qw wireshark; then
        echo -e "${GREEN}✔${GREY} User '$USER' is already a member of the 'wireshark' group.${RESET}"
    else
        echo -e "${LIGHTYELLOW}Adding current user '$USER' to the 'wireshark' group...${RESET}"
        if sudo usermod -aG wireshark "$USER"; then
            echo -e "${GREEN}Successfully added user '$USER' to the 'wireshark' group.${RESET}"
        else
            echo -e "${RED}Error: Failed to add user '$USER' to the 'wireshark' group.${RESET}"
            return 1
        fi
    fi

    # 7. Final message
    echo -e "\n${BOLD}${MAGENTA}IMPORTANT: You must run 'newgrp wireshark' or you have to log out and log back in, for group changes to take effect.${RESET}"
    echo -e "${LIGHTYELLOW}This will allow you to capture network traffic as a non-root user.${RESET}"
    wireshark --version
    return 0
}

configureTcpdumpCaps() {
    echo -e "${COLOR}Configuring tcpdump for Non-root User Packet Capture${RESET}"

    # Check for required tools first
    if ! command -v tcpdump &> /dev/null; then
        echo -e "${LIGHTYELLOW}Warning: tcpdump command not found. Skipping configuration.${RESET}"
        echo -e "${GREY}Please install it via 'sudo apt install tcpdump' and re-run.${RESET}"
        return 1
    fi
    # `setcap` is a utility for setting file capabilities. By granting the 'cap_net_raw'
    # and 'cap_net_admin' capabilities to the tcpdump binary, we allow non-root users
    # to capture packets without needing full sudo privileges. This is more secure
    # than making tcpdump setuid root. The `libcap2-bin` package provides `setcap`.
    if ! command -v setcap &> /dev/null || ! command -v getcap &> /dev/null; then
        echo -e "${RED}Error: 'setcap' or 'getcap' command not found.${RESET}"
        echo -e "${LIGHTYELLOW}Please install the required package (e.g., 'sudo apt install libcap2-bin') and re-run.${RESET}"
        return 1
    fi

    local tcpdumpPath
    tcpdumpPath=$(command -v tcpdump)
    local requiredCaps="cap_net_admin,cap_net_raw+eip"
    local currentCaps
    currentCaps=$(getcap "$tcpdumpPath" 2>/dev/null)

    # Check if the capabilities are already set
    if [[ "$currentCaps" == *"cap_net_admin,cap_net_raw"* ]]; then
        echo -e "${GREEN}✔${GREY} tcpdump already has the required capabilities for non-root capture.${RESET}"
        printf "  "
        tcpdump --version 2>&1 | head -n 1
        return 0
    fi

    echo -e "${LIGHTYELLOW}Attempting to set network capture capabilities on the tcpdump binary...${RESET}"
    echo -e "${GREY}Executing: sudo setcap '$requiredCaps' '$tcpdumpPath'${RESET}"
    if sudo setcap "$requiredCaps" "$tcpdumpPath"; then
        echo -e "${GREEN}Successfully set capabilities on '$tcpdumpPath'.${RESET}"
        echo -e "${LIGHTYELLOW}Normal users should now be able to run tcpdump for packet capture.${RESET}"
    else
        echo -e "${RED}Error: Failed to set capabilities on the tcpdump binary.${RESET}"
        echo -e "${LIGHTYELLOW}This might be due to a security policy (e.g., AppArmor, SELinux).${RESET}"
        return 1
    fi

    return 0
}

# https://claudiuconstantinbogdan.me/articles/litellm-vertexai-continuedev
startLiteLLMService() {
    echo -e "${COLOR}Installing/Configuring LiteLLM Proxy Server via Docker Compose${RESET}"
    if ! command -v docker &> /dev/null || ! docker compose version &> /dev/null; then
        echo -e "${RED}Error: Docker and Docker Compose are required.${RESET}"; return 1;
    fi

    local liteLLMComposeFile="$LITELLM_DIR/docker-compose.yml"
    if [ ! -d "$LITELLM_DIR/.git" ]; then
        echo -e "${LIGHTYELLOW}Cloning the LiteLLM repository from GitHub...${RESET}"
        # The directory may exist from a previous failed run or other reasons.
        # Remove it to ensure a clean clone.
        rm -rf "$LITELLM_DIR"
        if ! git clone https://github.com/BerriAI/litellm "$LITELLM_DIR"; then
            echo -e "${RED}Failed to clone the litellm repository from GitHub.${RESET}"
            return 1
        fi
    else
        echo -e "${GREEN}✔${GREY} LiteLLM repository already exists in $LITELLM_DIR.${RESET}"
    fi
    if [ ! -f "$liteLLMComposeFile" ]; then
        echo -e "${RED}Error: docker-compose.yml not found in the cloned repository at $LITELLM_DIR.${RESET}"
        return 1
    fi

    local envFile="$LITELLM_DIR/.env"
    local masterKey
    local saltKey
    if [ ! -f "$envFile" ]; then
        echo -e "${LIGHTYELLOW}Creating LiteLLM .env file for environment variables...${RESET}"
        while true; do
            read -r -s -p "Enter LiteLLM Master Key (e.g., sk-1234): " masterKey
            if [ -z "$masterKey" ]; then
                echo -e "${RED}Master Key cannot be empty. Please try again.${RESET}"
            else
                break
            fi
        done

        # Auto-generate a random salt key
        echo -e "${LIGHTYELLOW}Auto generating Salt Key...${RESET}"
        saltKey=$(head /dev/urandom | tr -dc A-Za-z0-9 | head -c 32)
        echo -e "${GREEN}Generated Salt Key: ${BOLD}$saltKey${RESET}"
        {
            echo "LITELLM_MASTER_KEY=$masterKey"
            echo "LITELLM_SALT_KEY=$saltKey"
        } > "$envFile"
        echo -e "${GREEN}✔${GREY} LiteLLM .env file created at ${BLUE}$envFile${RESET}"
    else
        echo -e "${GREEN}✔${GREY} LiteLLM .env file already exists at ${BLUE}$envFile${GREY}, skipping creation.${RESET}"
    fi

    echo -e "${LIGHTYELLOW}Starting LiteLLM proxy...${RESET}"
    if ! (cd "$LITELLM_DIR" && docker compose up -d); then
        echo -e "${RED}Failed to start LiteLLM. Check logs with: cd $LITELLM_DIR && docker compose logs${RESET}"
        return 1
    fi

    echo -e "\n${GREEN}--- LiteLLM proxy started successfully! ---${RESET}"
    echo -e "  - ${BOLD}Access:${RESET}   ${MAGENTA}http://localhost:4000${RESET}"
    echo -e "  - ${BOLD}Manage:${RESET}   Run commands from ${BLUE}$LITELLM_DIR${RESET}"
    echo -e "    - ${GREY}Start/Update: docker compose up -d${RESET}"
    echo -e "    - ${GREY}Stop:         docker compose down${RESET}"
    echo -e "    - ${GREY}Logs:         docker compose logs -f${RESET}"
    echo -e "  - ${BOLD}Investigate:${RESET}   Run commands from ${BLUE}Anywhere${RESET}"
    echo -e "    - ${GREY}Network:      docker network ls${RESET}"
    echo -e "    - ${GREY}Volumes:      docker volume ls${RESET}"
    return 0
}

stopLiteLLMService() {
    echo -e "${LIGHTYELLOW}Stopping LiteLLM Proxy...${RESET}"
    if ! (cd "$LITELLM_DIR" && docker compose down); then
        echo -e "${RED}Failed to stop LiteLLM. Check logs with: cd $LITELLM_DIR && docker compose logs${RESET}"
        return 1
    fi
    echo -e "${GREEN}✔${GREY} LiteLLM proxy stopped.${RESET}"
    return 0
}

restartLiteLLMService() {
    stopLiteLLMService
    startLiteLLMService
}

doCoreJobs() {
    aptInstallPrerequisites    # Install prerequisites for Ubuntu
    createTKSymlinks           # Create Tracked Files symlinks
    installVimPluginsManager   # Install Vim Plugins Manager
    installTmuxPluginsManager  # Install Tmux Plugins Manager
    createToolsSymlinks        # Create tool symlinks
    relinkSysCmds              # Relink system commands
    createExtraSymlinks        # Create extra symlinks
    buildBatTheme              # Build bat theme
    buildExtraFonts            # Build extra fonts
    addUserIntoLibvirtGrp      # Add user into libvirt group
    installLatestGitLfs        # Install Git LFS (PackageCloud)
    installLatestRimePinyin    # Install Rime Pinyin input method
    installLatestPPaFirefox    # Install Firefox (Mozilla PPA)
    installLatestPPaDocker     # Install Docker
    installLatestPPaWireshark  # Install Wireshark (Mozilla PPA)
    configureTcpdumpCaps       # Configure tcpdump for non-root user packet capture
    installLatestGithubClangd  # Install Github Clangd
    stopUnnecessaryServices    # Stop unnecessary services
}

doEarlyExitJobs() {
    [ -n "$fLinkClangFormatPath" ] && { linkClangFormat "$1"; exit 0; }
    [ -n "$fSambaServer" ]         && { installSambaServer; exit 0; }
    case "$fVncServer" in
        1) startVncServer;       exit 0 ;;
        2) stopVncServer;        exit 0 ;;
        3) restartVncServer;     exit 0 ;;
    esac
    case "$fOpenGrokContainer" in
        1) startOpenGrokContainer;   exit 0 ;;
        2) stopOpenGrokContainer;    exit 0 ;;
        3) restartOpenGrokContainer; exit 0 ;;
        4) startOpenGrokIndexer;     exit 0 ;;
    esac
    case "$fLiteLLMService" in
        1) startLiteLLMService;   exit 0 ;;
        2) stopLiteLLMService;    exit 0 ;;
        3) restartLiteLLMService; exit 0 ;;
    esac
}

showUfwStatus() {
    if ! command -v ufw &> /dev/null || sudo ufw status | grep -qw "Status: inactive"; then
        return
    fi
    echo -e "${COLOR}Checking UFW Firewall Status${RESET}"
    sudo ufw status verbose
    echo -e "${LIGHTYELLOW}Tip: Common UFW commands:${RESET}"
    echo -e "  ${GREY}- sudo ufw status        : Check if the firewall is active.${RESET}"
    echo -e "  ${GREY}- sudo ufw enable        : Enable the firewall.${RESET}"
    echo -e "  ${GREY}- sudo ufw disable       : Disable the firewall.${RESET}"
    echo -e "  ${GREY}- sudo ufw allow <port>  : Allow traffic on a specific port (e.g., sudo ufw allow 445/tcp).${RESET}"
    echo -e "  ${GREY}- sudo ufw deny <port>   : Deny traffic on a specific port.${RESET}"
    echo -e "  ${GREY}- sudo ufw delete allow <port>: Delete an allow rule (e.g., sudo ufw delete allow 445/tcp).\n${RESET}"
}

main() {
    doEarlyExitJobs "$1"
    checkOSAndArch
    checkTlsConnection
    createEssentialPaths
    if [ "$fOSCategory" == "debian" ]; then
        doCoreJobs
        changeTMOUTToWritable
        setTimeZone
        createFirstTimeFile
    elif [ "$fOSCategory" == "mac" ]; then
        createTKSymlinks
        installTmuxPluginsManager
        installVimPluginsManager
        createExtraSymlinks
        buildBatTheme
        buildExtraFonts
    fi
    showUfwStatus
}

main "$@"
