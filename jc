#!/bin/bash
# shellcheck disable=SC2155
# set -x

# Tracking directories
fMainDir=$(cd "$(dirname "$(readlink -f "$0")")" || exit; pwd)
fTKFilesDir=$fMainDir/track-files
fTKCompDir=$fMainDir/completion
fTKVimColorsDir=$fMainDir/assets/vim-colors
fTKBatThemeDir=$fMainDir/assets/bat-themes
fTKFontDir=$fMainDir/assets/fonts
fTKFontConfigDir=$fMainDir/assets/fontconfig
fTKClangdConfig=$fMainDir/assets/clangd/config.yaml
fTKtemplateDir=$fMainDir/template
fTKToolsDir=$fMainDir/ftnt-tools
fJCPath=$fMainDir/jc
fUpdateClangd=
fLinkClangFormatPath=
fLinkNodeJs=
fDownloads=$HOME/Downloads
fFirstTimeFile=$fMainDir/".has_been_invoked"
# Misc
fVimPlugsManagerPath=$HOME/.vim/autoload/plug.vim
fzfBinPath=$HOME/.vim/bundle/fzf/bin/fzf
# A fzf plugin: fzf-tab-completion
fzfTabCompPath=$HOME/.vim/bundle/fzf-tab-completion/bash/fzf-bash-completion.sh
fBackupDir="$HOME/Public/env.bak"
fOSCategory=debian # ubuntu/debian is the default OS type
fArch=
fNoInstallTools=
fForceUpdate=
# Constants
SCRIPT_NAME=$(basename $0)
# Colors
RED='\033[31m'
GREEN='\033[32m'
NORMAL='\033[0m'
MAGENTA='\033[35m'
LIGHTYELLOW='\033[93m'
BOLD='\033[1m'
NORMAL='\033[0m'
BLUE='\033[34m'
GREY='\033[90m'
RESET='\033[0m'
COLOR=$MAGENTA

usage() {
    cat << _EOF
Usage: $SCRIPT_NAME [OPTIONS]

This script is used to set up the coding environment in my predefined way.

Options:
    -h, --help              Print this help message
    -n, --no-tools          Don't install tools
    -d, --debug             Enable debug mode
    -u, --update            Force an update of prerequisites
    --clangd                Update clangd to the latest released version
    --link-clang-format     Link clang-format to current path
    --link-nodejs           Link nodejs from VsCode Server to current path

Examples:
    $SCRIPT_NAME -h
    $SCRIPT_NAME --link-clang-format \$HOME/crosslv

_EOF
exit 0
}

SHORTOPTS="hdnu"
LONGOPTS="help,debug,no-tools,update,clangd,link-clang-format::,link-nodejs"

# Use getopt to parse command-line options
if ! PARSED=$(getopt --options $SHORTOPTS --longoptions "$LONGOPTS" --name "$0" -- "$@"); then
    echo -e "${COLOR}Error: Failed to parse command-line options.${RESET}" >&2
    exit 1
fi

# Reset positional parameters to the parsed values
eval set -- "$PARSED"

while true; do
    case "$1" in
        -n|--no-tools)
            fNoInstallTools=true
            shift
            ;;
        -u|--update)
            fForceUpdate=true
            shift
            ;;
        --clangd)
            fUpdateClangd=true
            shift
            ;;
        --link-clang-format)
            # $1 is '--link-clang-format'
            # $2 is an empty string '' no matter whether it has an argument
            # The argument if provided will be put in sequence in the positional parameters
            # Exp: $ jc huhu --link-clang-format ~/ he
            #          --link-clang-format '' -- 'huhu' '/home/user1/' 'he'
            # CRITICAL: Always shift 2 to consume both the option token ($1)
            # and its argument/empty placeholder token ($2).
            fLinkClangFormatPath="$PWD"
            shift 2
            ;;
        --link-nodejs)
            fLinkNodeJs=true
            shift
            ;;
        -d|--debug)
            set -x
            echo -e "${COLOR}Debug mode enabled${RESET}"
            shift
            ;;
        -h|--help)
            usage
            ;;
        --)
            shift
            break
            ;;
        *)
            echo -e "${RED}Error: Invalid option: $1${RESET}" >&2
            exit 1
            ;;
    esac
done

checkSudoPrivilege() {
    echo -e "${COLOR}Checking sudo privilege${RESET}"
    # Check if the user can run sudo without a password
    if sudo -n true 2>/dev/null; then
        echo "User likely has passwordless sudo access."
    else
        echo "User likely does not have passwordless sudo access or needs a password."
        exit 0
    fi
}

checkOSCategory() {
    echo -e "${COLOR}Checking OS platform${RESET}"
    if [[ -f /etc/os-release ]]; then
        local osName
        osName=$(awk -F= '/^ID=/{print $2}' /etc/os-release)
        fArch=$(uname -m)

        case "$osName" in
            "ubuntu")
                fOSCategory=debian
                echo -e "The current OS type is ${LIGHTYELLOW}Ubuntu${RESET}. Arch: ${LIGHTYELLOW}$fArch${RESET}"
                ;;
            "centos")
                fOSCategory=redhat
                echo "The current OS type is CentOS. Arch: $fArch"
                echo "We currently do not support CentOS."
                exit
                ;;
            "raspbian")
                fOSCategory=debian
                echo "The current OS type is raspbian. Arch: $fArch"
                ;;
            *)
                echo "We currently do not support this OS type."
                exit
                ;;
        esac
    elif [[ $(uname) == "Darwin" ]]; then
        fOSCategory=mac
        echo "The current OS type is macOS (Mac)."
    else
        echo "The OS type is not supported or could not be determined."
        echo "We currently do not support this OS type."
        exit 1
    fi
}

updatePrerequisitesForDebian() {
    [ ! -f "$fFirstTimeFile" ] && fForceUpdate=true
    [ -z "$fForceUpdate" ] && return
    echo -e "${COLOR}Updating prerequisites for Ubuntu${RESET}"

    checkSudoPrivilege
    prerequisitesForUbuntu=(
        tmux # Basic tools
        rsync
        fd-find # fd
        ripgrep # rg
        universal-ctags
        openssl
        libssl-dev
        gdb
        bat
        curl
        jq # JSON parser
        xsel # X11 clipboard
        xclip
        libcurl4
        libcurl4-openssl-dev
        dos2unix
        expect
        sshfs
        sshpass
        shellcheck
        net-tools
        nftables
        bash-completion
        openssh-server
        python3-dev
        ffmpeg
        nodejs # Node.js
        npm
        build-essential # build essentials
        cmake
        libboost-all-dev
        gnupg
        lsb-release
        ragel
        sqlite3
        libsqlite3-dev
        libpcap-dev
        libvirt-clients
        texinfo
        libisl-dev
        libgmp-dev
        libncurses-dev
        source-highlight
        libsource-highlight-dev
        libmpfr-dev
        libtool
        autoconf
        gettext
        autopoint
        bear # llvm & clangd
        libear
        gdm3 # gnome desktop
        ubuntu-desktop
        gnome-keyring
        xfce4
        xfce4-goodies
        tigervnc-standalone-server # TigerVNC
        tigervnc-xorg-extension
        tigervnc-viewer
        remmina # remote desktop client
        samba
        smbclient
    )

    sudo apt remove -y wireshark lightdm
    sudo apt update
    sudo apt install -y "${prerequisitesForUbuntu[@]}"
    sudo apt autoremove -y
}

updatePrequesitesForMac() {
    checkSudoPrivilege
    prerequisitesForMac=(
        yt-dlp
        fzf
        fd
        bat
        vim
    )

    echo -e "${COLOR}Updating prerequisites for macOS${RESET}"
    brew update
    brew install "${prerequisitesForMac[@]}"
}

setTimeZone() {
    echo -e "${COLOR}Setting timezone to Vancouver${RESET}"
    # check time zone if it is already vancouver
    if [ $(timedatectl | grep "Time zone" | awk '{print $3}') == "America/Vancouver" ]; then
        echo -e "${GREY}Time zone is already vancouver${RESET}"
        return
    fi
    sudo timedatectl set-timezone America/Vancouver
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Success!${RESET}"
    else
        echo -e "${RED}Failed!${RESET}"
        exit 1
    fi
}

installTmuxPluginsManager() {
    if [ -d ~/.tmux/plugins/tpm ]; then
        return
    fi
    echo -e "${COLOR}Installing TPM${RESET}"
    git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Success!${RESET}"
    else
        echo -e "${RED}Failed!${RESET}"
        exit 1
    fi
}

updateVimPlugins (){
    echo -e "${COLOR}Installing Vim Plugins Manager${RESET}"

    if [ ! -f ~/.vimrc ]; then
        echo "No .vimrc found, Abort!"
        exit 1
    fi

    if [ ! -f "$fVimPlugsManagerPath" ]; then
        # use the --insecure option to avoid certificate check
        curl --insecure -fLo "$fVimPlugsManagerPath" --create-dirs \
        https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
    else
        echo -e "${GREY}Vim Plug is already installed${RESET}"
    fi

    echo -e "${COLOR}Updating Vim Plugins${RESET}"
    vim +PlugInstall +PlugUpdate +qall
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Success!${RESET}"
    else
        echo -e "${RED}Failed!${RESET}"
        exit 1
    fi
}

tackleTheExceptions() {
    if [ "$(hostname)" != "VAN-935558-PC0" ]; then
        return
    fi
    echo -e "${COLOR}Tackling exceptions${RESET}"
    # Copy back the privileged git config.
    gitconfigCheckFile=$HOME/.gitconfig.fortinet
    if [ -f "$gitconfigCheckFile"  ]; then
        echo -e "${LIGHTYELLOW}The privileged file $gitconfigCheckFile exists.${RESET}"
        echo -e "Relink $HOME/.gitconfig to $gitconfigCheckFile"
        ln -sf "$gitconfigCheckFile" "$HOME"/.gitconfig
        if [ $? -eq 0 ]; then
            echo -e "${GREEN}Success!${RESET}"
        else
            echo -e "${RED}Failed!${RESET}"
            exit 1
        fi
    fi
}

# linkFile: Creates a symbolic link for a file to a specified destination (dir).
#
# Usage:
#   linkFile /path/of/source/file /path/to/destination/dir
#   e.g., linkFile ~/myfile.txt /data/backup
#
# Arguments:
#   $1 - Source file
#   $2 - Destination directory path to link to
#   $3 - New link name (optional, default: as is)
#
# Returns:
#   0 if successful, 1 if already linked, 2 if source file does not exist
# ln [OPTION] TARGET LINK_NAME
linkFile() {
    local target="$1"      # The target to link
    local linkPath="$2"    # Destination directory to link to
    local newLinkName="$3" # New link name (optional, default: as is)

    [ ! -d "$linkPath" ] && echo "Destination directory $linkPath does not exist, abort!" && exit 1
    local filename=$(basename "$target")
    local linkName=${newLinkName:-$filename}
    local src="$target"
    local dst="$linkPath/${linkName}"

    [ ! -f "$target" ] && echo "Source file $target does not exist, abort!" && exit 1
    if [ -f "$dst" ] && [ ! -L "$dst" ]; then
        [ ! -d "$fBackupDir" ] && mkdir -p "$fBackupDir"
        echo -e "${BLUE}Warning: $dst is not a link, backing it up into $fBackupDir${RESET}"
        mv "$dst" "$fBackupDir/${linkName}.bak"
    fi

    if [ -L "$dst" ] && [ "$(readlink "$dst")" == "$src" ]; then
        echo -e "${GREY}${linkName} is already well linked.${RESET}"
        return 1
    fi

    echo -e "${LIGHTYELLOW}Creating symlink${RESET}: ${linkName} -> $src"
    ln -sf "$target" "$dst"
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Success!${RESET}"
    else
        echo -e "${RED}Failed!${RESET}"
        exit 2
    fi
}

# linkFiles: Creates symbolic links for all files in a source directory to a specified destination directory.
#
# Usage:
#   linkFiles /path/to/source/dir /path/to/destination/dir [linknamePrefix]
#   e.g., linkFiles ~/mydir /data/backup
#
# Arguments:
#   $1 - Source directory
#   $2 - Destination directory path to link to
#   $3 - Prefix for destination filename (optional, Exp: . for hidden files)
#
# Returns:
#   0 if successful, 1 if already linked, 2 if source directory does not exist
# ln [OPTION] TARGET LINK_NAME
linkFiles() {
    local targetDir="$1"        # Source directory
    local linkPath="$2"         # Destination directory
    local linknamePrefix="$3"   # Prefix for destination filename. Exp: . for hidden files

    echo -e "${COLOR}Creating symlinks From ${linkPath}/* To $(basename "$targetDir")/*${RESET}"
    [ ! -d "$targetDir" ] && echo "Source directory $targetDir does not exist, abort!" && exit 1
    [ ! -d "$linkPath" ] && mkdir -p "$linkPath"

    for file in "$targetDir"/*; do
        linkFile "$file" "$linkPath" "${linknamePrefix}$(basename "$file")"
    done

    if [ "$linkPath" == "$HOME" ]; then
        return
    fi

    COLOR=$GREEN
    find "$linkPath" -type l ! \
            -exec test -e {} \; \
            -exec rm -f {} \; \
            -exec echo -e "${COLOR}Deleting broken link: {}${RESET}" \;
    COLOR=$MAGENTA
}

# relinkCommand: Creates a symbolic link for a system command with a new name in new path.
#
# Usage:
#   relinkCommand <sysCmd> <linkName> [linkPath]
#   e.g., relinkCommand batcat bat
#
#   ~/.usr/bin/bat -> /bin/batcat
#
# Arguments:
#   $1 - System command to link
#   $2 - Link name (new name)
#   $3 - Optional destination directory path (new path, default: $HOME/.usr/bin)
#
# Returns:
#   0 if successful, 1 if already linked, 2 if system command does not exist
# ln [OPTION] TARGET LINK_NAME
relinkCommand() {
    local sysCmd=$1
    local linkName=$2
    local linkPath=$HOME/.usr/bin
    [ -n "$3" ] && linkPath=$3
    local dst=$linkPath/$linkName
    local exePrefix=

    [ ! -d "$linkPath" ] && mkdir -p "$linkPath"
    sysCmdPath=$(command -v "$sysCmd")
    if [ -z "$sysCmdPath" ]; then
        echo "${sysCmd} is not installed"
        return 2
    fi

    if [ -L "$dst" ] && [ "$(readlink "$dst")" == "$sysCmdPath" ]; then
        echo -e "${GREY}${linkName} is already linked to ${sysCmdPath}${RESET}"
        return 1
    fi

    echo -e "${COLOR}Creating symlink: ${linkName} -> syscmd: ${sysCmdPath}${RESET}"
    for _ in {1..2}; do
        $exePrefix ln -sf "$sysCmdPath" "$dst"
        if [ $? -eq 0 ]; then
            echo -e "${GREEN}Success!${RESET}"
            exePrefix=
        else
            echo -e "${RED}Failed!${RESET}"
            exePrefix="sudo "
            continue
        fi
    done
}

buildBatTheme() {
    # https://github.com/sharkdp/bat/tree/master/assets/themes
    echo -e "${COLOR}Building bat theme${RESET}"
    local batThemeDir=$HOME/.config/bat/themes
    local needBuild=
    [ ! -d "$batThemeDir" ] && mkdir -p "$batThemeDir"

    for theme in "$fTKBatThemeDir"/*; do
        linkFile "$theme" "$batThemeDir"
        if [ $? -eq 1 ]; then
            continue
        fi
        needBuild=true
    done

    [ -z "$needBuild" ] && return
    bat cache --build
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Success!${RESET}"
    else
        echo -e "${RED}Failed!${RESET}"
        exit 1
    fi
}

buildExtraFonts() {
    echo -e "${COLOR}Building extra fonts${RESET}"
    local needBuild=
    local fontConfigDir="$HOME/.config/fontconfig/conf.d"
    local fontDir=$HOME/.local/share/fonts
    [ ! -d "$fontDir" ] && mkdir -p "$fontDir"
    [ ! -d "$fontConfigDir" ] && mkdir -p "$fontConfigDir"

    for fontConfig in "$fTKFontConfigDir"/*; do
        linkFile "$fontConfig" "$fontConfigDir"
        if [ $? -eq 1 ]; then
            continue
        fi
    done

    for font in "$fTKFontDir"/*; do
        local fontFile=$(basename "$font")
        local fontExists=$(fc-list | grep -i "$fontFile")
        if [ -n "$fontExists" ]; then
            echo -e "${GREY}Font $fontFile already exists in system.${RESET}"
            continue
        fi

        linkFile "$font" "$fontDir"
        if [ $? -eq 1 ]; then
            continue
        fi
        needBuild=true
    done

    [ -z "$needBuild" ] && return
    echo -e "${COLOR}Building font cache...${RESET}"
    sudo fc-cache -fv
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Success!${RESET}"
    else
        echo -e "${RED}Failed!${RESET}"
        exit 1
    fi
}

changeTMOUTToWritable() {
    echo -e "${COLOR}Changing TMOUT to writable${RESET}"
    # TMOUT is readonly in /etc/profile, change it to writable so that we can unset it in .bashrc
    if ! grep -q "TMOUT" /etc/profile; then
        echo -e "${GREY}TMOUT is not found in /etc/profile.${RESET}"
        return
    fi

    if grep -q "^readonly TMOUT" /etc/profile; then
        echo -e "${GREY}TMOUT is readonly in /etc/profile, change it to writable${RESET}"
    else
        echo -e "${GREY}TMOUT is already writable in /etc/profile${RESET}"
        return
    fi

    sudo sed -i 's/^readonly TMOUT/# readonly TMOUT/g' /etc/profile
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Success!${RESET}"
    else
        echo -e "${RED}Failed!${RESET}"
        exit 1
    fi
}

createTKSymlinks() {
    # The directories are guaranteed to exist when this function is called.
    linkFiles "$fTKFilesDir" "$HOME" "."
    linkFiles "$fTKCompDir" "$HOME/.bash_completion.d"
    linkFiles "$fTKVimColorsDir" "$HOME/.vim/colors"
}

linkNodeJsFromCodeServer() {
    [ -z $fLinkNodeJs ] && return
    local vscodeServerDir="$HOME/.vscode-server"
    if [ ! -d "$vscodeServerDir" ]; then
        echo -e "${LIGHTYELLOW}VSCode Server directory not found: ${BLUE}$vscodeServerDir${RESET}"
        echo -e "${LIGHTYELLOW}Skipping linking Node.js from VSCode Server.${RESET}"
        return
    fi
    echo -e "${LIGHTYELLOW}Searching for Node.js executable in ${BLUE}$vscodeServerDir${RESET}..."
    local latestNodeJsPath=$(find "$vscodeServerDir" -name "node" -type f -executable \
            -exec stat -c '%W %n' {} \; 2>/dev/null | sort -nr | cut -d' ' -f2- | head -n1)

    echo -e "${GREEN}Found latest Node.js executable at: ${BLUE}$latestNodeJsPath${RESET}"
    linkFile "$latestNodeJsPath" "$HOME/.usr/bin" "node"
}

createExtraSymlinks() {
    if [ -z "$fNoInstallTools" ]; then
        linkFiles "$fTKToolsDir" "$HOME/.usr/bin"
        linkFiles "$fTKtemplateDir" "$HOME/Templates"
    fi

    echo -e "${COLOR}Creating extra symlinks${RESET}"
    # The directories are guaranteed to exist when this function is called.
    linkFile "$fTKClangdConfig" "$HOME/.config/clangd"
    linkFile "$fzfTabCompPath" "$HOME/.bash_completion.d" "fzf_tab_completion.bash"
    linkFile "$fzfBinPath" "$HOME/.usr/bin"
    linkFile "$fJCPath" "$HOME/.usr/bin"

    echo -e "${COLOR}Relinking system commands${RESET}"
    relinkCommand "batcat" "bat"
    relinkCommand "fdfind" "fd"
    relinkCommand "bash" "sh" "/bin/"

    linkNodeJsFromCodeServer
}

performSanityCheck() {
    local dirsToCheck=(
        "$fBackupDir"
        "$HOME/Downloads"
        "$HOME/Templates"
        "$HOME/.bash_completion.d"
        "$HOME/.usr/bin"
        "$HOME/.local/share/fonts"
        "$HOME/.config/bat/themes"
        "$HOME/.config/fontconfig/conf.d"
        "$HOME/.config/clangd"
    )

    for dir in "${dirsToCheck[@]}"; do
        if [ ! -d "$dir" ]; then
            echo -e "${LIGHTYELLOW}Creating directory: ${BLUE}$dir${RESET}"
            mkdir -p "$dir"
            if [ $? -ne 0 ]; then
                echo -e "${RED}Error: Failed to create directory $dir${RESET}"
                exit 1
            fi
        fi
    done

    cd "$fMainDir" || exit
}

installUpdateClangd() {
    [ -z "$fUpdateClangd" ] && return
    echo -e "${COLOR}Updating Clangd${RESET}"
    # Check if the current architecture is arm64
    if [ "$fArch" == "aarch64" ]; then
        sudo apt install clangd -y
        return
    fi

    if ! command -v jq &> /dev/null; then
        echo -e "${RED}Error: jq is required but not installed. Please install jq first.${RESET}"
        return 1
    fi

    local currentVersion=""
    local clangdPath=$(command -v clangd 2>/dev/null)
    if [ -n "$clangdPath" ]; then
        currentVersion=$($clangdPath --version | head -n1 | grep -oP 'version \K[0-9]+\.[0-9]+\.[0-9]+' || echo "")
        echo -e "Current clangd version: ${BLUE}$currentVersion${RESET}"
    else
        echo -e "${LIGHTYELLOW}clangd is not currently installed${RESET}"
        currentVersion="0.0.0"
    fi

    # Get the latest stable release version and download URL
    echo -e "${LIGHTYELLOW}Fetching latest Clangd binary information${RESET}"
    # 20.1.0
    # https://github.com/clangd/clangd/releases/download/20.1.0/clangd-linux-20.1.0.zip
    local output=$(curl -s https://api.github.com/repos/clangd/clangd/releases |
        jq -r '[.[] | select(.prerelease == false)] | .[0] |
               .name, (.assets[] | select(.name | contains("clangd-linux")) | .browser_download_url)')
    mapfile -t lines <<< "$output"
    local latestVersion="${lines[0]}"
    local downloadUrl="${lines[1]}"
    if [ -z "$latestVersion" ] || [ "$latestVersion" == "null" ]; then
        echo -e "${RED}Error: Failed to get latest version information${RESET}"
        return 1
    fi

    echo -e "Latest available clangd version: ${COLOR}$latestVersion${RESET}"
    if [ -n "$currentVersion" ]; then
        if [ "$(printf '%s\n' "$latestVersion" "$currentVersion" | sort -V -r | head -n1)" == "$currentVersion" ]; then
            echo -e "${GREY}No update needed. Current version is up to date.${RESET}"
            return 0
        fi
    fi

    echo -e "${LIGHTYELLOW}Downloading latest version of Clangd${RESET}"
    local fileName=$(basename "$downloadUrl")
    local downloadDst="$fDownloads/$fileName"
    if [ -f "$downloadDst" ]; then
        echo -e "${GREY}File $fileName already exists in $fDownloads, skipping download.${RESET}"
    else
        curl -L -o "$downloadDst" "$downloadUrl"
        if [ $? -ne 0 ]; then
            echo -e "${RED}Error: Failed to download the latest version${RESET}"
            return 1
        fi
    fi

    cd "$fDownloads" || exit 1
    local peekInfo=$(zipinfo -1 "$downloadDst" | head -n 1)
    local extractDir="$fDownloads/$(dirname "$peekInfo")"
    if [ -d "$extractDir" ]; then
        echo -e "${GREY}Directory $extractDir already exists, skipping extraction.${RESET}"
    else
        echo -e "${LIGHTYELLOW}Extracting Clangd${RESET}"
        unzip "$downloadDst"
        if [ ! -d "$extractDir" ]; then
            echo -e "${RED}Error: Failed to extract the downloaded file${RESET}"
            exit 1
        fi
        echo -e "${GREEN}Successfully extracted to $extractDir${RESET}"
    fi

    # find binary named clangd under the extracted directory
    local clangdBinary=$(find "$extractDir" -type f -name "clangd" -executable | head -n 1)
    if [ -z "$clangdBinary" ]; then
        echo -e "${RED}Error: Failed to find the clangd binary in the extracted directory${RESET}"
        return 1
    fi

    linkFile "$clangdBinary" "$HOME/.usr/bin"
}

createFirstTimeFile() {
    [ -f "$fFirstTimeFile" ] && return
    touch "$fFirstTimeFile"
}

installDocker() {
    if command -v docker &> /dev/null; then
        echo -e "${GREY}Docker is already installed.${RESET}"
        docker --version
        return 0
    fi

    echo -e "${COLOR}Attempting to install Docker${RESET}"

    # 1. Uninstall old versions
    echo -e "${LIGHTYELLOW}Uninstalling old Docker versions (if any)...${RESET}"
    sudo apt-get remove -y docker docker-engine docker.io containerd runc > /dev/null 2>&1
    sudo apt-get autoremove -y > /dev/null 2>&1
    echo -e "${GREY}Old versions uninstalled/autoremoved (if any existed).${RESET}"

    # 2. Set up the repository
    echo -e "${LIGHTYELLOW}Setting up Docker repository...${RESET}"
    if ! sudo apt-get update; then
        echo -e "${RED}Failed to update apt package list.${RESET}"
        exit 1
    fi

    if ! sudo install -m 0755 -d /etc/apt/keyrings; then
        echo -e "${RED}Failed to create /etc/apt/keyrings directory.${RESET}"
        exit 1
    fi

    # Download Docker's official GPG key
    if ! curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg; then
        echo -e "${RED}Failed to download or dearmor Docker GPG key.${RESET}"
        exit 1
    fi
    if ! sudo chmod a+r /etc/apt/keyrings/docker.gpg; then
        echo -e "${RED}Failed to set permissions for Docker GPG key.${RESET}"
        exit 1
    fi

    # Add Docker repository to Apt sources
    # shellcheck disable=SC2024 # sudo tee is generally fine with output redirection here.
    if ! echo \
      "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
      $(lsb_release -cs) stable" | \
      sudo tee /etc/apt/sources.list.d/docker.list > /dev/null; then
        echo -e "${RED}Failed to add Docker repository to apt sources.${RESET}"
        exit 1
    fi
    echo -e "${GREEN}Docker repository set up successfully.${RESET}"

    # 3. Install Docker Engine
    echo -e "${LIGHTYELLOW}Installing Docker Engine...${RESET}"
    if ! sudo apt-get update; then
        echo -e "${RED}Failed to update apt package list after adding Docker repo.${RESET}"
        exit 1
    fi
    if ! sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin; then
        echo -e "${RED}Failed to install Docker Engine packages.${RESET}"
        exit 1
    fi
    echo -e "${GREEN}Docker Engine installed successfully.${RESET}"

    # 4. Verify installation
    echo -e "${LIGHTYELLOW}Verifying Docker installation by running hello-world...${RESET}"
    if sudo docker run hello-world; then
        echo -e "${GREEN}Docker hello-world container ran successfully.${RESET}"
    else
        echo -e "${RED}Docker hello-world container failed to run. Docker might be installed but requires attention.${RESET}"
    fi

    # 5. Post-installation steps
    echo -e "${LIGHTYELLOW}Configuring Docker to run without sudo for current user ($USER)...${RESET}"
    if ! getent group docker > /dev/null; then
        echo -e "${GREY}Docker group does not exist, creating it...${RESET}"
        if ! sudo groupadd docker; then
            echo -e "${RED}Failed to create 'docker' group. You may need to do this manually.${RESET}"
        else
            echo -e "${GREEN}'docker' group created.${RESET}"
        fi
    else
        echo -e "${GREY}'docker' group already exists.${RESET}"
    fi

    if getent group docker > /dev/null; then
        if sudo usermod -aG docker "$USER"; then
            echo -e "${LIGHTYELLOW}IMPORTANT: You must log out and log back in, or run 'newgrp docker' in your terminal, for this change to take full effect.${RESET}"
        else
            echo -e "${RED}Failed to add user $USER to the 'docker' group. You may need to do this manually (e.g., sudo usermod -aG docker \"\$USER\").${RESET}"
        fi
    else
        echo -e "${RED}Cannot add user to 'docker' group as the group does not exist or could not be created.${RESET}"
    fi

    echo -e "${GREEN}Docker installation and basic configuration process completed.${RESET}"
}

linkClangFormat() {
    [ -z "$fLinkClangFormatPath" ] && return

    local argVal="$1"
    if [ -n "$argVal" ]; then
        if [ ! -d "$argVal" ]; then
            echo -e "${RED}Error: Link path '$argVal' is not a valid directory.${RESET}" >&2
            exit 1
        fi
        fLinkClangFormatPath="$argVal"
    fi

    local realClangFormatPath=$fMainDir/assets/clangd/clang-format
    echo -e "${LIGHTYELLOW}Linking clang-format to $fLinkClangFormatPath/.clang-format${RESET}"
    linkFile "$realClangFormatPath" "$fLinkClangFormatPath" .clang-format
    exit 0
}

doCoreJobs() {
    createTKSymlinks
    updateVimPlugins
    installTmuxPluginsManager
    installDocker
    installUpdateClangd
    createExtraSymlinks
}

main() {
    linkClangFormat "$1"
    checkOSCategory
    performSanityCheck
    if [ "$fOSCategory" == "debian" ]; then
        updatePrerequisitesForDebian
        doCoreJobs
        buildBatTheme
        buildExtraFonts
        tackleTheExceptions
        setTimeZone
        changeTMOUTToWritable
        createFirstTimeFile
    elif [ "$fOSCategory" == "mac" ]; then # Deprecated
        createTKSymlinks
        installTmuxPluginsManager
        updateVimPlugins
        createExtraSymlinks
        buildBatTheme
        buildExtraFonts
    fi
}

main "$@"
