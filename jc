#!/bin/bash
# shellcheck disable=SC2155
# set -x

# Tracking directories
fMainDir=$(cd "$(dirname "$(readlink -f "$0")")" || exit; pwd)
fTKFilesDir=$fMainDir/track-files
fTKCompDir=$fMainDir/completion
fTKVimColorsDir=$fMainDir/assets/vim-colors
fTKBatThemeDir=$fMainDir/assets/bat-themes
fTKFontDir=$fMainDir/assets/fonts
fTKFontConfigDir=$fMainDir/assets/fontconfig
fTKClangdConfig=$fMainDir/assets/clangd/config.yaml
fTKtemplateDir=$fMainDir/template
fTKToolsDir=$fMainDir/ftnt-tools
fDownloads=$HOME/Downloads
fJCPath=$fMainDir/jc
fFirstTimeFile=$fMainDir/".has_been_invoked"
fUpdateClangd=
fUpdateDocker=
fLinkClangFormatPath=
fLinkNodeJs=
fTlsInsecure=
fRimePinyinInputMethod=
# Misc
fVimPlugsManagerPath=$HOME/.vim/autoload/plug.vim
fzfBinPath=$HOME/.vim/bundle/fzf/bin/fzf
# A fzf plugin: fzf-tab-completion
fzfTabCompPath=$HOME/.vim/bundle/fzf-tab-completion/bash/fzf-bash-completion.sh
fBackupDir="$HOME/Public/env.bak"
fOSCategory=debian # ubuntu/debian is the default OS type
fArch=
fNoInstallTools=
# VNC server
fVncSimplePort=9
fVncRealPort="590${fVncSimplePort}"
fVncResolution=2060x1080
fVncServer= # 1: start VNC server; 2: kill VNC server 3: restart VNC server
# Deb Firefox
fInstallDebFirefox=
# Force options
fForceInstallPrerequisites=
fForceChinesePinyin=
# Constants
SCRIPT_NAME=$(basename $0)
# Colors
RED='\033[31m'
GREEN='\033[32m'
MAGENTA='\033[35m'
LIGHTYELLOW='\033[93m'
BOLD='\033[1m'
BLUE='\033[34m'
GREY='\033[90m'
CYAN='\033[36m'
RESET='\033[0m'
COLOR=$MAGENTA

usage() {
    cat << _EOF
Usage: $SCRIPT_NAME [OPTIONS]

This script is used to set up the coding environment in my predefined way.

Options:
    -h, --help               Print this help message
    -n, --no-tools           Don't install tools
    -d, --debug              Enable debug mode
    --insecure               Allow insecure TLS
    --docker                 Update Docker
    --clangd                 Update clangd to the latest released version
    --firefox-deb            Install deb version of Firefox
    --link-clang-format      Link clang-format to current path
    --link-nodejs            Link nodejs from VsCode Server to current path
    --vnc-start              Start VNC server
    --vnc-stop               Stop VNC server
    --vnc,--vnc-restart      Restart VNC server
    --unlock-vnc             Unlock VNC
    --lock-vnc               Lock VNC
    --chinese-pinyin         Install Rime Pinyin
    --auto-remove            Remove unused packages
    --update                 Update all packages
    --upgrade                Upgrade all packages

Force options:
    --prerequisite           Force install prerequisites
    --chinese-pinyin-force   Force install Rime Pinyin

Examples:
    $SCRIPT_NAME -h
    $SCRIPT_NAME --link-clang-format \$HOME/crosslv

_EOF
exit 0
}

SHORTOPTS="hdnf"
LONGOPTS="help,debug,no-tools,clangd,docker,link-clang-format::,link-nodejs,auto-remove,\
          upgrade,insecure,chinese-pinyin,prerequisite,force-chinese-pinyin,vnc-restart,\
          vnc-stop,unlock-vnc,lock-vnc,vnc-start,vnc,firefox-deb,update"

# Use getopt to parse command-line options
if ! PARSED=$(getopt --options $SHORTOPTS --longoptions "$LONGOPTS" --name "$0" -- "$@"); then
    echo -e "${COLOR}Error: Failed to parse command-line options.${RESET}" >&2
    exit 1
fi

# Reset positional parameters to the parsed values
eval set -- "$PARSED"

while true; do
    case "$1" in
        -n|--no-tools)
            fNoInstallTools=true
            shift
            ;;
        --prerequisite)
            fForceInstallPrerequisites=true
            shift
            ;;
        --docker)
            fUpdateDocker=true
            shift
            ;;
        --insecure)
            fTlsInsecure="--insecure"
            shift
            ;;
        --clangd)
            fUpdateClangd=true
            shift
            ;;
        --firefox-deb)
            fInstallDebFirefox=true
            shift
            ;;
        --vnc-start)
            fVncServer=1
            shift
            ;;
        --vnc-stop)
            fVncServer=2
            shift
            ;;
        --vnc|--vnc-restart)
            fVncServer=3
            shift
            ;;
        --unlock-vnc)
            set -x
            loginctl unlock-session
            exit 0
            ;;
        --lock-vnc)
            set -x
            loginctl lock-session
            exit 0
            ;;
        --chinese-pinyin)
            fRimePinyinInputMethod=true
            shift
            ;;
        --force-chinese-pinyin)
            fRimePinyinInputMethod=true
            fForceChinesePinyin=true
            shift
            ;;
        --link-clang-format)
            # $1 is '--link-clang-format'
            # $2 is an empty string '' no matter whether it has an argument
            # The argument if provided will be put in sequence in the positional parameters
            # Exp: $ jc huhu --link-clang-format ~/ he
            #          --link-clang-format '' -- 'huhu' '/home/user1/' 'he'
            # CRITICAL: Always shift 2 to consume both the option token ($1)
            # and its argument/empty placeholder token ($2).
            fLinkClangFormatPath="$PWD"
            shift 2
            ;;
        --link-nodejs)
            fLinkNodeJs=true
            shift
            ;;
        --auto-remove)
            echo -e "${COLOR}Removing unused packages${RESET}"
            sudo apt autoremove -y
            shift
            exit 0
            ;;
        --update)
            echo -e "${COLOR}Updating all packages${RESET}"
            sudo apt update -y
            shift
            exit 0
            ;;
        --upgrade)
            echo -e "${COLOR}Upgrading all packages${RESET}"
            sudo apt upgrade -y
            shift
            exit 0
            ;;
        -d|--debug)
            set -x
            echo -e "${COLOR}Debug mode enabled${RESET}"
            shift
            ;;
        -h|--help)
            usage
            ;;
        --)
            shift
            break
            ;;
        *)
            echo -e "${RED}Error: Invalid option: $1${RESET}" >&2
            exit 1
            ;;
    esac
done

checkSudoPrivilege() {
    echo -e "${COLOR}Checking sudo privilege${RESET}"
    # Check if the user can run sudo without a password
    if sudo -n true 2>/dev/null; then
        echo "User likely has passwordless sudo access."
    else
        echo "User likely does not have passwordless sudo access or needs a password."
        exit 0
    fi
}

checkOSCategory() {
    echo -e "${COLOR}Checking OS platform${RESET}"
    if [[ -f /etc/os-release ]]; then
        local osName
        osName=$(awk -F= '/^ID=/{print $2}' /etc/os-release)
        fArch=$(uname -m)

        case "$osName" in
            "ubuntu")
                fOSCategory=debian
                echo -e "The current OS type is ${LIGHTYELLOW}Ubuntu${RESET}. Arch: ${LIGHTYELLOW}$fArch${RESET}"
                ;;
            "centos")
                fOSCategory=redhat
                echo "The current OS type is CentOS. Arch: $fArch"
                echo "We currently do not support CentOS."
                exit
                ;;
            "raspbian")
                fOSCategory=debian
                echo "The current OS type is raspbian. Arch: $fArch"
                ;;
            *)
                echo "We currently do not support this OS type."
                exit
                ;;
        esac
    elif [[ $(uname) == "Darwin" ]]; then
        fOSCategory=mac
        echo "The current OS type is macOS (Mac)."
    else
        echo "The OS type is not supported or could not be determined."
        echo "We currently do not support this OS type."
        exit 1
    fi
}

updatePrerequisitesForDebian() {
    [ ! -f "$fFirstTimeFile" ] && fForceInstallPrerequisites=true
    [ -z "$fForceInstallPrerequisites" ] && return
    echo -e "${COLOR}Updating prerequisites for Ubuntu${RESET}"

    checkSudoPrivilege
    prerequisitesForUbuntu=(
        opencc # Simplified Chinese
        tmux # Basic tools
        rsync
        fd-find # fd
        ripgrep # rg
        universal-ctags
        openssl
        libssl-dev
        gdb
        bat
        curl
        firefox
        # Recommended Chinese fonts for good character display
        fonts-noto-cjk
        fonts-wqy-microhei
        fonts-wqy-zenhei
        jq # JSON parser
        xsel # X11 clipboard
        xclip
        libcurl4
        libcurl4-openssl-dev
        dos2unix
        expect
        sshfs
        sshpass
        shellcheck
        net-tools
        nftables
        bash-completion
        openssh-server
        python3-dev
        ffmpeg
        nodejs # Node.js
        npm
        build-essential # build essentials
        cmake
        libboost-all-dev
        gnupg
        lsb-release
        ragel
        sqlite3
        libsqlite3-dev
        libpcap-dev
        libvirt-clients
        texinfo
        libisl-dev
        libgmp-dev
        libncurses-dev
        source-highlight
        libsource-highlight-dev
        libmpfr-dev
        libtool
        autoconf
        gettext
        autopoint
        ifupdown
        bridge-utils
        bear # llvm & clangd
        libear
        gdm3 # gnome display manager
        ubuntu-desktop
        gnome-keyring
        xfce4
        xfce4-goodies
        tigervnc-standalone-server # TigerVNC
        tigervnc-xorg-extension
        tigervnc-viewer
        remmina # remote desktop client
        samba
        smbclient
    )

    sudo apt remove -y wireshark lightdm
    sudo apt update
    sudo apt install -y "${prerequisitesForUbuntu[@]}"
    sudo apt autoremove -y
}

updatePrequesitesForMac() {
    checkSudoPrivilege
    prerequisitesForMac=(
        yt-dlp
        fzf
        fd
        bat
        vim
    )

    echo -e "${COLOR}Updating prerequisites for macOS${RESET}"
    brew update
    brew install "${prerequisitesForMac[@]}"
}

setTimeZone() {
    echo -e "${COLOR}Setting timezone to Vancouver${RESET}"
    # check time zone if it is already vancouver
    if [ $(timedatectl | grep "Time zone" | awk '{print $3}') == "America/Vancouver" ]; then
        echo -e "${GREEN}✔${GREY} Time zone is already vancouver${RESET}"
        return
    fi
    sudo timedatectl set-timezone America/Vancouver
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Success!${RESET}"
    else
        echo -e "${RED}Failed!${RESET}"
        exit 1
    fi
}

installTmuxPluginsManager() {
    if [ -d ~/.tmux/plugins/tpm ]; then
        return
    fi
    echo -e "${COLOR}Installing TPM${RESET}"
    git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Success!${RESET}"
    else
        echo -e "${RED}Failed!${RESET}"
        exit 1
    fi
}

updateVimPlugins (){
    echo -e "${COLOR}Installing Vim Plugins Manager${RESET}"

    if [ ! -f ~/.vimrc ]; then
        echo "No .vimrc found, Abort!"
        exit 1
    fi

    if [ ! -f "$fVimPlugsManagerPath" ]; then
        # use the --insecure option to avoid certificate check
        curl $fTlsInsecure -fLo "$fVimPlugsManagerPath" --create-dirs \
        https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
    else
        echo -e "${GREEN}✔${GREY} Vim Plug Manager is already installed${RESET}"
    fi

    echo -e "${COLOR}Updating Vim Plugins${RESET}"
    vim +PlugInstall +PlugUpdate +qall
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}✔ Success!${RESET}"
    else
        echo -e "${RED}x Failed!${RESET}"
        exit 1
    fi
}

tackleTheExceptions() {
    if [ "$(hostname)" != "VAN-935558-PC0" ]; then
        return
    fi
    echo -e "${COLOR}Tackling exceptions${RESET}"
    # Copy back the privileged git config.
    gitconfigCheckFile=$HOME/.gitconfig.fortinet
    if [ -f "$gitconfigCheckFile"  ]; then
        echo -e "${LIGHTYELLOW}The privileged file $gitconfigCheckFile exists.${RESET}"
        echo -e "Relink $HOME/.gitconfig to $gitconfigCheckFile"
        ln -sf "$gitconfigCheckFile" "$HOME"/.gitconfig
        if [ $? -eq 0 ]; then
            echo -e "${GREEN}Success!${RESET}"
        else
            echo -e "${RED}Failed!${RESET}"
            exit 1
        fi
    fi
}

# linkFile: Creates a symbolic link for a file to a directory (destination).
#
# Usage:
#   linkFile /path/of/source/file /path/to/destination/dir
#   e.g., linkFile ~/myfile.txt /data/backup
#
# Arguments:
#   $1 - Source file
#   $2 - Destination directory path to link to
#   $3 - New link name (optional, default: as is)
#
# Returns:
#   0 if successful, 1 if already linked, 2 if source file does not exist
# ln [OPTION] TARGET LINK_NAME
linkFile() {
    local target="$1"      # The target to link
    local linkPath="$2"    # Destination directory to link to
    local newLinkName="$3" # New link name (optional, default: as is)

    if [ ! -d "$linkPath" ]; then
        echo -e "${RED}Destination directory $linkPath does not exist, abort!${RESET}"
        exit 1
    fi
    local filename=$(basename "$target")
    local linkName=${newLinkName:-$filename}
    local src="$target"
    local dst="$linkPath/${linkName}"

    [ ! -f "$target" ] && echo "Source file $target does not exist, abort!" && exit 1
    if [ -f "$dst" ] && [ ! -L "$dst" ]; then
        [ ! -d "$fBackupDir" ] && mkdir -p "$fBackupDir"
        echo -e "${CYAN}Warning: $dst is not a link, backing it up into $fBackupDir${RESET}"
        mv "$dst" "$fBackupDir/${linkName}.bak"
    fi

    if [ -L "$dst" ] && [ "$(readlink "$dst")" == "$src" ]; then
        echo -e "${GREEN}✔${GREY} Link ${BLUE}${linkName}${GREY} is already up to date.${RESET}"
        return 1
    fi

    # echo -e "${LIGHTYELLOW}Creating symlink${RESET}: $linkName -> $src"
    echo -e "${LIGHTYELLOW}Creating symlink${RESET}: $dst"
    echo "               => $src"
    ln -sf "$target" "$dst"
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Success!${RESET}"
    else
        echo -e "${RED}Failed!${RESET}"
        exit 2
    fi
}

# linkFiles: Creates symbolic links for all files in a source directory to a specified destination directory.
#
# Usage:
#   linkFiles /path/to/source/dir /path/to/destination/dir [linknamePrefix]
#   e.g., linkFiles ~/mydir /data/backup
#
# Arguments:
#   $1 - Source directory
#   $2 - Destination directory path to link to
#   $3 - Prefix for destination filename (optional, Exp: . for hidden files)
#
# Returns:
#   0 if successful, 1 if already linked, 2 if source directory does not exist
# ln [OPTION] TARGET LINK_NAME
linkFiles() {
    local targetDir="$1"        # Source directory
    local linkPath="$2"         # Destination directory
    local linknamePrefix="$3"   # Prefix for destination filename. Exp: . for hidden files

    echo -e "${COLOR}Creating symlinks pointing from ${linkPath}/* to $(basename "$targetDir")/*${RESET}"
    [ ! -d "$targetDir" ] && echo "Source directory $targetDir does not exist, abort!" && exit 1
    [ ! -d "$linkPath" ] && mkdir -p "$linkPath"

    for file in "$targetDir"/*; do
        linkFile "$file" "$linkPath" "${linknamePrefix}$(basename "$file")"
    done

    if [ "$linkPath" == "$HOME" ]; then
        return
    fi

    COLOR=$GREEN
    find "$linkPath" -type l ! \
            -exec test -e {} \; \
            -exec rm -f {} \; \
            -exec echo -e "${COLOR}Deleting broken link: {}${RESET}" \;
    COLOR=$MAGENTA
}

# relinkCommand: Creates a symbolic link for a system command with a new name in new path.
#
# Usage:
#   relinkCommand <sysCmd> <linkName> [linkPath]
#   e.g., relinkCommand batcat bat
#
#   ~/.usr/bin/bat -> /bin/batcat
#
# Arguments:
#   $1 - System command to link
#   $2 - Link name (new name)
#   $3 - Optional destination directory path (new path, default: $HOME/.usr/bin)
#
# Returns:
#   0 if successful, 1 if already linked, 2 if system command does not exist
# ln [OPTION] TARGET LINK_NAME
relinkCommand() {
    local sysCmd=$1
    local linkName=$2
    local linkPath=$HOME/.usr/bin
    [ -n "$3" ] && linkPath=$3
    local dst=$linkPath/$linkName
    local exePrefix=

    [ ! -d "$linkPath" ] && mkdir -p "$linkPath"
    sysCmdPath=$(command -v "$sysCmd")
    if [ -z "$sysCmdPath" ]; then
        echo "${sysCmd} is not installed"
        return 2
    fi

    if [ -L "$dst" ] && [ "$(readlink "$dst")" == "$sysCmdPath" ]; then
        echo -e "${GREEN}✔${GREY} Link ${BLUE}${linkName}${GREY} is already up to date.${RESET}"
        return 1
    fi

    echo -e "${COLOR}Creating symlink: ${linkName} -> syscmd: ${sysCmdPath}${RESET}"
    for _ in {1..2}; do
        $exePrefix ln -sf "$sysCmdPath" "$dst"
        if [ $? -eq 0 ]; then
            echo -e "${GREEN}Success!${RESET}"
            exePrefix=
        else
            echo -e "${RED}Failed!${RESET}"
            exePrefix="sudo "
            continue
        fi
    done
}

buildBatTheme() {
    # https://github.com/sharkdp/bat/tree/master/assets/themes
    echo -e "${COLOR}Building bat theme${RESET}"
    local batThemeDir=$HOME/.config/bat/themes
    local needBuild=
    [ ! -d "$batThemeDir" ] && mkdir -p "$batThemeDir"

    for theme in "$fTKBatThemeDir"/*; do
        linkFile "$theme" "$batThemeDir"
        if [ $? -eq 1 ]; then
            continue
        fi
        needBuild=true
    done

    [ -z "$needBuild" ] && return
    bat cache --build
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Success!${RESET}"
    else
        echo -e "${RED}Failed!${RESET}"
        exit 1
    fi
}

buildExtraFonts() {
    echo -e "${COLOR}Building extra fonts${RESET}"
    local needBuild=
    local fontConfigDir="$HOME/.config/fontconfig/conf.d"
    local fontDir=$HOME/.local/share/fonts
    [ ! -d "$fontDir" ] && mkdir -p "$fontDir"
    [ ! -d "$fontConfigDir" ] && mkdir -p "$fontConfigDir"

    for fontConfig in "$fTKFontConfigDir"/*; do
        linkFile "$fontConfig" "$fontConfigDir"
        if [ $? -eq 1 ]; then
            continue
        fi
    done

    for font in "$fTKFontDir"/*; do
        local fontFile=$(basename "$font")
        local fontExists=$(fc-list | grep -i "$fontFile")
        if [ -n "$fontExists" ]; then
            echo -e "${GREEN}✔${GREY} Font ${BLUE}${fontFile}${GREY} is already up to date.${RESET}"
            continue
        fi

        linkFile "$font" "$fontDir"
        if [ $? -eq 1 ]; then
            continue
        fi
        needBuild=true
    done

    [ -z "$needBuild" ] && return
    echo -e "${COLOR}Building font cache...${RESET}"
    sudo fc-cache -fv
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Success!${RESET}"
    else
        echo -e "${RED}Failed!${RESET}"
        exit 1
    fi
}

changeTMOUTToWritable() {
    # TMOUT is readonly in /etc/profile, change it to writable so that we can unset it in .bashrc
    if ! grep -q "TMOUT" /etc/profile; then
        return
    fi
    echo -e "${COLOR}Changing TMOUT to writable${RESET}"
    if grep -q "^readonly TMOUT" /etc/profile; then
        echo -e "${GREY}TMOUT is readonly in /etc/profile, change it to writable${RESET}"
    else
        echo -e "${GREEN}✔${GREY} TMOUT is already writable$ in /etc/profile${RESET}"
        return
    fi

    sudo sed -i 's/^readonly TMOUT/# readonly TMOUT/g' /etc/profile
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Success!${RESET}"
    else
        echo -e "${RED}Failed!${RESET}"
        exit 1
    fi
}

createTKSymlinks() {
    # The directories are guaranteed to exist when this function is called.
    linkFiles "$fTKFilesDir" "$HOME" "."
    linkFiles "$fTKCompDir" "$HOME/.bash_completion.d"
    linkFiles "$fTKVimColorsDir" "$HOME/.vim/colors"
}

linkNodeJsFromCodeServer() {
    [ -z $fLinkNodeJs ] && return
    local vscodeServerDir="$HOME/.vscode-server"
    if [ ! -d "$vscodeServerDir" ]; then
        echo -e "${LIGHTYELLOW}VSCode Server directory not found: ${BLUE}$vscodeServerDir${RESET}"
        echo -e "${LIGHTYELLOW}Skipping linking Node.js from VSCode Server.${RESET}"
        return
    fi
    echo -e "${LIGHTYELLOW}Searching for Node.js executable in ${BLUE}$vscodeServerDir${RESET}..."
    local latestNodeJsPath=$(find "$vscodeServerDir" -name "node" -type f -executable \
            -exec stat -c '%W %n' {} \; 2>/dev/null | sort -nr | cut -d' ' -f2- | head -n1)

    echo -e "${GREEN}Found latest Node.js executable at: ${BLUE}$latestNodeJsPath${RESET}"
    linkFile "$latestNodeJsPath" "$HOME/.usr/bin" "node"
}

createExtraSymlinks() {
    if [ -z "$fNoInstallTools" ]; then
        linkFiles "$fTKToolsDir" "$HOME/.usr/bin"
        linkFiles "$fTKtemplateDir" "$HOME/Templates"
    fi

    echo -e "${COLOR}Creating extra symlinks${RESET}"
    # The directories are guaranteed to exist when this function is called.
    linkFile "$fTKClangdConfig" "$HOME/.config/clangd"
    linkFile "$fzfTabCompPath" "$HOME/.bash_completion.d" "fzf_tab_completion.bash"
    linkFile "$fzfBinPath" "$HOME/.usr/bin"
    linkFile "$fJCPath" "$HOME/.usr/bin"
    linkFile "$fMainDir"/cloud/vscode/remote.settings.json "$HOME"/.vscode-server/data/Machine "settings.json"

    echo -e "${COLOR}Relinking system commands${RESET}"
    relinkCommand "batcat" "bat"
    relinkCommand "fdfind" "fd"
    relinkCommand "bash" "sh" "/bin/"

    linkNodeJsFromCodeServer
}

performSanityCheck() {
    local dirsToCheck=(
        "$fBackupDir"
        "$HOME/Downloads"
        "$HOME/Templates"
        "$HOME/.bash_completion.d"
        "$HOME/.usr/bin"
        "$HOME/.local/share/fonts"
        "$HOME/.config/bat/themes"
        "$HOME/.config/fontconfig/conf.d"
        "$HOME/.config/clangd"
    )

    for dir in "${dirsToCheck[@]}"; do
        if [ ! -d "$dir" ]; then
            echo -e "${LIGHTYELLOW}Creating directory: ${BLUE}$dir${RESET}"
            mkdir -p "$dir"
            if [ $? -ne 0 ]; then
                echo -e "${RED}Error: Failed to create directory $dir${RESET}"
                exit 1
            fi
        fi
    done

    cd "$fMainDir" || exit
}

installUpdateClangd() {
    echo -e "${COLOR}Updating Clangd${RESET}"
    # Check if the current architecture is arm64
    if [ "$fArch" == "aarch64" ]; then
        sudo apt install clangd -y
        return
    fi

    if ! command -v jq &> /dev/null; then
        echo -e "${RED}Error: jq is required but not installed. Please install jq first.${RESET}"
        return 1
    fi

    local currentVersion=""
    local clangdPath=$(command -v clangd 2>/dev/null)
    if [ -n "$clangdPath" ]; then
        currentVersion=$($clangdPath --version | head -n1 | grep -oP 'version \K[0-9]+\.[0-9]+\.[0-9]+' || echo "")
        echo -e "Current clangd version: ${BLUE}$currentVersion${RESET}"
    else
        echo -e "${LIGHTYELLOW}clangd is not currently installed${RESET}"
        currentVersion="0.0.0"
    fi

    # Get the latest stable release version and download URL
    echo -e "${LIGHTYELLOW}Fetching latest Clangd binary information${RESET}"
    # 20.1.0
    # https://github.com/clangd/clangd/releases/download/20.1.0/clangd-linux-20.1.0.zip
    local output=$(curl $fTlsInsecure -s https://api.github.com/repos/clangd/clangd/releases |
        jq -r '[.[] | select(.prerelease == false)] | .[0] |
               .name, (.assets[] | select(.name | contains("clangd-linux")) | .browser_download_url)')
    mapfile -t lines <<< "$output"
    local latestVersion="${lines[0]}"
    local downloadUrl="${lines[1]}"
    if [ -z "$latestVersion" ] || [ "$latestVersion" == "null" ]; then
        echo -e "${RED}Error: Failed to get latest version information${RESET}"
        return 1
    fi

    echo -e "Latest available clangd version: ${COLOR}$latestVersion${RESET}"
    if [ -n "$currentVersion" ]; then
        if [ "$(printf '%s\n' "$latestVersion" "$currentVersion" | sort -V -r | head -n1)" == "$currentVersion" ]; then
            echo -e "${GREY}No update needed. Current version is up to date.${RESET}"
            return 0
        fi
    fi

    echo -e "${LIGHTYELLOW}Downloading latest version of Clangd${RESET}"
    local fileName=$(basename "$downloadUrl")
    local downloadDst="$fDownloads/$fileName"
    if [ -f "$downloadDst" ]; then
        echo -e "${GREY}File $fileName already exists in $fDownloads, skipping download.${RESET}"
    else
        curl $fTlsInsecure -Lo "$downloadDst" "$downloadUrl"
        if [ $? -ne 0 ]; then
            echo -e "${RED}Error: Failed to download the latest version${RESET}"
            return 1
        fi
    fi

    cd "$fDownloads" || exit 1
    local peekInfo=$(zipinfo -1 "$downloadDst" | head -n 1)
    local extractDir="$fDownloads/$(dirname "$peekInfo")"
    if [ -d "$extractDir" ]; then
        echo -e "${GREY}Directory $extractDir already exists, skipping extraction.${RESET}"
    else
        echo -e "${LIGHTYELLOW}Extracting Clangd${RESET}"
        unzip "$downloadDst"
        if [ ! -d "$extractDir" ]; then
            echo -e "${RED}Error: Failed to extract the downloaded file${RESET}"
            exit 1
        fi
        echo -e "${GREEN}Successfully extracted to $extractDir${RESET}"
    fi

    # find binary named clangd under the extracted directory
    local clangdBinary=$(find "$extractDir" -type f -name "clangd" -executable | head -n 1)
    if [ -z "$clangdBinary" ]; then
        echo -e "${RED}Error: Failed to find the clangd binary in the extracted directory${RESET}"
        return 1
    fi

    linkFile "$clangdBinary" "$HOME/.usr/bin"
}

createFirstTimeFile() {
    [ -f "$fFirstTimeFile" ] && return
    touch "$fFirstTimeFile"
}

installDocker() {
    echo -e "${COLOR}Checking Docker...${RESET}"
    if command -v docker &> /dev/null && [ -z "$fUpdateDocker" ]; then
        echo -e "${GREEN}✔${GREY} Docker is already installed.${RESET}"
        printf "  "
        docker --version
        return 0
    fi

    echo -e "${COLOR}Installing Docker${RESET}"

    # 1. Uninstall old versions
    echo -e "${LIGHTYELLOW}Uninstalling old Docker versions (if any)...${RESET}"
    sudo apt-get remove -y docker docker-engine docker.io containerd runc > /dev/null 2>&1
    sudo apt-get autoremove -y > /dev/null 2>&1
    echo -e "${GREY}Old versions uninstalled/autoremoved (if any existed).${RESET}"

    # 2. Set up the repository
    echo -e "${LIGHTYELLOW}Setting up Docker repository...${RESET}"
    if ! sudo apt-get update; then
        echo -e "${RED}Failed to update apt package list.${RESET}"
        exit 1
    fi

    if [ ! -d /etc/apt/keyrings ] && ! sudo install -m 0755 -d /etc/apt/keyrings; then
        echo -e "${RED}Failed to create /etc/apt/keyrings directory.${RESET}"
        exit 1
    fi

    # Download Docker's official GPG key
    local dockerGpgKey="/etc/apt/keyrings/docker.gpg"
    if [ -f "$dockerGpgKey" ]; then
        echo -e "${GREY}Docker GPG key already exists at $dockerGpgKey. Verifying permissions...${RESET}"
    else
        echo -e "${LIGHTYELLOW}Downloading Docker's official GPG key...${RESET}"
        if ! curl $fTlsInsecure -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o "$dockerGpgKey"; then
            echo -e "${RED}Failed to download or dearmor Docker GPG key.${RESET}"
            exit 1
        fi
        echo -e "${GREEN}Docker GPG key downloaded and dearmored successfully.${RESET}"
    fi
    if ! sudo chmod a+r /etc/apt/keyrings/docker.gpg; then
        echo -e "${RED}Failed to set permissions for Docker GPG key.${RESET}"
        exit 1
    fi

    # Add Docker repository to Apt sources
    # shellcheck disable=SC2024 # sudo tee is generally fine with output redirection here.
    if ! echo \
      "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
      $(lsb_release -cs) stable" | \
      sudo tee /etc/apt/sources.list.d/docker.list > /dev/null; then
        echo -e "${RED}Failed to add Docker repository to apt sources.${RESET}"
        exit 1
    fi
    echo -e "${GREEN}Docker repository set up successfully.${RESET}"

    # 3. Install Docker Engine
    echo -e "${LIGHTYELLOW}Installing Docker Engine...${RESET}"
    if ! sudo apt-get update; then
        echo -e "${RED}Failed to update apt package list after adding Docker repo.${RESET}"
        exit 1
    fi
    if ! sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin; then
        echo -e "${RED}Failed to install Docker Engine packages.${RESET}"
        exit 1
    fi
    echo -e "${GREEN}Docker Engine installed successfully.${RESET}"

    # 4. Verify installation
    echo -e "${LIGHTYELLOW}Verifying Docker installation by running hello-world...${RESET}"
    if sudo docker run hello-world; then
        echo -e "${GREEN}Docker hello-world container ran successfully.${RESET}"
    else
        echo -e "${RED}Docker hello-world container failed to run. Docker might be installed but requires attention.${RESET}"
    fi

    # 5. Post-installation steps
    echo -e "${LIGHTYELLOW}Configuring Docker to run without sudo for current user ($USER)...${RESET}"
    if ! getent group docker > /dev/null; then
        echo -e "${GREY}Docker group does not exist, creating it...${RESET}"
        if ! sudo groupadd docker; then
            echo -e "${RED}Failed to create 'docker' group. You may need to do this manually.${RESET}"
        else
            echo -e "${GREEN}'docker' group created.${RESET}"
        fi
    else
        echo -e "${GREY}'docker' group already exists.${RESET}"
    fi

    if getent group docker > /dev/null; then
        if sudo usermod -aG docker "$USER"; then
            echo -e "${LIGHTYELLOW}IMPORTANT: You must log out and log back in, or run 'newgrp docker' in your terminal, for this change to take full effect.${RESET}"
        else
            echo -e "${RED}Failed to add user $USER to the 'docker' group. You may need to do this manually (e.g., sudo usermod -aG docker \"\$USER\").${RESET}"
        fi
    else
        echo -e "${RED}Cannot add user to 'docker' group as the group does not exist or could not be created.${RESET}"
    fi

    echo -e "${GREEN}Docker installation and basic configuration process completed.${RESET}"
}

installRimePinyinInputMethod() {
    echo -e "${COLOR}Checking Rime Pinyin input method...${RESET}"
    if [ -z "$fForceChinesePinyin" ]; then
        if command -v fcitx5-configtool &> /dev/null || \
           command -v fcitx-configtool  &> /dev/null; then
                echo -e "${GREEN}✔${GREY} Rime Pinyin input method is already installed.${RESET}"
                return 0
        fi
    fi

    echo -e "${COLOR}Installing Rime Pinyin input method${RESET}"
    echo -e "${LIGHTYELLOW}Updating package lists...${RESET}"
    if ! sudo apt update; then
        echo -e "${RED}Failed to update apt package list. Aborting Rime installation.${RESET}"
        return 1
    fi

    local fcitxXProfilePath=$fMainDir/readonly/fcitx5.xprofile
    # --- Attempt Fcitx5-Rime first ---
    echo -e "${COLOR}Checking for Fcitx5-Rime availability...${RESET}"
    if apt-cache show fcitx5-rime > /dev/null 2>&1; then
        echo -e "${GREEN}Fcitx5-Rime (fcitx5-rime) appears to be available. Attempting installation.${RESET}"
        local packagesToInstallFcitx5=(
            fcitx5
            fcitx5-rime
            fcitx5-chinese-addons # Provides general Chinese support, dictionaries, etc.
            fcitx5-configtool     # GUI configuration tool (e.g., fcitx5-config-qt)
            im-config             # Input method configuration tool (sets fcitx5 as default)
        )

        # Link the xprofile file
        linkFile "$fcitxXProfilePath" "$HOME" .xprofile
        echo -e "${LIGHTYELLOW}Installing Fcitx5 packages: ${packagesToInstallFcitx5[*]}${RESET}"
        if sudo DEBIAN_FRONTEND=noninteractive apt install -y "${packagesToInstallFcitx5[@]}"; then
            echo -e "${GREEN}Successfully installed Fcitx5 and Rime packages.${RESET}"
            echo -e "${LIGHTYELLOW}Setting fcitx5 as the default input method system-wide using im-config...${RESET}"
            if sudo im-config -n fcitx5; then
                echo -e "${GREEN}Successfully configured fcitx5 as the default input method via im-config.${RESET}"
                echo -e "${GREY}(im-config handles setting environment variables like XMODIFIERS, GTK_IM_MODULE, QT_IM_MODULE for graphical sessions)${RESET}"
            else
                echo -e "${RED}Failed to set fcitx5 as the default input method using im-config.${RESET}"
                echo -e "${LIGHTYELLOW}You might need to run 'im-config' (as a regular user, not sudo) to select fcitx5, or configure it via your desktop environment's settings.${RESET}"
                echo -e "${LIGHTYELLOW}Alternatively, for X11 sessions, ensure these lines are in your ~/.xprofile or similar (e.g., ~/.profile, ~/.xinitrc):${RESET}"
                echo -e "${LIGHTYELLOW}  export GTK_IM_MODULE=fcitx5${RESET}"
                echo -e "${LIGHTYELLOW}  export QT_IM_MODULE=fcitx5${RESET}"
                echo -e "${LIGHTYELLOW}  export XMODIFIERS=@im=fcitx5${RESET}"
            fi

            echo -e "${GREEN}Fcitx5-Rime installation and basic configuration process completed.${RESET}"
            echo -e "${BOLD}${MAGENTA}IMPORTANT: A system REBOOT or RE-LOGIN is REQUIRED for all changes to take full effect.${RESET}"
            echo -e "${LIGHTYELLOW}After rebooting/re-logging in:${RESET}"
            echo -e "${LIGHTYELLOW}1. Fcitx5 should start automatically. If not, add 'fcitx5' to your session's startup applications.${RESET}"
            echo -e "${LIGHTYELLOW}2. Open 'Fcitx 5 Configuration' (command: ${BLUE}fcitx5-configtool${RESET}).${RESET}"
            echo -e "${LIGHTYELLOW}3. In the 'Input Method' tab, ensure 'Pinyin' (from Rime) is in the list of active input methods. ${RESET}"
            echo -e "${LIGHTYELLOW}   If not, click the '+' button, uncheck 'Only Show Current Language' if needed, find 'Pinyin' (Rime), and add it.${RESET}"
            echo -e "${LIGHTYELLOW}4. You can switch input methods using the configured hotkey (often Ctrl+Space or Super+Space). Check 'Global Options' tab in fcitx5-configtool for 'Trigger Input Method'.${RESET}"
            echo -e "${LIGHTYELLOW}5. For Rime specific settings (e.g., traditional Chinese, fuzzy pinyin), create/edit files in ${BLUE}~/.local/share/fcitx5/rime/${RESET} (e.g., default.custom.yaml). Refer to Rime documentation.${RESET}"
            return 0
        else
            echo -e "${RED}Failed to install Fcitx5-Rime packages. Will try Fcitx4-Rime as a fallback.${RESET}"
        fi
    else
        echo -e "${LIGHTYELLOW}Fcitx5-Rime (fcitx5-rime) not found in official repositories. Checking for Fcitx4-Rime.${RESET}"
    fi

    # --- Attempt Fcitx4-Rime (fcitx) if Fcitx5-Rime was not available or failed ---
    echo -e "${COLOR}Checking for Fcitx4-Rime (fcitx-rime) availability...${RESET}"
    if apt-cache show fcitx-rime > /dev/null 2>&1; then
        echo -e "${GREEN}Fcitx4-Rime (fcitx-rime) appears to be available. Attempting installation.${RESET}"
        local packagesToInstallFcitx4=(
            fcitx
            fcitx-rime
            fcitx-table-all       # Common tables for fcitx4, includes pinyin etc.
            fcitx-frontend-gtk3
            fcitx-frontend-qt5    # Or fcitx-libs-qt5 on older systems
            fcitx-config-gtk      # GUI config tool for fcitx4 (or fcitx-configtool)
            im-config
        )

        # Link .xprofile to ~/.xprofile
        fcitxXProfilePath=$fMainDir/readonly/fcitx.xprofile
        linkFile "$fcitxXProfilePath" "$HOME" .xprofile
        echo -e "${LIGHTYELLOW}Installing Fcitx4 packages: ${packagesToInstallFcitx4[*]}${RESET}"
        if sudo DEBIAN_FRONTEND=noninteractive apt install -y "${packagesToInstallFcitx4[@]}"; then
            echo -e "${GREEN}Successfully installed Fcitx4 and Rime packages.${RESET}"

            echo -e "${LIGHTYELLOW}Setting fcitx as the default input method system-wide using im-config...${RESET}"
            if sudo im-config -n fcitx; then # Note: 'fcitx' for fcitx4
                echo -e "${GREEN}Successfully configured fcitx as the default input method via im-config.${RESET}"
            else
                echo -e "${RED}Failed to set fcitx as the default input method using im-config.${RESET}"
                echo -e "${LIGHTYELLOW}You might need to run 'im-config' (as a regular user) to select fcitx, or configure it via your desktop environment's settings.${RESET}"
                echo -e "${LIGHTYELLOW}Alternatively, for X11 sessions, ensure these lines are in your ~/.xprofile or similar:${RESET}"
                echo -e "${LIGHTYELLOW}  export GTK_IM_MODULE=fcitx${RESET}"
                echo -e "${LIGHTYELLOW}  export QT_IM_MODULE=fcitx${RESET}"
                echo -e "${LIGHTYELLOW}  export XMODIFIERS=@im=fcitx${RESET}"
            fi

            echo -e "${GREEN}Fcitx4-Rime installation and basic configuration process completed.${RESET}"
            echo -e "${BOLD}${MAGENTA}IMPORTANT: A system REBOOT or RE-LOGIN is REQUIRED for all changes to take full effect.${RESET}"
            echo -e "${LIGHTYELLOW}After rebooting/re-logging in:${RESET}"
            echo -e "${LIGHTYELLOW}1. Fcitx should start automatically. If not, add 'fcitx' to your session's startup applications.${RESET}"
            echo -e "${LIGHTYELLOW}2. Open 'Fcitx Configuration' (command: ${BLUE}fcitx-config-gtk${RESET} or ${BLUE}fcitx-configtool${RESET}).${RESET}"
            echo -e "${LIGHTYELLOW}3. Ensure 'Rime' is in the list of active input methods. If not, add it.${RESET}"
            echo -e "${LIGHTYELLOW}4. Switch input methods using the configured hotkey (e.g., Ctrl+Space).${RESET}"
            echo -e "${LIGHTYELLOW}5. Rime user data for fcitx4 is typically in ${BLUE}~/.config/fcitx/rime/${RESET}. Check Rime documentation.${RESET}"
            return 0
        else
            echo -e "${RED}Failed to install Fcitx4-Rime packages.${RESET}"
        fi
    else
        echo -e "${LIGHTYELLOW}Fcitx4-Rime (fcitx-rime) not found in official repositories.${RESET}"
    fi

    echo -e "${RED}Could not install Rime (neither Fcitx5-Rime nor Fcitx4-Rime) from official repositories.${RESET}"
    echo -e "${LIGHTYELLOW}Please ensure your system is Ubuntu/Debian based and your package sources are correctly configured.${RESET}"
    echo -e "${LIGHTYELLOW}No Rime input method was installed.${RESET}"
    return 1
}

linkClangFormat() {
    [ -z "$fLinkClangFormatPath" ] && return

    local argVal="$1"
    if [ -n "$argVal" ]; then
        if [ ! -d "$argVal" ]; then
            echo -e "${RED}Error: Link path '$argVal' is not a valid directory.${RESET}" >&2
            exit 1
        fi
        fLinkClangFormatPath="$argVal"
    fi

    local realClangFormatPath=$fMainDir/assets/clangd/clang-format
    echo -e "${LIGHTYELLOW}Linking clang-format to $fLinkClangFormatPath/.clang-format${RESET}"
    linkFile "$realClangFormatPath" "$fLinkClangFormatPath" .clang-format
    exit 0
}

isVncServerRunning() {
    if ! command -v tigervncserver &> /dev/null; then
        echo -e "${RED}Error: vncserver is not installed.${RESET}" >&2
        exit 1
    fi
    if lsof -i :$fVncRealPort | grep --quiet LISTEN; then
        return 0
    else
        return 1
    fi
}

stopVncServer() {
    if isVncServerRunning; then
        echo -e "${LIGHTYELLOW}Stopping VNC server on port $fVncRealPort...${RESET}"
        tigervncserver -kill :$fVncSimplePort
    else
        echo -e "${LIGHTYELLOW}VNC server on port $fVncRealPort is not running.${RESET}"
    fi
}

startVncServer() {
    if isVncServerRunning; then
        echo -e "${LIGHTYELLOW}VNC server on port $fVncRealPort is already running.${RESET}"
        return 0
    fi
    local hostIpAddress=$(hostname -I | awk '{print $1}')
    local hostUsername=$(whoami)
    local xstartupPath=$fMainDir/readonly/xstartup
    local xstartupDest=$HOME/.vnc/xstartup
    cd "$HOME"/.vnc || exit
    if [ ! -L "$xstartupDest" ]; then
        echo -e "${LIGHTYELLOW}Linking xstartup to $xstartupDest${RESET}"
        linkFile "$xstartupPath" "$HOME/.vnc" xstartup
    fi
    echo -e "${GREEN}Starting VNC server...${RESET}"
    local startCmd="tigervncserver :$fVncSimplePort -geometry $fVncResolution -SecurityTypes None -localhost"
    echo -e "${MAGENTA}$startCmd${RESET}"
    $startCmd
    # Display the status of the VNC server
    echo -e "${MAGENTA}VNC server started successfully:${RESET}"
    sudo lsof -i :5909
    cat << _EOF
===================================================
- On your local machine, setup the SSH tunnel as follows:
  Option 1. Use Vs Code Port Forward feature to forward the port $fVncRealPort
  Option 2. Open a terminal and run the following command:
    ssh -NL $fVncRealPort:localhost:$fVncRealPort $hostUsername@$hostIpAddress
    ssh -NL $fVncRealPort:localhost:$fVncRealPort droplet1
- Connect to the VNC server
  vncviewer localhost:$fVncRealPort
===================================================
_EOF
}

restartVncServer() {
    stopVncServer
    sleep 1
    startVncServer
}

installDebFirefox() {
    echo -e "${COLOR}Checking for DEB version of Firefox...${RESET}"
    if ! apt-cache show fcitx5-rime > /dev/null 2>&1; then
        return 0
    fi
    # Check if Firefox is installed and if it's the DEB version from Mozilla PPA
    if command -v firefox &>/dev/null; then
        firefoxPolicy=$(apt-cache policy firefox)
        if echo "$firefoxPolicy" | grep -q "mozillateam/ppa"; then
            installedVersion=$(echo "$firefoxPolicy" | grep "Installed:" | awk '{print $2}')
            candidateVersion=$(echo "$firefoxPolicy" | grep "Candidate:" | awk '{print $2}')
            if [ "$installedVersion" != "(none)" ] && [ "$installedVersion" == "$candidateVersion" ]; then
                echo -e "${GREEN}✔${GREY} Firefox (DEB version from Mozilla PPA) is already installed and up-to-date (${installedVersion}).${RESET}"
                return 0
            fi
        elif echo "$firefoxPolicy" | grep -q "snap"; then
            echo -e "${LIGHTYELLOW}Snap version of Firefox found. Will attempt to replace with DEB version.${RESET}"
        fi
    fi

    echo -e "${COLOR}Installing Firefox (DEB version) from Mozilla PPA${RESET}"
    # 1. Add the Mozilla PPA
    echo -e "${LIGHTYELLOW}Adding Mozilla PPA (ppa:mozillateam/ppa)...${RESET}"
    if ! sudo add-apt-repository -y ppa:mozillateam/ppa; then
        echo -e "${RED}Failed to add Mozilla PPA. Aborting Firefox DEB installation.${RESET}"
        return 1
    fi
    echo -e "${GREEN}Mozilla PPA added successfully.${RESET}"

    # 2. Create the preference file to prioritize PPA Firefox
    local preferenceFilePath="/etc/apt/preferences.d/mozilla-firefox-nosnap"
    local preferenceContent=$(cat <<EOF
Package: *
Pin: release o=LP-PPA-mozillateam
Pin-Priority: 1001

Package: firefox
Pin: release o=Ubuntu*
Pin-Priority: -1
EOF
)
    echo -e "${LIGHTYELLOW}Setting up APT preferences to prioritize Mozilla PPA Firefox...${RESET}"
    if [ -f "$preferenceFilePath" ] && cmp -s <(echo "$preferenceContent") "$preferenceFilePath"; then
        echo -e "${GREY}APT preference file '$preferenceFilePath' already exists and is correctly configured.${RESET}"
    else
        echo "$preferenceContent" | sudo tee "$preferenceFilePath" > /dev/null
        if [ $? -eq 0 ]; then
            echo -e "${GREEN}APT preference file '$preferenceFilePath' created/updated successfully.${RESET}"
        else
            echo -e "${RED}Failed to create/update APT preference file '$preferenceFilePath'. Aborting.${RESET}"
            return 1
        fi
    fi

    # 3. Uninstall Snap Firefox (if present)
    if snap list firefox &>/dev/null; then
        echo -e "${LIGHTYELLOW}Uninstalling Snap version of Firefox...${RESET}"
        if ! sudo snap remove firefox; then
            echo -e "${RED}Failed to remove Snap Firefox. This might interfere. Continuing, but manual removal might be needed.${RESET}"
        else
            echo -e "${GREEN}Snap Firefox removed successfully.${RESET}"
        fi
    else
        echo -e "${GREY}Snap version of Firefox not found. Skipping removal.${RESET}"
    fi

    # 4. Install DEB Firefox
    echo -e "${LIGHTYELLOW}Updating package lists...${RESET}"
    if ! sudo apt update; then
        echo -e "${RED}Failed to update apt package list after PPA and preference changes. Aborting Firefox installation.${RESET}"
        return 1
    fi

    echo -e "${LIGHTYELLOW}Installing Firefox (DEB version)...${RESET}"
    if ! sudo apt install -y firefox; then
        echo -e "${RED}Failed to install Firefox (DEB version).${RESET}"
        echo -e "${LIGHTYELLOW}Attempting to install specific components that might be missing (e.g., language packs)...${RESET}"
        sudo apt install -y firefox-locale-en # Example for English, adjust if needed
        if ! sudo apt install -y firefox; then # Retry main installation
             echo -e "${RED}Still failed to install Firefox (DEB version) after attempting component install.${RESET}"
             return 1
        fi
    fi

    # 5. Verify installation
    if command -v firefox &>/dev/null; then
        firefoxVersion=$(firefox --version)
        firefoxPolicyAfter=$(apt-cache policy firefox)
        if echo "$firefoxPolicyAfter" | grep -q "mozillateam/ppa"; then
            echo -e "${GREEN}Firefox (DEB version) installed successfully! Version: $firefoxVersion${RESET}"
            echo -e "${GREY}Policy check confirms it's from Mozilla PPA.${RESET}"
        else
            echo -e "${RED}Firefox installed, but it might not be the DEB version from Mozilla PPA. Please check 'apt-cache policy firefox'.${RESET}"
        fi
    else
        echo -e "${RED}Firefox installation failed or binary not found in PATH.${RESET}"
        return 1
    fi
    return 0
}

doCoreJobs() {
    createTKSymlinks
    updateVimPlugins
    installTmuxPluginsManager
    installDocker
    [ -n "$fInstallDebFirefox" ] && installDebFirefox
    [ -n "$fUpdateClangd" ] && installUpdateClangd
    [ -n "$fRimePinyinInputMethod" ] && installRimePinyinInputMethod
    createExtraSymlinks
}

doEarlyExitJobs() {
    linkClangFormat "$1"
    if [[ "$fVncServer" == "1" ]]; then
        startVncServer
        exit 0
    elif [[ "$fVncServer" == "2" ]]; then
        stopVncServer
        exit 0
    elif [[ "$fVncServer" == "3" ]]; then
        restartVncServer
        exit 0
    fi
}

main() {
    doEarlyExitJobs "$1"
    checkOSCategory
    performSanityCheck
    if [ "$fOSCategory" == "debian" ]; then
        updatePrerequisitesForDebian
        doCoreJobs
        buildBatTheme
        buildExtraFonts
        tackleTheExceptions
        setTimeZone
        changeTMOUTToWritable
        createFirstTimeFile
    elif [ "$fOSCategory" == "mac" ]; then # Deprecated
        createTKSymlinks
        installTmuxPluginsManager
        updateVimPlugins
        createExtraSymlinks
        buildBatTheme
        buildExtraFonts
    fi
}

main "$@"
