#!/usr/bin/env bash
# shellcheck disable=SC2155 disable=SC2120 disable=SC2024
# set -x

# Tracking directories
fMainDir=$(cd "$(dirname "$(readlink -f "$0")")" || exit; pwd)
fTKFilesDir=$fMainDir/track-files
fTKCompDir=$fMainDir/completion
fTKVimColorsDir=$fMainDir/assets/vim-colors
fTKBatThemeDir=$fMainDir/assets/bat-themes
fTKFontDir=$fMainDir/assets/fonts
fTKFontConfigDir=$fMainDir/assets/fontconfig
fTKClangdConfig=$fMainDir/assets/clangd/config.yaml
fTKtemplateDir=$fMainDir/template
fTKToolsDir=$fMainDir/nv-tools
fDownloads=$HOME/Downloads
fJCPath=$fMainDir/jc
fFirstTimeFile=$fMainDir/".has_been_invoked"
# Misc
fVimPlugsManagerPath=$HOME/.vim/autoload/plug.vim
fzfBinPath=$HOME/.vim/bundle/fzf/bin/fzf
fzfTabCompPath=$HOME/.vim/bundle/fzf-tab-completion/bash/fzf-bash-completion.sh # A fzf plugin: fzf-tab-completion
fBackupDir="$HOME/Public/env.bak"
fOSCategory=debian # ubuntu/debian is the default OS type
fArch=
fNoInstallTools=
fCheckTlsConn=
# VNC server
fVncAbbrePort=9
fVncFullPort="590${fVncAbbrePort}"
fVncResolution=2060x1080
fVncServer= # 1: start VNC server; 2: kill VNC server 3: restart VNC server
fVncLockAction=
# Docker Container: OpenGrok
fOpenGrokContainer= # 1: start container; 2: stop container 3: restart container 4: start indexer
OPENGROK_IMAGE_NAME="opengrok/docker:latest" # You can pin to a specific version, e.g., opengrok/docker:1.7.30
OPENGROK_CONTAINER_NAME="opengrok"
OPENGROK_SRC_VOLUME="$HOME/.usr/local/opengrok/src" # User puts source code here on the host
OPENGROK_DATA_VOLUME="$HOME/.usr/local/opengrok/data" # Docker named volume for OpenGrok data/indexes
OPENGROK_ETC_VOLUME="$HOME/.usr/local/opengrok/etc"   # Docker named volume for OpenGrok configuration
OPENGROK_HOST_PORT="8080"
OPENGROK_CONTAINER_PORT="8080"
fLinkClangFormatPath= # Link clang-format to this path
# Force Options
appInstallForce= # 1: install apps and continue; 2: install apps and exit
fNVMForce=
fGitLfsForce=
fClangdForce=
fDockerForce=
fWiresharkForce=
fFirefoxForce=
fChinesePinyinForce=
fSwapReq=
# Samba Server | 1: Start samba server 2: Start samba server and reset password
fSambaServerFlag=
# LiteLLM | 1: Start LiteLLM 2: Stop LiteLLM 3: Restart LiteLLM
fLiteLLMService=
LITELLM_DIR="$fDownloads/litellm"
# Constants
SCRIPT_NAME=$(basename $0)
# Colors
RED='\033[31m'
GREEN='\033[32m'
MAGENTA='\033[35m'
LIGHTYELLOW='\033[93m'
BOLD='\033[1m'
NORMAL='\033[0m'
BLUE='\033[34m'
GREY='\033[90m'
CYAN='\033[36m'
RESET='\033[0m'
COLOR=$MAGENTA

# On macOS, always initialize Homebrew environment
if [[ $(uname -s) == 'Darwin' ]]; then
    [ -x /opt/homebrew/bin/brew ] && eval "$(/opt/homebrew/bin/brew shellenv)"
    [ -x /usr/local/bin/brew ] && eval "$(/usr/local/bin/brew shellenv)"
fi

usage() {
    cat << _EOF
Usage: $SCRIPT_NAME [OPTIONS]

This script is used to set up the coding environment in my predefined way.

Common Options:
    -h, --help                      Print this help message
    -n, --no-tools                  Don't install tools
    -d, --debug                     Enable debug mode
    --check-tls                     Check TLS connection
    --link-clang-format             Link clang-format to current path
    --auto-remove                   Remove unused packages
    --update                        Update all packages
    --upgrade                       Upgrade all packages

Samba Options:
    --samba                         Install and configure Samba Server
    --samba-reset-password          Reset Samba Server password

Swap Options:
    --swap                          Add swap file (default 8G)

Vnc Server Options:
    --vnc,--vnc-start               Start VNC server
    --vnc-stop                      Stop VNC server
    --vnc-restart                   Restart VNC server

Vnc Lock Options:
    --vnclock                       Effect options: [unlock|lock|status]
    --unlock-vnc                    Unlock VNC, equivalent to --vnclock unlock
    --lock-vnc                      Lock VNC, equivalent to --vnclock lock

LiteLLM Options:
    --litellm,--litellm-start       Start LiteLLM Service
    --litellm-stop                  Stop LiteLLM Service
    --litellm-restart               Restart LiteLLM Service

OpenGrok Options:
    --opengrok,--opengrok-start     Start OpenGrok Docker container
    --opengrok-stop                 Stop OpenGrok Docker container
    --opengrok-restart              Restart OpenGrok Docker container
    --opengrok-indexer              Start OpenGrok indexer

The following options force updates or re-installation (installed by default):
    --nvm                           Force update NVM
    --git-lfs                       Force update Git LFS from PackageCloud
    --apps                          Force update Apps
    --chinese-pinyin                Force Update Rime Pinyin
    --docker                        Force update Docker from Docker PPA
    --wireshark                     Force update wireshark from Wireshark PPA
    --firefox                       Force update firefox from Mozilla PPA
    --clangd                        Force update clangd from Github

Examples:
    $SCRIPT_NAME -h
    $SCRIPT_NAME --link-clang-format \$HOME/crosslv

_EOF
exit 0
}

# Detect and use GNU getopt if available (required for long options on macOS)
GETOPT_BIN="getopt"
if command -v /opt/homebrew/opt/gnu-getopt/bin/getopt &> /dev/null; then
    GETOPT_BIN="/opt/homebrew/opt/gnu-getopt/bin/getopt"
elif command -v /usr/local/opt/gnu-getopt/bin/getopt &> /dev/null; then
    GETOPT_BIN="/usr/local/opt/gnu-getopt/bin/getopt"
fi

SHORTOPTS="hdnf"
# Two colons: The option takes an optional argument
LONGOPTS="help,debug,no-tools,clangd,docker,link-clang-format::,auto-remove,nvm\
          upgrade,chinese-pinyin,apps,apps-only,vnc-restart,vnc-stop,unlock-vnc,vnclock:,\
          lock-vnc,vnc-start,vnc,firefox,update,opengrok,opengrok-start,opengrok-stop,\
          opengrok-restart,opengrok-indexer,samba,samba-reset-password,wireshark,git-lfs\
          litellm-start,litellm-stop,litellm-restart,litellm,check-tls::,swap::"

# Use getopt to parse command-line options
if ! PARSED=$("$GETOPT_BIN" --options $SHORTOPTS --longoptions "$LONGOPTS" --name "$0" -- "$@"); then
    echo -e "${COLOR}Error: Failed to parse command-line options.${RESET}" >&2
    echo -e "${CYAN}Tip: On macOS, install GNU getopt: ${GREY}brew install gnu-getopt${RESET}" >&2
    exit 1
fi

# Reset positional parameters to the parsed values
eval set -- "$PARSED"

while true; do
    case "$1" in
        -n|--no-tools)
            fNoInstallTools=true
            shift
            ;;
        --apps)
            appInstallForce=1
            shift
            ;;
        --apps-only)
            appInstallForce=2
            shift
            ;;
        --nvm)
            fNVMForce=true
            shift
            ;;
        --git-lfs)
            fGitLfsForce=true
            shift
            ;;
        --docker)
            fDockerForce=true
            shift
            ;;
        --wireshark)
            fWiresharkForce=true
            shift
            ;;
        --firefox)
            fFirefoxForce=true
            shift
            ;;
        --clangd)
            fClangdForce=true
            shift
            ;;
        --opengrok|--opengrok-start)
            fOpenGrokContainer=1
            shift
            ;;
        --opengrok-stop)
            fOpenGrokContainer=2
            shift
            ;;
        --opengrok-restart)
            fOpenGrokContainer=3
            shift
            ;;
        --opengrok-indexer)
            fOpenGrokContainer=4
            shift
            ;;
        --samba)
            fSambaServerFlag=1
            shift
            ;;
        --samba-reset-password)
            fSambaServerFlag=2
            shift
            ;;
        --vnc|--vnc-start)
            fVncServer=1
            shift
            ;;
        --vnc-stop)
            fVncServer=2
            shift
            ;;
        --vnc-restart)
            fVncServer=3
            shift
            ;;
        --vnclock)
            fVncLockAction="$2"
            shift 2
            ;;
        --unlock-vnc)
            fVncLockAction="unlock"
            shift
            ;;
        --lock-vnc)
            fVncLockAction="lock"
            shift
            ;;
        --litellm|--litellm-start)
            fLiteLLMService=1
            shift
            ;;
        --litellm-stop)
            fLiteLLMService=2
            shift
            ;;
        --litellm-restart)
            fLiteLLMService=3
            shift
            ;;
        --chinese-pinyin)
            fChinesePinyinForce=true
            shift
            ;;
        --swap)
            fSwapReq=true
            shift 2
            ;;
        --link-clang-format)
            # $1 is '--link-clang-format'.
            # $2 is always an empty string '', even if an argument is provided.
            # Any provided argument appears sequentially in the positional parameters.
            # Example: $ jc huhu --link-clang-format /home/user1/ leetcode
            #       => jc --link-clang-format '' -- 'huhu' '/home/user1/' 'leetcode'
            # CRITICAL: Always 'shift 2' to consume the option ($1) and the
            # empty placeholder token ($2).
            fLinkClangFormatPath="$PWD"
            shift 2
            ;;
        --check-tls)
            fCheckTlsConn=true
            shift 2
            ;;
        --auto-remove)
            echo -e "${COLOR}Removing unused packages${RESET}"
            sudo apt autoremove -y
            shift
            exit 0
            ;;
        --update)
            echo -e "${COLOR}Updating all packages${RESET}"
            if [[ $(uname -s) == 'Darwin' ]]; then
                brew update
            else
                sudo apt update -y
            fi
            shift
            exit 0
            ;;
        --upgrade)
            echo -e "${COLOR}Updating all packages${RESET}"
            if [[ $(uname -s) == 'Darwin' ]]; then
                brew update
                echo -e "${COLOR}Upgrading all packages${RESET}"
                brew upgrade
            else
                sudo apt update -y
                echo -e "${COLOR}Upgrading all packages${RESET}"
                sudo apt upgrade -y
            fi
            shift
            exit 0
            ;;
        -d|--debug)
            set -x
            echo -e "${COLOR}Debug mode enabled${RESET}"
            shift
            ;;
        -h|--help)
            usage
            ;;
        --)
            shift
            break
            ;;
        *)
            echo -e "${RED}Error: Invalid option: $1${RESET}" >&2
            exit 1
            ;;
    esac
done

checkSudoPrivilege() {
    echo -e "${COLOR}Checking Sudo Privilege${RESET}"
    if sudo -n true 2>/dev/null; then
        echo -e "${GREEN}‚úî${GREY} User has passwordless sudo access.${RESET}"
    else
        echo -e "${RED}‚úó${GREY} User does not have passwordless sudo access. Please run the script with sudo.${RESET}"
        exit 0
    fi
}

checkTlsConnection() {
    local targetHost=${1:-"github.com"}
    if command -v openssl &> /dev/null; then
        checkTlsConnWithOpenssl "$targetHost"
    elif command -v curl &> /dev/null; then
        checkTlsConnWithCurl "$targetHost"
    else
        echo -e "${LIGHTYELLOW}curl and openssl are not installed. Aborting.${RESET}"
        exit 1
    fi
}

checkTlsConnWithOpenssl() {
    local targetHost=${1:-"github.com"}
    echo -e "${COLOR}Verifying server certificate against CA list for: ${NORMAL}${targetHost}${RESET}"

    # Use openssl s_client to connect and verify the certificate.
    # -connect <host>:<port>
    # -servername <host> for SNI
    # -showcerts (optional, but useful if debugging; we'll focus on the verify return code)
    # -verify_return_error: Crucial for getting a meaningful exit code on verification failure.
    # </dev/null: Prevents blocking on stdin.
    # 2>&1: Captures both stdout and stderr.
    local opensslOutput
    opensslOutput=$(openssl s_client -connect "${targetHost}:443" -servername "${targetHost}" -verify_return_error </dev/null 2>&1)
    local opensslExitCode=$?

    # openssl s_client returns non-zero for many errors, including verification failures.
    # A successful verification usually results in 'verify return:1'.
    # We need to check the exit code *and* the output for 'verify return:1'.

    # Grep for the specific success indicator and check the exit code.
    # The 'verify return:1' is the most direct confirmation of CA trust.
    # Note: openssl s_client may return non-zero even on successful verification due to connection closure
    if echo "$opensslOutput" | grep -q 'verify return:1' && ! echo "$opensslOutput" | grep -q 'verify return:0'; then
        echo -e "${GREEN}‚úî${GREY} Server certificate is trusted (legally issued and verifiable against CA list).${RESET}"
        # Optionally display specific certificate details if needed for context:
        local certDetails=$(echo "$opensslOutput" | openssl x509 -noout -subject -issuer -dates)
        if [ -n "$certDetails" ]; then
            echo -e "${CYAN}--- Certificate Details ---${RESET}"
            echo "$certDetails"
            echo -e "${CYAN}---------------------------${RESET}"
        fi
    else
        # Handle failures
        echo -e "${RED}‚úó${GREY} Server certificate is NOT trusted or an error occurred.${RESET}"
        if echo "$opensslOutput" | grep -q 'verify return:.*error'; then
            echo -e "${RED}  Reason: Certificate validation failed.${RESET}"
        elif echo "$opensslOutput" | grep -q 'connect:errno='; then
            echo -e "${RED}  Reason: Could not connect to the server.${RESET}"
        elif echo "$opensslOutput" | grep -q 'certificate verify failed'; then
            echo -e "${RED}  Reason: OpenSSL reported a certificate verification failure.${RESET}"
        else
            echo -e "${RED}  Reason: Unknown error or non-verified certificate.${RESET}"
        fi
        # Show a snippet of the output for debugging
        echo -e "${CYAN}‚òû ${GREY}openssl output snippet:${RESET}"
        echo "$opensslOutput" | head -n 10
        exit 1 # Exit on any failure
    fi
}

checkTlsConnWithCurl() {
    local targetHost=${1:-"github.com"}
    echo -e "${COLOR}Checking TLS Certificate Trust for: ${NORMAL}${targetHost}${RESET}"

    local curlOutput
    # -fsS = --fail --silent --show-error
    curlOutput=$(curl --head -fsS --connect-timeout 5 "https://${targetHost}" 2>&1)
    local curlExitCode=$?

    # Exit code 60 is specifically for peer certificate verification failure.
    if [ $curlExitCode -eq 0 ]; then
        echo -e "${GREEN}‚úî${GREY} TLS connection successful. Certificate is trusted.${RESET}"
    elif [ $curlExitCode -eq 60 ]; then
        echo -e "${RED}‚úó${GREY} TLS connection failed: Certificate validation error.${RESET}"
        echo -e "${RED}  This is often due to a corporate proxy (Man-in-the-Middle).${RESET}"
        echo -e "${GREY}‚òû Details: \n$(echo "$curlOutput" | sed 's/curl: (60) //')${RESET}"
        exit 1
    else
        echo -e "${RED}‚úó${GREY} TLS connection failed for another reason (Exit Code: $curlExitCode).${RESET}"
        echo -e "${GREY}‚òû Details: \n$(echo "$curlOutput" | sed 's/curl: ([0-9]\+) //')${RESET}"
    fi
}

checkOSAndArch() {
    echo -e "${COLOR}Checking OS and Architecture${RESET}"
    fArch=$(uname -m)
    if [[ -f /etc/os-release ]]; then
        local prettyName=$(awk -F= '/^PRETTY_NAME=/{print $2}' /etc/os-release)
        local idLike=$(awk -F= '/^ID_LIKE=/{print $2}' /etc/os-release)
        case "$idLike" in
            "debian")
                fOSCategory=$idLike
                echo -e "${GREEN}‚úî${GREY} The current OS type is ${LIGHTYELLOW}$prettyName${RESET}. ${GREY}The Arch is ${LIGHTYELLOW}$fArch${RESET}"
                ;;
            *)
                fOSCategory=$idLike
                echo -e "${GREEN}‚ùå${GREY} The current OS type is ${LIGHTYELLOW}$prettyName${RESET}. ${GREY}The Arch is ${LIGHTYELLOW}$fArch${RESET}"
                echo "  We currently do not support this OS type."
                exit
                ;;
        esac
    elif [[ $(uname) == "Darwin" ]]; then
        fOSCategory=mac
        echo -e "${GREEN}‚úî${GREY} The current OS type is ${LIGHTYELLOW}macOS${RESET}. ${GREY}The Arch is ${LIGHTYELLOW}$fArch${RESET}"
    else
        echo -e "${GREEN}‚ùå${GREY} The OS type is not supported or could not be determined."
        exit 1
    fi
}

removeInstalledPackages() {
        local packagesToCheck=("$@")
        local packagesToRemove=()

        for pkg in "${packagesToCheck[@]}"; do
            if dpkg-query -W -f='${Status}' "$pkg" 2>/dev/null | grep -q "ok installed"; then
                packagesToRemove+=("$pkg")
            fi
        done

        if [ ${#packagesToRemove[@]} -gt 0 ]; then
            echo -e "${LIGHTYELLOW}Removing conflicting/unwanted packages: ${packagesToRemove[*]}${RESET}"
            sudo apt remove --purge -y "${packagesToRemove[@]}"
        fi
}

ubuntuInstallApps() {
    [ ! -f "$fFirstTimeFile" ] && appInstallForce=1
    [ -z "$appInstallForce" ] && return
    checkSudoPrivilege
    local appsForUbuntu=(
        # --- Core Command-Line Tools ---
        tmux                    # Terminal multiplexer
        vim                     # Vi IMproved
        rsync                   # Remote file sync
        curl                    # Command-line HTTP client
        gnupg                   # GNU privacy guard
        lsb-release             # Linux Standard Base
        openssl                 # OpenSSL command-line tools
        dos2unix                # Convert DOS line endings to Unix
        expect                  # Expect script interpreter
        shellcheck              # Shell script static analyzer
        bash-completion         # Bash completion
        qrencode

        # --- File Finding & Processing ---
        fd-find                 # fd, a faster find
        ripgrep                 # rg, a faster grep
        jq                      # JSON processor
        bat                     # A cat clone with syntax highlighting

        # --- Build System & Toolchains ---
        build-essential         # Compiler toolchain (gcc, make, etc.)
        pkg-config              # Manage compile/link flags for libraries
        gdb                     # The GNU Debugger
        universal-ctags         # Ctags for code navigation
        ragel                   # State machine compiler
        bear                    # Generate compilation database
        clang-tools             # Clang compiler tools
        cmake                   # Cross-platform build system generator
        libtool                 # Generic library support script
        autoconf                # Generates configuration scripts
        gettext                 # GNU internationalization utilities
        texinfo                 # Documentation system

        # --- Development Libraries ---
        python3-dev             # Python 3 development headers
        python3-venv            # Python 3 virtual environment
        libssl-dev              # OpenSSL development libraries
        libboost-all-dev        # Boost C++ libraries
        libsqlite3-dev          # SQLite 3 development library
        libpcap-dev             # Packet capture library headers
        libbpf-dev              # libbpf eBPF library
        libcurl4-openssl-dev    # cURL development library
        libisl-dev              # Integer Set Library for polyhedral compilation
        libgmp-dev              # GNU Multiple Precision Arithmetic Library
        libncurses-dev          # Ncurses terminal library
        libsource-highlight-dev # Source code highlighting library
        libmpfr-dev             # Multiple-precision floating-point library

        # --- System & Performance Analysis ---
        linux-tools-common        # Common Linux tools
        bpfcc-tools               # BCC eBPF toolkit

        # --- Networking Tools ---
        netcat-openbsd          # nc
        socat                   # netcat replacement
        net-tools               # (Optional, legacy: ifconfig, netstat)
        iproute2                # (Recommended, modern: ip, ss)
        conntrack               # Connection tracking tools
        nftables                # Netfilter tables
        inetutils-traceroute    # Traceroute
        openssh-server          # SSH server
        sshfs                   # SSH filesystem
        sshpass                 # SSH password authentication

        # --- Desktop Environment (Choose ONE) ---
        ubuntu-desktop          # The full GNOME desktop environment
        xfce4                   # A lightweight XFCE desktop
        xfce4-goodies           # Goodies for XFCE (recommended)
        xfce4-screensaver       # XFCE screensaver

        # --- GUI Tools & Dependencies ---
        gdm3                    # GNOME Display Manager
        yaru-theme-icon         # Yaru icon theme
        network-manager-gnome   # Network manager
        gnome-keyring           # Keyring manager
        xsel                    # Command-line clipboard tool
        xclip                   # Command-line clipboard tool
        fonts-noto-cjk          # CJK fonts
        fonts-wqy-microhei      # Chinese fonts
        fonts-wqy-zenhei        # Chinese fonts
        remmina                 # Remote desktop client (VNC, RDP, etc.)
        remmina-plugin-rdp      # RDP plugin for Remmina
        tigervnc-standalone-server # VNC server
        tigervnc-xorg-extension    # VNC X11 extension

        # --- Virtualization ---
        qemu-kvm                # KVM virtualization
        qemu-utils              # QEMU utilities
        libvirt-daemon-system   # libvirt daemon
        virt-manager            # GUI for managing virtual machines
        virt-top

        # --- Miscellaneous ---
        ffmpeg                  # FFmpeg command-line tools
        sqlite3                 # Command-line interface for SQLite
        ifupdown                # Legacy network configuration tool
        bridge-utils            # Bridge configuration utility
    )
    echo -e "${COLOR}Updating Apps for Ubuntu${RESET}"
    sudo apt update
    if ! removeInstalledPackages thunderbird lightdm xrdp xorgxrdp; then
        echo -e "${RED}Error: Failed to remove one or more conflicting packages. Aborting Apps installation.${RESET}"
        return 1
    fi
    echo "gdm3 shared/default-x-display-manager select gdm3" | sudo debconf-set-selections
    # echo "wireshark-common wireshark-common/install-setuid boolean true" | sudo debconf-set-selections
    sudo DEBIAN_FRONTEND=noninteractive apt install -y --no-install-recommends "${appsForUbuntu[@]}"

    # Install kernel-specific linux-tools if available (may not exist for custom kernels)
    # Try kernel-specific version first, fall back to generic
    local kernelToolsPkg="linux-tools-$(uname -r)"
    local genericToolsPkg="linux-tools-generic"
    if apt-cache show "$kernelToolsPkg" &>/dev/null; then
        echo -e "${GREY}Installing kernel-specific tools: ${kernelToolsPkg}${RESET}"
        sudo DEBIAN_FRONTEND=noninteractive apt install -y "$kernelToolsPkg" || \
            echo -e "${LIGHTYELLOW}Warning: Failed to install ${kernelToolsPkg}, skipping.${RESET}"
    elif apt-cache show "$genericToolsPkg" &>/dev/null; then
        echo -e "${LIGHTYELLOW}Note: ${kernelToolsPkg} not available, trying ${genericToolsPkg}...${RESET}"
        sudo DEBIAN_FRONTEND=noninteractive apt install -y "$genericToolsPkg" || \
            echo -e "${LIGHTYELLOW}Warning: Failed to install ${genericToolsPkg}, skipping.${RESET}"
    else
        echo -e "${LIGHTYELLOW}Note: Neither ${kernelToolsPkg} nor ${genericToolsPkg} available, skipping.${RESET}"
    fi

    # sudo DEBIAN_FRONTEND=noninteractive dpkg-reconfigure gdm3
    sudo apt autoremove -y
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Success!${RESET}"
        if [ "$appInstallForce" -eq 2 ]; then
            exit 0
        fi
    else
        echo -e "${RED}Failed!${RESET}"
        exit 1
    fi
}

macInstallApps() {
    checkSudoPrivilege
    appsForMac=(
        bash
        gnu-getopt
        gnu-sed
        gawk
        grep
        bash-completion@2
        coreutils
        git
        fontconfig
        yt-dlp
        fzf
        fd
        bat
        vim
        tmux
    )

    echo -e "${COLOR}Updating Apps for MacOS${RESET}"
    brew update

    # Unlink old bash-completion if installed (conflicts with bash-completion@2)
    # if brew list bash-completion &>/dev/null; then
    #     echo -e "${GREY}Unlinking old bash-completion...${RESET}"
    #     brew unlink bash-completion
    # fi

    brew install "${appsForMac[@]}"
}

setTimeZone() {
    if [[ $(uname -s) == 'Darwin' ]]; then
        echo -e "${COLOR}Checking Timezone on macOS${RESET}"
        local currentTZ=$(readlink /etc/localtime 2>/dev/null | sed 's|/var/db/timezone/zoneinfo/||' || echo "Unknown")
        if [[ "$currentTZ" == "Asia/Shanghai" ]]; then
            echo -e "${GREEN}‚úî${GREY} Timezone is already set to Asia/Shanghai${RESET}"
        else
            echo -e "${LIGHTYELLOW}Current timezone: $currentTZ${RESET}"
            echo -e "${LIGHTYELLOW}To change timezone on macOS:${RESET}"
            echo -e "${GREY}  System Settings ‚Üí General ‚Üí Date & Time ‚Üí Time Zone${RESET}"
            echo -e "${GREY}  Or use: sudo systemsetup -settimezone Asia/Shanghai${RESET}"
        fi
        return
    fi

    # Linux (Ubuntu/Debian)
    if [ "$(timedatectl | grep "Time zone" | awk '{print $3}')" == "Asia/Shanghai" ]; then
        # echo -e "${GREEN}‚úî${GREY} Time zone is already shanghai${RESET}"
        return
    fi
    echo -e "${COLOR}Setting Timezone to Shanghai${RESET}"
    sudo timedatectl set-timezone Asia/Shanghai
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Success!${RESET}"
    else
        echo -e "${RED}Failed!${RESET}"
        exit 1
    fi
}

stopAndDisableDaemonService() {
    local targetServiceName="${1:-networking.service}"
    if ! systemctl cat "$targetServiceName" >/dev/null 2>&1; then
        return 1
    fi
    # Stop the service
    local targetServiceStatus=$(systemctl is-active "$targetServiceName" 2>&1)
    if [ "$targetServiceStatus" == "active" ]; then
        echo -e "${LIGHTYELLOW}Service '${targetServiceName}' is active. Attempting to stop it...${RESET}"
        if sudo systemctl stop "$targetServiceName"; then
            echo -e "${GREEN}‚úî${GREY} Successfully stopped service '${targetServiceName}'.${RESET}"
        else
            echo -e "${RED}Failed to stop service '${targetServiceName}'.${RESET}"
        fi
    elif [ "$targetServiceStatus" == "inactive" ] || [ "$targetServiceStatus" == "failed" ]; then
        echo -e "${GREEN}‚úî${GREY} Service '${targetServiceName}' is inactive (status: $targetServiceStatus).${RESET}"
    else
        echo -e "${RED}Failed to check status for service '${targetServiceName}'.${RESET}"
        return 1
    fi

    # Disable the service
    local targetServiceEnabledStatus=$(systemctl is-enabled "$targetServiceName" 2>&1)
    case "$targetServiceEnabledStatus" in
        "disabled")
            echo -e "${GREEN}‚úî${GREY} Service '${targetServiceName}' is already disabled.${RESET}"
            return 0
            ;;
        "static")
            echo -e "${GREEN}‚úî${GREY} Service '${targetServiceName}' is static (cannot be enabled/disabled conventionally). No action needed.${RESET}"
            return 0
            ;;
        "masked")
            echo -e "${GREEN}‚úî${GREY} networking.service is masked. No disable action needed.${RESET}"
            return 0
            ;;
        *)
            echo -e "${LIGHTYELLOW}Attempting to disable service '${targetServiceName}' (current status: '$targetServiceEnabledStatus')...${RESET}"
            if sudo systemctl disable "$targetServiceName"; then
                echo -e "${GREEN}‚úî${GREY} Successfully disabled service '${targetServiceName}'.${RESET}"
            else
                echo -e "${RED}Failed to disable service '${targetServiceName}'. It might be already disabled or an error occurred.${RESET}"
                return 1
            fi
            ;;
    esac
}

# There are two primary services associated with networking in Debian/Ubuntu-based systems:
# 1. networking.service:
#    - This is the traditional System V init-style networking service.
#    - It primarily manages network interfaces configured in `/etc/network/interfaces`.
#    - It's often used for statically configured interfaces or simpler network setups.
#    - On modern systems, especially desktops and laptops, NetworkManager often takes precedence.
#
# 2. NetworkManager.service:
#    - This is a more dynamic and feature-rich network management daemon.
#    - It's the default on most modern desktop Linux distributions, including Ubuntu Desktop.
#    - It provides automatic detection and configuration for various network types (Ethernet, Wi-Fi, VPNs, etc.).
#    - It manages connections through profiles and can handle roaming, multiple connections, and user-specific settings.
#    - It usually takes control of interfaces *not* explicitly managed by `/etc/network/interfaces` (unless configured otherwise).
#
# Coexistence and Conflicts:
# - Generally, it's recommended to use *either* `networking.service` (via `/etc/network/interfaces`) *or* `NetworkManager.service` to manage a particular network interface, but not both.
# - Having both active and attempting to manage the same interfaces can lead to conflicts, unpredictable behavior, or connection issues.
# - For desktop environments, NetworkManager is usually preferred for its ease of use and dynamic capabilities.
# - For servers, especially with static IPs, `networking.service` with `/etc/network/interfaces` is often sufficient and more straightforward.
# - The script below checks if NetworkManager is active. If it is, and `networking.service` is also active,
#   it attempts to stop and disable `networking.service` to prevent potential conflicts, assuming NetworkManager
#   is the intended primary network manager.
checkNetworkManagerStatus() {
    # echo -e "${COLOR}Checking NetworkManager.service status...${RESET}"
    local nmServiceStatus=$(systemctl is-active NetworkManager.service 2>&1)
    if [ "$nmServiceStatus" == "active" ]; then
        echo -e "${GREEN}‚úî${GREY} NetworkManager is active.${RESET}"
        stopAndDisableDaemonService "networking.service"
    elif [ "$nmServiceStatus" == "inactive" ] || [ "$nmServiceStatus" == "failed" ]; then
        echo -e "${LIGHTYELLOW}NetworkManager is not active (status: ${nmServiceStatus}).${RESET}"
        echo -e "${LIGHTYELLOW}Consider enabling and starting NetworkManager if it's intended to manage network connections.${RESET}"
        if [ "$(systemctl is-active networking.service 2>/dev/null)" == "active" ]; then
            echo -e "${GREY}networking.service is active. This might be intentional if NetworkManager is not used.${RESET}"
        fi
    else
        echo -e "${RED}Could not determine status of NetworkManager (status: '$nmServiceStatus').${RESET}"
    fi
}

stopUnnecessaryServices() {
    echo -e "${COLOR}Stopping Unnecessary Services${RESET}"
    checkNetworkManagerStatus
    local services_to_manage=(
        "cups.service"          # CUPS (Common UNIX Printing System)
        "cups-browsed.service"  # CUPS Browser Support
        "nmbd.service"          # NetBIOS Name Service
        "xrdp.service"          # Remote Desktop Protocol
        # "ufw.service"           # Uncomplicated Firewall
    )
    for service in "${services_to_manage[@]}"; do
        stopAndDisableDaemonService "$service"
    done
}

installTmuxPluginsManager() {
    echo -e "${COLOR}Installing Tmux Plugins Manager${RESET}"
    if [ -d ~/.tmux/plugins/tpm ]; then
        echo -e "${GREEN}‚úî${GREY} Tmux Plug Manager is already installed${RESET}"
        return
    fi
    git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Success!${RESET}"
    else
        echo -e "${RED}Failed!${RESET}"
        exit 1
    fi
}

installVimPluginsManager (){
    echo -e "${COLOR}Installing Vim Plugins Manager${RESET}"

    if [ ! -f ~/.vimrc ]; then
        echo "No .vimrc found, Abort!"
        exit 1
    fi

    if [ ! -f "$fVimPlugsManagerPath" ]; then
        # use the --insecure option to avoid certificate check
        curl -fLo "$fVimPlugsManagerPath" --create-dirs \
        https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
    else
        echo -e "${GREEN}‚úî${GREY} Vim Plug Manager is already installed${RESET}"
    fi

    echo -e "${COLOR}Updating Vim Plugins${RESET}"
    vim +PlugInstall +PlugUpdate +qall
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}‚úî Success!${RESET}"
    else
        echo -e "${RED}‚úó Failed!${RESET}"
        exit 1
    fi
}

# linkFile: Creates a symbolic link for a file or command to a destination directory.
#
# It can link a source file by its path or a command from the system's PATH.
# The function will back up any existing non-link file at the destination.
#
# Usage:
#   linkFile <target_path_or_cmd> <destination_dir> [new_link_name] [type]
#
# Example (file):
#   linkFile ~/myfile.txt /data/backup
# Example (file with new name):
#   linkFile ~/myfile.txt /data/backup my-renamed-file.txt
# Example (command):
#   linkFile batcat ~/.usr/bin bat command
#
# Arguments:
#   $1 - The source file path or command name.
#   $2 - The destination directory where the link will be created.
#   $3 - New link name (optional, defaults to the basename of the source).
#   $4 - Type of source: 'file' (default) or 'command' (optional).
#
# Returns:
#   0 on successful link creation.
#   1 if the link is already up to date.
#   2 if the source command is not found.
#   Exits the script if a source file does not exist.
#
linkFile() {
    local src="$1"         # Source file or command
    local linkPath="$2"    # Destination directory to link to
    local newLinkName="$3" # New link name (optional, default: as is)
    local type=${4:-file}  # Type of source

    if [[ "$type" == "command" ]]; then
        local originalCmd="$src"
        src=$(command -v "$src")
        if [ -z "$src" ]; then
            echo -e "${RED}‚úó${GREY} ${originalCmd} is not installed${RESET}"
            return 2
        fi
    fi
    if [ ! -d "$linkPath" ]; then
        mkdir -p "$linkPath"
    fi

    local filename=$(basename "$src")
    local linkName=${newLinkName:-$filename}
    local dst="$linkPath/${linkName}"
    [ ! -e "$src" ] && echo -e "${RED}Error: $src does not exist${RESET}" && return 1
    if [ -f "$dst" ] && [ ! -L "$dst" ]; then
        [ ! -d "$fBackupDir" ] && mkdir -p "$fBackupDir"
        echo -e "${CYAN}Warning: $dst is not a link, backing it up into $fBackupDir${RESET}"
        mv "$dst" "$fBackupDir/${linkName}.bak"
    fi

    if [ -L "$dst" ] && [ "$(readlink "$dst")" == "$src" ]; then
        echo -e "${GREEN}‚úî${GREY} Link ${BLUE}${linkName}${GREY} is already up to date.${RESET}"
        return 1
    fi

    echo -e "üîó ${LIGHTYELLOW}Creating Symlink${RESET}"
    echo -e "   ‚îú‚îÄ ${GREY}Source:${RESET} ${CYAN}$src${RESET}"
    echo -e "   ‚îî‚îÄ ${GREY}Target:${RESET} ${CYAN}$dst${RESET}"

    local success=false
    local execPrefix=
    for _ in {1..2}; do
        if $execPrefix ln -sf "$src" "$dst" &> /dev/null; then
            success=true
            break
        fi
        if [ -z "$execPrefix" ]; then
            echo -e "   ‚îú‚îÄ ${GREY}Info:${RESET}   ${RED}Failed! Retrying with sudo...${RESET}"
            execPrefix="sudo "
        else
            break
        fi
    done
    if [ "$success" = true ]; then
        echo -e "   ‚îî‚îÄ ${GREY}Status:${RESET} ‚úî ${GREEN}Success!${RESET}"
    else
        echo -e "   ‚îî‚îÄ ${GREY}Status:${RESET} ‚ùå ${RED}Failed!${RESET}"
    fi
}

# linkFiles: Creates symbolic links for all files from a source directory to a destination directory.
#
# This function iterates through all files in a source directory and creates a
# symbolic link for each in the destination directory. After linking, it also
# removes any broken symbolic links found in the destination directory (this
# cleanup is skipped if the destination is the user's home directory).
#
# Usage:
#   linkFiles <source_dir> <destination_dir> [link_name_prefix]
#
# Example:
#   # Link files from a config folder to the home directory, creating dotfiles.
#   linkFiles ~/dotfiles/config ~/. "."
#
# Arguments:
#   $1 - The source directory containing the files to be linked.
#   $2 - The destination directory where the symbolic links will be created.
#   $3 - An optional prefix to add to the created link names (e.g., ".").
#
# Exits:
#   The script will exit if the source directory does not exist.
linkFiles() {
    local srcDir="$1"           # Source directory
    local linkPath="$2"         # Destination directory
    local linknamePrefix="$3"   # Prefix for destination filename. Exp: . for hidden files

    [ ! -d "$srcDir" ] && echo "Source directory $srcDir does not exist, abort!" && exit 1
    [ ! -d "$linkPath" ] && mkdir -p "$linkPath"

    for file in "$srcDir"/*; do
        linkFile "$file" "$linkPath" "${linknamePrefix}$(basename "$file")"
    done

    if [ "$linkPath" == "$HOME" ]; then
        return
    fi
    # Remove broken symlinks
    find "$linkPath" -type l ! \
            -exec test -e {} \; \
            -exec rm -f {} \; \
            -exec echo -e "${CYAN}Deleting broken link: {}${RESET}" \;
}

buildBatTheme() {
    # https://github.com/sharkdp/bat/tree/master/assets/themes
    echo -e "${COLOR}Building Bat Themes${RESET}"
    local batThemeDir=$HOME/.config/bat/themes
    local needBuild=
    [ ! -d "$batThemeDir" ] && mkdir -p "$batThemeDir"

    for theme in "$fTKBatThemeDir"/*; do
        linkFile "$theme" "$batThemeDir"
        if [ $? -eq 1 ]; then
            continue
        fi
        needBuild=true
    done

    [ -z "$needBuild" ] && return
    bat cache --build
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Success!${RESET}"
    else
        echo -e "${RED}Failed!${RESET}"
        exit 1
    fi
}

buildExtraFonts() {
    echo -e "${COLOR}Building Extra Fonts${RESET}"
    local needBuild=
    local fontConfigDir="$HOME/.config/fontconfig/conf.d"
    local fontDir=$HOME/.local/share/fonts
    [ ! -d "$fontDir" ] && mkdir -p "$fontDir"
    [ ! -d "$fontConfigDir" ] && mkdir -p "$fontConfigDir"

    # Detect fc-list command
    local FC_LIST_CMD="fc-list"
    local FC_CACHE_CMD="fc-cache"
    if [[ $(uname -s) == 'Darwin' ]]; then
        if command -v /opt/homebrew/bin/fc-list &> /dev/null; then
            FC_LIST_CMD="/opt/homebrew/bin/fc-list"
            FC_CACHE_CMD="/opt/homebrew/bin/fc-cache"
        elif command -v /usr/local/bin/fc-list &> /dev/null; then
            FC_LIST_CMD="/usr/local/bin/fc-list"
            FC_CACHE_CMD="/usr/local/bin/fc-cache"
        fi
    fi

    for fontConfig in "$fTKFontConfigDir"/*; do
        linkFile "$fontConfig" "$fontConfigDir"
        if [ $? -eq 1 ]; then
            continue
        fi
    done

    for font in "$fTKFontDir"/*; do
        local fontFile=$(basename "$font")

        # Check if font exists
        if command -v "$FC_LIST_CMD" &> /dev/null; then
            local fontExists=$("$FC_LIST_CMD" | grep -i "$fontFile")
            if [ -n "$fontExists" ]; then
                echo -e "${GREEN}‚úî${GREY} Font ${BLUE}${fontFile}${GREY} is already up to date.${RESET}"
                continue
            fi
        else
            # Fallback: check if font file exists in font directory
            if [ -f "$fontDir/$fontFile" ] || [ -L "$fontDir/$fontFile" ]; then
                echo -e "${GREEN}‚úî${GREY} Link ${BLUE}${fontFile}${GREY} is already up to date.${RESET}"
                continue
            fi
        fi

        linkFile "$font" "$fontDir"
        if [ $? -eq 1 ]; then
            continue
        fi
        needBuild=true
    done

    [ -z "$needBuild" ] && return

    # Build font cache if fc-cache is available
    if command -v "$FC_CACHE_CMD" &> /dev/null; then
        echo -e "${COLOR}Building font cache...${RESET}"
        if [[ $(uname -s) == 'Darwin' ]]; then
            "$FC_CACHE_CMD" -fv
        else
            sudo "$FC_CACHE_CMD" -fv
        fi
        if [ $? -eq 0 ]; then
            echo -e "${GREEN}Success!${RESET}"
        else
            echo -e "${LIGHTYELLOW}Warning: Font cache build had issues, but fonts are installed.${RESET}"
        fi
    else
        echo -e "${LIGHTYELLOW}Note: fc-cache not available, fonts installed but cache not rebuilt.${RESET}"
        echo -e "${GREY}On macOS, fonts may require logging out and back in to take effect.${RESET}"
    fi
}

changeTMOUTToWritable() {
    # TMOUT is readonly in /etc/profile, change it to writable so that we can unset it in .bashrc
    if ! grep -q "TMOUT" /etc/profile; then
        return
    fi
    echo -e "${COLOR}Changing TMOUT to Writable${RESET}"
    if grep -q "^readonly TMOUT" /etc/profile; then
        echo -e "${GREY}TMOUT is readonly in /etc/profile, change it to writable${RESET}"
    else
        echo -e "${GREEN}‚úî${GREY} TMOUT is already writable$ in /etc/profile${RESET}"
        return
    fi

    sudo sed -i 's/^readonly TMOUT/# readonly TMOUT/g' /etc/profile
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Success!${RESET}"
    else
        echo -e "${RED}Failed!${RESET}"
        exit 1
    fi
}

createTKSymlinks() {
    # The directories are guaranteed to exist when this function is called.
    echo -e "${COLOR}Creating Home Directory Symlinks${RESET}"
    linkFiles "$fTKFilesDir" "$HOME" "."
    echo -e "${COLOR}Creating Completion Symlinks${RESET}"
    linkFiles "$fTKCompDir" "$HOME/.bash_completion.d"
    echo -e "${COLOR}Creating Vim Colorscheme Symlinks${RESET}"
    linkFiles "$fTKVimColorsDir" "$HOME/.vim/colors"
}

createToolsSymlinks() {
    [ -n "$fNoInstallTools" ] && return
    echo -e "${COLOR}Creating Tool Symlinks${RESET}"
    linkFiles "$fTKToolsDir" "$HOME/.usr/bin"
    echo -e "${COLOR}Creating template symlinks${RESET}"
    linkFiles "$fTKtemplateDir" "$HOME/Templates"
}

relinkSysCmds() {
    echo -e "${COLOR}Relinking System Commands${RESET}"
    linkFile "batcat" "$HOME/.usr/bin" "bat" "command"
    linkFile "fdfind" "$HOME/.usr/bin" "fd" "command"
    linkFile "bash" "/bin" "sh" "command"
}

createMacOSBashProfile() {
    echo -e "${COLOR}Creating macOS bash_profile${RESET}"
    linkFile "$fTKFilesDir/bash_profile" "$HOME" ".bash_profile"
}

setMacOSDefaultShell() {
    # Only run on macOS
    [[ $(uname -s) != 'Darwin' ]] && return

    local HOMEBREW_BASH="/opt/homebrew/bin/bash"
    # Fallback for Intel Mac
    [ ! -x "$HOMEBREW_BASH" ] && HOMEBREW_BASH="/usr/local/bin/bash"

    if [ ! -x "$HOMEBREW_BASH" ]; then
        echo -e "${LIGHTYELLOW}Homebrew bash not found, skipping default shell setup${RESET}"
        return
    fi

    echo -e "${COLOR}Setting up Homebrew Bash as default shell${RESET}"

    # Add to /etc/shells if not already there
    if ! grep -q "^${HOMEBREW_BASH}$" /etc/shells; then
        echo -e "${GREY}Adding ${HOMEBREW_BASH} to /etc/shells${RESET}"
        sudo sh -c "echo '$HOMEBREW_BASH' >> /etc/shells"
    else
        echo -e "${GREEN}‚úî${GREY} ${HOMEBREW_BASH} already in /etc/shells${RESET}"
    fi

    # Change default shell if not already set
    if [ "$SHELL" != "$HOMEBREW_BASH" ]; then
        echo -e "${GREY}Changing default shell to ${HOMEBREW_BASH}${RESET}"
        # Use sudo to avoid password prompt (requires passwordless sudo)
        sudo chsh -s "$HOMEBREW_BASH" "$USER"
        if [ $? -eq 0 ]; then
            echo -e "${GREEN}‚úî${GREY} Default shell changed to Bash 5.x${RESET}"
            echo -e "${LIGHTYELLOW}Note: Please restart your terminal for the change to take effect.${RESET}"
        else
            echo -e "${RED}Failed to change default shell${RESET}"
        fi
    else
        echo -e "${GREEN}‚úî${GREY} Default shell is already ${HOMEBREW_BASH}${RESET}"
    fi
}

createExtraSymlinks() {
    echo -e "${COLOR}Creating Extra Symlinks${RESET}"
    # The directories are guaranteed to exist when this function is called.
    linkFile "$fTKClangdConfig" "$HOME/.config/clangd"
    linkFile "$fzfTabCompPath" "$HOME/.bash_completion.d" "fzf_tab_completion.bash"
    linkFile "$fzfBinPath" "$HOME/.usr/bin"
    linkFile "$fJCPath" "$HOME/.usr/bin"
    if [ -d "$HOME"/.vscode-server/data/Machine ]; then
        linkFile "$fMainDir"/assets/vscode/remote.settings.json "$HOME"/.vscode-server/data/Machine "settings.json"
    fi
}

createEssentialPaths() {
    local dirsToCheck=(
        "$fBackupDir"
        "$HOME/Downloads"
        "$HOME/Templates"
        "$HOME/Media"
        "$HOME/.vnc"
        "$HOME/.bash_completion.d"
        "$HOME/.usr/bin"
        "$HOME/.local/share/fonts"
        "$HOME/.config/bat/themes"
        "$HOME/.config/fontconfig/conf.d"
        "$HOME/.config/clangd"
    )

    for dir in "${dirsToCheck[@]}"; do
        if [ ! -d "$dir" ]; then
            echo -e "${LIGHTYELLOW}  Creating directory: ${BLUE}$dir${RESET}"
            mkdir -p "$dir"
            if [ $? -ne 0 ]; then
                echo -e "${RED}  Error: Failed to create directory $dir${RESET}"
                exit 1
            fi
        fi
    done

    cd "$fMainDir" || exit
}

installLatestGithubClangd() {
    echo -e "${COLOR}Checking for Github Clangd (Github Release)${RESET}"
    if [ -z "$fClangdForce" ] && command -v clangd &> /dev/null; then
        echo -e "${GREEN}‚úî${GREY} Clangd is already installed.${RESET}"
        printf "  "
        clangd --version | head -n 1 | sed 's/ (.*//'
        return 0
    fi

    # Github clangd is only available for x86_64
    if [ "$fArch" == "aarch64" ]; then
        echo -e "${LIGHTYELLOW}Github clangd is not available for $fArch architecture.${RESET}"
        echo -e "${LIGHTYELLOW}Installing clangd from apt package manager.${RESET}"
        sudo apt install clangd -y
        return
    fi

    if ! command -v jq &> /dev/null; then
        echo -e "${RED}Error: jq is required but not installed. Please install jq first.${RESET}"
        return 1
    fi

    local currentVersion="0.0.0"
    local clangdPath=$(command -v clangd 2>/dev/null)
    if [ -n "$clangdPath" ]; then
        currentVersion=$($clangdPath --version | head -n1 | grep -oP 'version \K[0-9]+\.[0-9]+\.[0-9]+' || echo "")
        echo -e "Current clangd version: ${BLUE}$currentVersion${RESET}"
    fi

    # Get the latest stable release version and download URL
    echo -e "${LIGHTYELLOW}Fetching latest Clangd binary information${RESET}"
    # 20.1.0
    # https://github.com/clangd/clangd/releases/download/20.1.0/clangd-linux-20.1.0.zip
    local output=$(curl -s https://api.github.com/repos/clangd/clangd/releases |
        jq -r '[.[] | select(.prerelease == false)] | .[0] |
               .name, (.assets[] | select(.name | contains("clangd-linux")) | .browser_download_url)')
    mapfile -t lines <<< "$output"
    local latestVersion="${lines[0]}"
    local downloadUrl="${lines[1]}"
    if [ -z "$latestVersion" ] || [ "$latestVersion" == "null" ]; then
        echo -e "${RED}Error: Failed to get latest version information${RESET}"
        return 1
    fi

    echo -e "Latest available clangd version: ${COLOR}$latestVersion${RESET}"
    if [ -n "$currentVersion" ]; then
        if [ "$(printf '%s\n' "$latestVersion" "$currentVersion" | sort -V -r | head -n1)" == "$currentVersion" ]; then
            echo -e "${GREY}No update needed. Current version is up to date.${RESET}"
            return 0
        fi
    fi

    echo -e "${LIGHTYELLOW}Downloading latest version of Clangd${RESET}"
    local fileName=$(basename "$downloadUrl")
    local downloadDst="$fDownloads/$fileName"
    if [ -f "$downloadDst" ]; then
        echo -e "${GREY}File $fileName already exists in $fDownloads, skipping download.${RESET}"
    else
        curl -Lo "$downloadDst" "$downloadUrl"
        if [ $? -ne 0 ]; then
            echo -e "${RED}Error: Failed to download the latest version${RESET}"
            return 1
        fi
    fi

    cd "$fDownloads" || exit 1
    local peekInfo=$(zipinfo -1 "$downloadDst" | head -n 1)
    local extractDir="$fDownloads/$(dirname "$peekInfo")"
    if [ -d "$extractDir" ]; then
        echo -e "${GREY}Directory $extractDir already exists, skipping extraction.${RESET}"
    else
        echo -e "${LIGHTYELLOW}Extracting Clangd${RESET}"
        unzip "$downloadDst"
        if [ ! -d "$extractDir" ]; then
            echo -e "${RED}Error: Failed to extract the downloaded file${RESET}"
            exit 1
        fi
        echo -e "${GREEN}Successfully extracted to $extractDir${RESET}"
    fi

    # find binary named clangd under the extracted directory
    local clangdBinary=$(find "$extractDir" -type f -name "clangd" -executable | head -n 1)
    if [ -z "$clangdBinary" ]; then
        echo -e "${RED}Error: Failed to find the clangd binary in the extracted directory${RESET}"
        return 1
    fi

    linkFile "$clangdBinary" "$HOME/.usr/bin"
}

createFirstTimeFile() {
    [ -f "$fFirstTimeFile" ] && return
    touch "$fFirstTimeFile"
}

installLatestGitLfs() {
    echo -e "${COLOR}Checking for Git LFS (PackageCloud)${RESET}"

    if [ -z "$fGitLfsForce" ] && command -v git-lfs &>/dev/null; then
        local lfsPolicy
        lfsPolicy=$(apt-cache policy git-lfs)
        local installedVersion candidateVersion
        installedVersion=$(echo "$lfsPolicy" | grep "Installed:" | awk '{print $2}')
        candidateVersion=$(echo "$lfsPolicy" | grep "Candidate:" | awk '{print $2}')

        if [ "$installedVersion" != "(none)" ] && [ "$installedVersion" == "$candidateVersion" ]; then
            if echo "$lfsPolicy" | grep -q "packagecloud.io"; then
                echo -e "${GREEN}‚úî${GREY} Git LFS (from PackageCloud) is already installed and up-to-date.${RESET}"
                printf "  "
                git-lfs --version | head -n 1
                return 0
            fi
        fi
    fi

    echo -e "${LIGHTYELLOW}Proceeding with Git LFS installation/update from PackageCloud...${RESET}"

    # 1. Add the Git LFS repository
    echo -e "${LIGHTYELLOW}Checking for Git LFS repository (packagecloud.io)...${RESET}"
    if grep -qr "packagecloud.io/github/git-lfs" /etc/apt/sources.list /etc/apt/sources.list.d/ 2>/dev/null; then
        echo -e "${GREEN}‚úî${GREY} Git LFS repository already configured.${RESET}"
    else
        echo -e "${LIGHTYELLOW}Adding the Git LFS repository script from packagecloud.io...${RESET}"
        if ! curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash; then
            echo -e "${RED}Error: Failed to add Git LFS repository. Aborting.${RESET}"
            return 1
        fi
        echo -e "${GREEN}Git LFS repository added successfully.${RESET}"
    fi

    # 2. Create the preference file to prioritize PackageCloud Git LFS
    local preferenceFilePath="/etc/apt/preferences.d/git-lfs-ppa-priority"
    local preferenceContent
    preferenceContent=$(cat <<'EOF'
Package: git-lfs
Pin: origin packagecloud.io
Pin-Priority: 1001

Package: git-lfs
Pin: release o=Ubuntu*
Pin-Priority: -1
EOF
)
    echo -e "${LIGHTYELLOW}Setting up APT preferences to prioritize Git LFS from PackageCloud...${RESET}"
    if [ -f "$preferenceFilePath" ] && cmp -s <(echo "$preferenceContent") "$preferenceFilePath"; then
        echo -e "${GREY}APT preference file '$preferenceFilePath' already exists and is correctly configured.${RESET}"
    else
        echo "$preferenceContent" | sudo tee "$preferenceFilePath" > /dev/null
        if [ $? -eq 0 ]; then
            echo -e "${GREEN}APT preference file '$preferenceFilePath' created/updated successfully.${RESET}"
        else
            echo -e "${RED}Failed to create/update APT preference file '$preferenceFilePath'. Aborting.${RESET}"
            return 1
        fi
    fi

    # 3. Update package list and install
    echo -e "${LIGHTYELLOW}Updating package lists...${RESET}"
    if ! sudo apt update; then
        echo -e "${RED}Error: Failed to update apt package list. Aborting.${RESET}"
        return 1
    fi

    echo -e "${LIGHTYELLOW}Installing Git LFS...${RESET}"
    if ! sudo DEBIAN_FRONTEND=noninteractive apt install -y git-lfs; then
        echo -e "${RED}Error: Failed to install git-lfs. Aborting.${RESET}"
        return 1
    fi
    echo -e "${GREEN}Git LFS installed successfully.${RESET}"

    # 4. Initialize Git LFS for the user
    echo -e "${LIGHTYELLOW}Running 'git lfs install' to initialize Git LFS...${RESET}"
    if git lfs install; then
        echo -e "${GREEN}Git LFS initialized successfully for the current user.${RESET}"
    else
        echo -e "${RED}Warning: 'git lfs install' command failed. You may need to run it manually.${RESET}"
    fi
    echo -e "${GREEN}--- Git LFS Installation Process Completed ---${RESET}"
    git-lfs --version
    return 0
}

installLatestPPaDocker() {
    echo -e "${COLOR}Checking for Docker${RESET}"
    if command -v docker &> /dev/null && [ -z "$fDockerForce" ]; then
        echo -e "${GREEN}‚úî${GREY} Docker is already installed.${RESET}"
        printf "  "
        docker --version
        return 0
    fi

    # 1. Uninstall old versions
    echo -e "${LIGHTYELLOW}Uninstalling old Docker versions (if any)...${RESET}"
    sudo apt-get remove -y docker docker-engine docker.io containerd runc > /dev/null 2>&1
    sudo apt-get autoremove -y > /dev/null 2>&1
    echo -e "${GREY}Old versions uninstalled/autoremoved (if any existed).${RESET}"

    # 2. Set up the repository
    echo -e "${LIGHTYELLOW}Setting up Docker repository...${RESET}"
    if ! sudo apt-get update; then
        echo -e "${RED}Failed to update apt package list.${RESET}"
        exit 1
    fi

    if [ ! -d /etc/apt/keyrings ] && ! sudo install -m 0755 -d /etc/apt/keyrings; then
        echo -e "${RED}Failed to create /etc/apt/keyrings directory.${RESET}"
        exit 1
    fi

    # Step 2a: Add Docker's official GPG key
    local dockerGpgKey="/etc/apt/keyrings/docker.gpg"
    if [ -f "$dockerGpgKey" ]; then
        echo -e "${GREEN}‚úî${GREY} Docker GPG key already exists.${RESET}"
    else
        echo -e "${LIGHTYELLOW}Downloading Docker's official GPG key...${RESET}"
        # Download Docker's official GPG key
        if ! curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o "$dockerGpgKey"; then
            echo -e "${RED}Failed to download or dearmor Docker GPG key.${RESET}"
            exit 1
        fi
        if ! sudo chmod a+r "$dockerGpgKey"; then
        echo -e "${RED}Failed to set permissions for Docker GPG key.${RESET}"
        exit 1
    fi
        echo -e "${GREEN}Docker GPG key downloaded and configured successfully.${RESET}"
    fi

    # Step 2b: Add the Docker repository to Apt sources.
    # This command creates the repository source file and points to Docker's official repository.
    # The `signed-by` option tells apt to verify packages from this repo using the key we just downloaded.
    # This now uses the official recommended method from Docker's documentation.
    if ! echo \
      "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
      $(lsb_release -cs) stable" | \
      sudo tee /etc/apt/sources.list.d/docker.list > /dev/null; then
        echo -e "${RED}Failed to add Docker repository to apt sources.${RESET}"
        exit 1
    fi
    echo -e "${GREEN}Docker repository set up successfully.${RESET}"

    # Step 3: Install Docker Engine.
    echo -e "${LIGHTYELLOW}Updating package list and installing Docker Engine...${RESET}"
    if ! sudo apt-get update; then
        echo -e "${RED}Failed to update apt package list after adding Docker repo.${RESET}"
        exit 1
    fi
    if ! sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin; then
        echo -e "${RED}Failed to install Docker Engine packages.${RESET}"
        exit 1
    fi
    echo -e "${GREEN}Docker Engine installed successfully.${RESET}"

    # Step 4: Verify installation by running the hello-world container.
    echo -e "${LIGHTYELLOW}Verifying Docker installation by running hello-world...${RESET}"
    if sudo docker run hello-world; then
        echo -e "${GREEN}Docker hello-world container ran successfully.${RESET}"
    else
        echo -e "${RED}Docker hello-world container failed to run. Docker might be installed but requires attention.${RESET}"
    fi

    # Step 5: Post-installation steps (run Docker as a non-root user).
    echo -e "${LIGHTYELLOW}Configuring Docker to run without sudo for current user ($USER)...${RESET}"
    # Create the 'docker' group if it doesn't exist.
    if ! getent group docker > /dev/null; then
        echo -e "${GREY}Docker group does not exist, creating it...${RESET}"
        if ! sudo groupadd docker; then
            echo -e "${RED}Failed to create 'docker' group. You may need to do this manually.${RESET}"
        else
            echo -e "${GREEN}'docker' group created.${RESET}"
        fi
    else
        echo -e "${GREY}'docker' group already exists.${RESET}"
    fi

    # Add the current user to the 'docker' group.
    if getent group docker > /dev/null; then
        if sudo usermod -aG docker "$USER"; then
            echo -e "${GREEN}User '$USER' added to the 'docker' group.${RESET}"
            echo -e "${BOLD}${MAGENTA}IMPORTANT: You must log out and log back in, or run 'newgrp docker', for this change to take effect.${RESET}"
        else
            echo -e "${RED}Failed to add user $USER to the 'docker' group. You may need to do this manually (e.g., sudo usermod -aG docker \"\$USER\").${RESET}"
        fi
    else
        echo -e "${RED}Cannot add user to 'docker' group as the group does not exist or could not be created.${RESET}"
    fi

    echo -e "${GREEN}Docker installation and basic configuration process completed.${RESET}"
}

installLatestRimePinyin() {
    echo -e "${COLOR}Checking Rime Pinyin Input Method${RESET}"
    if [ -z "$fChinesePinyinForce" ]; then
        for cmd in fcitx5 fcitx; do
            if command -v "${cmd}-configtool" &>/dev/null; then
                echo -e "${GREEN}‚úî${GREY} Rime Pinyin input method is already installed.${RESET}"
                printf "  "
                "$cmd" --version
                return 0
            fi
        done
    fi

    echo -e "${LIGHTYELLOW}Updating package lists...${RESET}"
    if ! sudo apt update; then
        echo -e "${RED}Failed to update apt package list. Aborting Rime installation.${RESET}"
        return 1
    fi

    local fcitxXProfilePath=$fMainDir/assets/rime/fcitx5.xprofile
    local rimeDefaultCustomYaml=$fMainDir/assets/rime/default.custom.yaml
    local localRimePath="$HOME/.local/share/fcitx5/rime"
    # --- Attempt Fcitx5-Rime first ---
    echo -e "${COLOR}Checking for Fcitx5-Rime availability...${RESET}"
    if apt-cache show fcitx5-rime > /dev/null 2>&1; then
        echo -e "${GREEN}Fcitx5-Rime (fcitx5-rime) appears to be available. Attempting installation.${RESET}"
        local packagesToInstallFcitx5=(
            fcitx5
            fcitx5-rime
            fcitx5-chinese-addons # Provides general Chinese support, dictionaries, etc.
            # fcitx5-configtool     # GUI configuration tool (e.g., fcitx5-config-qt)
            fcitx5-config-qt      # GUI configuration tool
            im-config             # Input method configuration tool (sets fcitx5 as default)
        )

        # Link the xprofile file
        linkFile "$fcitxXProfilePath" "$HOME" .xprofile
        linkFile "$rimeDefaultCustomYaml" "$localRimePath" default.custom.yaml
        echo -e "${LIGHTYELLOW}Installing Fcitx5 packages: ${packagesToInstallFcitx5[*]}${RESET}"
        if sudo DEBIAN_FRONTEND=noninteractive apt install -y "${packagesToInstallFcitx5[@]}"; then
            echo -e "${GREEN}Successfully installed Fcitx5 and Rime packages.${RESET}"
            echo -e "${LIGHTYELLOW}Setting fcitx5 as the default input method system-wide using im-config...${RESET}"
            if sudo im-config -n fcitx5; then
                echo -e "${GREEN}Successfully configured fcitx5 as the default input method via im-config.${RESET}"
                echo -e "${GREY}(im-config handles setting environment variables like XMODIFIERS, GTK_IM_MODULE, QT_IM_MODULE for graphical sessions)${RESET}"
            else
                echo -e "${RED}Failed to set fcitx5 as the default input method using im-config.${RESET}"
                echo -e "${LIGHTYELLOW}You might need to run 'im-config' (as a regular user, not sudo) to select fcitx5, or configure it via your desktop environment's settings.${RESET}"
                echo -e "${LIGHTYELLOW}Alternatively, for X11 sessions, ensure these lines are in your ~/.xprofile or similar (e.g., ~/.profile, ~/.xinitrc):${RESET}"
                echo -e "${LIGHTYELLOW}  export GTK_IM_MODULE=fcitx5${RESET}"
                echo -e "${LIGHTYELLOW}  export QT_IM_MODULE=fcitx5${RESET}"
                echo -e "${LIGHTYELLOW}  export XMODIFIERS=@im=fcitx5${RESET}"
            fi

            echo -e "${GREEN}Fcitx5-Rime installation and basic configuration process completed.${RESET}"
            echo -e "${BOLD}${MAGENTA}IMPORTANT: A system REBOOT or RE-LOGIN is REQUIRED for all changes to take full effect.${RESET}"
            echo -e "${LIGHTYELLOW}After rebooting/re-logging in:${RESET}"
            echo -e "${LIGHTYELLOW}1. Fcitx5 should start automatically. If not, add 'fcitx5' to your session's startup applications.${RESET}"
            echo -e "${LIGHTYELLOW}2. Open 'Fcitx 5 Configuration' (command: ${BLUE}fcitx5-configtool${RESET}).${RESET}"
            echo -e "${LIGHTYELLOW}3. In the 'Input Method' tab, ensure 'Rime' is in the list of active input methods. ${RESET}"
            echo -e "${LIGHTYELLOW}   If not, click the '+' button, uncheck 'Only Show Current Language' if needed, find 'Rime', and add it.${RESET}"
            echo -e "${LIGHTYELLOW}4. You can switch input methods using the configured hotkey (often Ctrl+Space or Super+Space). Check 'Global Options' tab in fcitx5-configtool for 'Trigger Input Method'.${RESET}"
            echo -e "${LIGHTYELLOW}5. For Rime specific settings (e.g., traditional Chinese, fuzzy pinyin), create/edit files in ${BLUE}~/.local/share/fcitx5/rime/${RESET} (e.g., default.custom.yaml). Refer to Rime documentation.${RESET}"
            return 0
        else
            echo -e "${RED}Failed to install Fcitx5-Rime packages. Will try Fcitx4-Rime as a fallback.${RESET}"
        fi
    else
        echo -e "${LIGHTYELLOW}Fcitx5-Rime (fcitx5-rime) not found in official repositories. Checking for Fcitx4-Rime.${RESET}"
    fi

    # --- Attempt Fcitx4-Rime (fcitx) if Fcitx5-Rime was not available or failed ---
    echo -e "${COLOR}Checking for Fcitx4-Rime (fcitx-rime) availability...${RESET}"
    if apt-cache show fcitx-rime > /dev/null 2>&1; then
        echo -e "${GREEN}Fcitx4-Rime (fcitx-rime) appears to be available. Attempting installation.${RESET}"
        local packagesToInstallFcitx4=(
            fcitx
            fcitx-rime
            fcitx-table-all       # Common tables for fcitx4, includes pinyin etc.
            fcitx-frontend-gtk3
            fcitx-frontend-qt5    # Or fcitx-libs-qt5 on older systems
            fcitx-config-gtk      # GUI config tool for fcitx4 (or fcitx-configtool)
            im-config
        )

        # Link .xprofile to ~/.xprofile
        fcitxXProfilePath=$fMainDir/assets/rime/fcitx.xprofile
        linkFile "$fcitxXProfilePath" "$HOME" .xprofile
        localRimePath="$HOME/.config/fcitx/rime"
        linkFile "$rimeDefaultCustomYaml" "$localRimePath" default.custom.yaml
        echo -e "${LIGHTYELLOW}Installing Fcitx4 packages: ${packagesToInstallFcitx4[*]}${RESET}"
        if sudo DEBIAN_FRONTEND=noninteractive apt install -y "${packagesToInstallFcitx4[@]}"; then
            echo -e "${GREEN}Successfully installed Fcitx4 and Rime packages.${RESET}"

            echo -e "${LIGHTYELLOW}Setting fcitx as the default input method system-wide using im-config...${RESET}"
            if sudo im-config -n fcitx; then # Note: 'fcitx' for fcitx4
                echo -e "${GREEN}Successfully configured fcitx as the default input method via im-config.${RESET}"
            else
                echo -e "${RED}Failed to set fcitx as the default input method using im-config.${RESET}"
                echo -e "${LIGHTYELLOW}You might need to run 'im-config' (as a regular user) to select fcitx, or configure it via your desktop environment's settings.${RESET}"
                echo -e "${LIGHTYELLOW}Alternatively, for X11 sessions, ensure these lines are in your ~/.xprofile or similar:${RESET}"
                echo -e "${LIGHTYELLOW}  export GTK_IM_MODULE=fcitx${RESET}"
                echo -e "${LIGHTYELLOW}  export QT_IM_MODULE=fcitx${RESET}"
                echo -e "${LIGHTYELLOW}  export XMODIFIERS=@im=fcitx${RESET}"
            fi

            echo -e "${GREEN}Fcitx4-Rime installation and basic configuration process completed.${RESET}"
            echo -e "${BOLD}${MAGENTA}IMPORTANT: A system REBOOT or RE-LOGIN is REQUIRED for all changes to take full effect.${RESET}"
            echo -e "${LIGHTYELLOW}After rebooting/re-logging in:${RESET}"
            echo -e "${LIGHTYELLOW}1. Fcitx should start automatically. If not, add 'fcitx' to your session's startup applications.${RESET}"
            echo -e "${LIGHTYELLOW}2. Open 'Fcitx Configuration' (command: ${BLUE}fcitx-config-gtk${RESET} or ${BLUE}fcitx-configtool${RESET}).${RESET}"
            echo -e "${LIGHTYELLOW}3. Ensure 'Rime' is in the list of active input methods. If not, add it.${RESET}"
            echo -e "${LIGHTYELLOW}4. Switch input methods using the configured hotkey (e.g., Ctrl+Space).${RESET}"
            echo -e "${LIGHTYELLOW}5. Rime user data for fcitx4 is typically in ${BLUE}~/.config/fcitx/rime/${RESET}. Check Rime documentation.${RESET}"
            return 0
        else
            echo -e "${RED}Failed to install Fcitx4-Rime packages.${RESET}"
        fi
    else
        echo -e "${LIGHTYELLOW}Fcitx4-Rime (fcitx-rime) not found in official repositories.${RESET}"
    fi

    echo -e "${RED}Could not install Rime (neither Fcitx5-Rime nor Fcitx4-Rime) from official repositories.${RESET}"
    echo -e "${LIGHTYELLOW}Please ensure your system is Ubuntu/Debian based and your package sources are correctly configured.${RESET}"
    echo -e "${LIGHTYELLOW}No Rime input method was installed.${RESET}"
    return 1
}

installLatestPPaFirefox() {
    echo -e "${COLOR}Checking for Firefox (Mozilla PPA)${RESET}"
    if ! apt-cache show fcitx5-rime > /dev/null 2>&1; then
        echo -e "${GREEN}‚úî${GREY} The current version of Firefox is acceptable.${RESET}"
        return 0
    fi

    # Check if Firefox is installed and if it's the DEB version from Mozilla PPA
    if [ -z "$fFirefoxForce" ] && command -v firefox &>/dev/null; then
        firefoxPolicy=$(apt-cache policy firefox)
        if echo "$firefoxPolicy" | grep -q "mozillateam/ppa"; then
            installedVersion=$(echo "$firefoxPolicy" | grep "Installed:" | awk '{print $2}')
            candidateVersion=$(echo "$firefoxPolicy" | grep "Candidate:" | awk '{print $2}')
            if [ "$installedVersion" != "(none)" ] && [ "$installedVersion" == "$candidateVersion" ]; then
                echo -e "${GREEN}‚úî${GREY} Firefox (Mozilla PPA) is already installed and up-to-date.${RESET}"
                echo "  $installedVersion"
                return 0
            fi
        elif echo "$firefoxPolicy" | grep -q "snap"; then
            echo -e "${LIGHTYELLOW}Snap version of Firefox found. Will attempt to replace with DEB version.${RESET}"
        fi
    fi

    # 1. Add the Mozilla PPA
    echo -e "${LIGHTYELLOW}Checking for Mozilla PPA (ppa:mozillateam/ppa)...${RESET}"
    if grep -qr "mozillateam/ppa" /etc/apt/sources.list /etc/apt/sources.list.d/ 2>/dev/null; then
        echo -e "${GREEN}‚úî${GREY} Mozilla PPA already configured.${RESET}"
    else
        echo -e "${LIGHTYELLOW}Adding the Mozilla PPA...${RESET}"
        if ! sudo add-apt-repository -y ppa:mozillateam/ppa; then
            echo -e "${RED}Failed to add Mozilla PPA. Aborting Firefox DEB installation.${RESET}"
            return 1
        fi
        echo -e "${GREEN}Mozilla PPA added successfully.${RESET}"
    fi

    # 2. Create the preference file to prioritize PPA Firefox
    local preferenceFilePath="/etc/apt/preferences.d/mozilla-firefox-nosnap"
    local preferenceContent=$(cat <<EOF
Package: *
Pin: release o=LP-PPA-mozillateam
Pin-Priority: 1001

Package: firefox
Pin: release o=Ubuntu*
Pin-Priority: -1
EOF
)
    echo -e "${LIGHTYELLOW}Setting up APT preferences to prioritize Mozilla PPA Firefox...${RESET}"
    if [ -f "$preferenceFilePath" ] && cmp -s <(echo "$preferenceContent") "$preferenceFilePath"; then
        echo -e "${GREY}APT preference file '$preferenceFilePath' already exists and is correctly configured.${RESET}"
    else
        echo "$preferenceContent" | sudo tee "$preferenceFilePath" > /dev/null
        if [ $? -eq 0 ]; then
            echo -e "${GREEN}APT preference file '$preferenceFilePath' created/updated successfully.${RESET}"
        else
            echo -e "${RED}Failed to create/update APT preference file '$preferenceFilePath'. Aborting.${RESET}"
            return 1
        fi
    fi

    # 3. Uninstall Snap Firefox (if present)
    if snap list firefox &>/dev/null; then
        echo -e "${LIGHTYELLOW}Uninstalling Snap version of Firefox...${RESET}"
        if ! sudo snap remove firefox; then
            echo -e "${RED}Failed to remove Snap Firefox. This might interfere. Continuing, but manual removal might be needed.${RESET}"
        else
            echo -e "${GREEN}Snap Firefox removed successfully.${RESET}"
        fi
    else
        echo -e "${GREY}Snap version of Firefox not found. Skipping removal.${RESET}"
    fi

    # 4. Install DEB Firefox
    echo -e "${LIGHTYELLOW}Updating package lists...${RESET}"
    if ! sudo apt update; then
        echo -e "${RED}Failed to update apt package list after PPA and preference changes. Aborting Firefox installation.${RESET}"
        return 1
    fi

    echo -e "${LIGHTYELLOW}Installing Firefox from Mozilla PPA...${RESET}"
    if ! sudo apt install -y firefox; then
        echo -e "${RED}Failed to install Firefox from Mozilla PPA.${RESET}"
        echo -e "${LIGHTYELLOW}Attempting to install specific components that might be missing (e.g., language packs)...${RESET}"
        sudo apt install -y firefox-locale-en # Example for English, adjust if needed
        if ! sudo apt install -y firefox; then # Retry main installation
             echo -e "${RED}Still failed to install Firefox after attempting component install.${RESET}"
             return 1
        fi
    fi

    # 5. Verify installation
    if command -v firefox &>/dev/null; then
        firefoxVersion=$(firefox --version)
        firefoxPolicyAfter=$(apt-cache policy firefox)
        if echo "$firefoxPolicyAfter" | grep -q "mozillateam/ppa"; then
            echo -e "${GREEN}Firefox installed successfully! Version: $firefoxVersion${RESET}"
            echo -e "${GREY}Policy check confirms it's from Mozilla PPA.${RESET}"
        else
            echo -e "${RED}Firefox installed, but it might not be the DEB version from Mozilla PPA. Please check 'apt-cache policy firefox'.${RESET}"
        fi
    else
        echo -e "${RED}Firefox installation failed or binary not found in PATH.${RESET}"
        return 1
    fi
    return 0
}

linkClangFormat() {
    local argVal="$1"
    if [ -n "$argVal" ]; then
        if [ ! -d "$argVal" ]; then
            echo -e "${RED}Error: Link path '$argVal' is not a valid directory.${RESET}" >&2
            exit 1
        fi
        fLinkClangFormatPath="$argVal"
    fi

    local realClangFormatPath=$fMainDir/assets/clangd/clang-format
    echo -e "${LIGHTYELLOW}Linking clang-format to $fLinkClangFormatPath/.clang-format${RESET}"
    linkFile "$realClangFormatPath" "$fLinkClangFormatPath" .clang-format
}

vncLock() {
    if ! command -v xfce4-screensaver-command &> /dev/null; then
        echo -e "${RED}Error: xfce4-screensaver-command is not installed.${RESET}" >&2
        exit 1
    fi
    if [ $# -lt 1 ]; then
        echo -e "${RED}Error: Missing action argument.${RESET}" >&2
        exit 1
    fi

    local DISPLAY_NUM=":$fVncAbbrePort"
    local ACTION="$1"
    set -x
    case "$ACTION" in
        lock)
            DISPLAY="$DISPLAY_NUM" xfce4-screensaver-command --lock
            ;;
        unlock)
            DISPLAY="$DISPLAY_NUM" xfce4-screensaver-command --deactivate || {
                echo "Unlock failed. Please check:"
                echo "1. Correct DISPLAY setting (currently using $DISPLAY_NUM)"
                echo "2. Screen may require manual password entry"
                echo "3. Try restarting screensaver: pkill -f xfce4-screensaver"
                return 1
            }
            ;;
        status)
            DISPLAY="$DISPLAY_NUM" xfce4-screensaver-command --query
            ;;
        *)
            echo "Usage: $SCRIPT_NAME --vnclock [lock|unlock|status]"
            return 1
            ;;
    esac
}

isVncServerRunning() {
    if ! command -v tigervncserver &> /dev/null; then
        echo -e "${RED}Error: vncserver is not installed.${RESET}" >&2
        exit 1
    fi
    if lsof -i :$fVncFullPort | grep --quiet LISTEN; then
        return 0
    else
        return 1
    fi
}

stopVncServer() {
    if isVncServerRunning; then
        echo -e "${LIGHTYELLOW}Stopping VNC server on port $fVncFullPort...${RESET}"
        tigervncserver -kill :$fVncAbbrePort
    else
        echo -e "${LIGHTYELLOW}VNC server on port $fVncFullPort is not running.${RESET}"
    fi
}

# genChineseLocale() {
#     if ! command -v locale-gen &> /dev/null; then
#         echo -e "${RED}Error: locale-gen is not installed.${RESET}" >&2
#         exit 1
#     fi

#     if locale -a | grep -iq '^zh_CN\.utf8$'; then
#         return 0
#     fi

#     echo -e "${GREEN}Generating Chinese locale (zh_CN.UTF-8)...${RESET}"
#     sudo locale-gen zh_CN.UTF-8
#     sudo update-locale LANG=en_US.UTF-8 LC_CTYPE=zh_CN.UTF-8 # Update /etc/default/locale
#     if [ $? -eq 0 ]; then
#         echo -e "${GREEN}‚úî${GREY} Chinese locale generated successfully.${RESET}"
#     else
#         echo -e "${RED}Error: Failed to generate Chinese locale.${RESET}"
#         return 1
#     fi
# }

startVncServer() {
    if isVncServerRunning; then
        echo -e "${LIGHTYELLOW}VNC server on port $fVncFullPort is already running.${RESET}"
        return 0
    fi
    local hostIpAddress=$(hostname -I | awk '{print $1}')
    local hostUsername=$(whoami)
    local xstartupPath=$fMainDir/assets/vnc/xstartup
    local xstartupDest=$HOME/.vnc/xstartup
    [ -d "$HOME"/.vnc ] || mkdir -p "$HOME"/.vnc
    cd "$HOME"/.vnc || exit
    linkFile "$xstartupPath" "$HOME/.vnc" xstartup
    linkFile "$fMainDir/assets/gdm3/custom.conf" "/etc/gdm3" custom.conf
    echo -e "${GREEN}Starting VNC server...${RESET}"
    local startCmd="tigervncserver :$fVncAbbrePort -geometry $fVncResolution -SecurityTypes None -localhost yes -depth 24 -xstartup $xstartupDest"
    echo -e "${MAGENTA}$startCmd${RESET}"
    $startCmd
    if [ $? -ne 0 ]; then
        echo -e "${RED}Failed to start VNC server.${RESET}"
        return 1
    fi
    echo -e "${MAGENTA}VNC server started successfully:${RESET}"
    sudo lsof -i :5909
    echo -e "${CYAN}===================================================${RESET}"
    echo -e "${BOLD}${LIGHTYELLOW}- On your local machine, setup the SSH tunnel as follows:${RESET}"
    echo -e "  ${GREEN}Option 1.${RESET} Use Vs Code Port Forward feature to forward the port ${MAGENTA}$fVncFullPort${RESET}"
    echo -e "  ${GREEN}Option 2.${RESET} Open a terminal and run the following command:"
    echo -e "    ${BLUE}ssh -NL ${MAGENTA}$fVncFullPort${BLUE}:localhost:${MAGENTA}$fVncFullPort ${MAGENTA}$hostUsername@$hostIpAddress${RESET}"
    echo -e "    ${GREY}or simply:${RESET} ${BLUE}ssh -NL ${MAGENTA}$fVncFullPort${BLUE}:localhost:${MAGENTA}$fVncFullPort ${MAGENTA}droplet1${RESET}"
    echo -e "${BOLD}${LIGHTYELLOW}- Connect to the VNC server using a VNC viewer:${RESET}"
    echo -e "  ${BLUE}vncviewer localhost:${MAGENTA}$fVncFullPort${RESET}"
    echo -e "${CYAN}===================================================${RESET}"
}

restartVncServer() {
    stopVncServer
    sleep 1
    startVncServer
}

isOpenGrokContainerRunning() {
    if ! command -v docker &> /dev/null; then
        echo -e "${RED}Error: Docker is not installed. Please install Docker first.${RESET}"
        exit 1
    fi
    if ! docker info > /dev/null 2>&1; then
        echo -e "${RED}Error: Docker daemon does not seem to be running or accessible.${RESET}"
        echo -e "${LIGHTYELLOW}Please ensure Docker is started and you have permissions (e.g., current user in 'docker' group, or running commands with sudo).${RESET}"
        exit 1
    fi
    if docker ps -q --filter "name=^/${OPENGROK_CONTAINER_NAME}$" | grep -q .; then
        return 0
    else
        return 1
    fi
}

startOpenGrokIndexer() {
    # docker exec -it opengrok bash
    if ! isOpenGrokContainerRunning; then
        echo -e "${GREEN}‚úî${GREY} OpenGrok container ('${OPENGROK_CONTAINER_NAME}') is not running.${RESET}"
        return 0
    fi
    echo -e "${MAGENTA}Starting OpenGrok indexer...${RESET}"
    docker exec $OPENGROK_CONTAINER_NAME java \
    -Djava.util.logging.config.file=/opengrok/etc/logging.properties \
    -jar /opengrok/lib/opengrok.jar \
    -c /usr/local/bin/ctags \
    -s /opengrok/src \
    -d /opengrok/data \
    -H -P -S -G \
    -W /opengrok/etc/configuration.xml
}

stopOpenGrokContainer() {
    if ! isOpenGrokContainerRunning; then
        echo -e "${GREEN}‚úî${GREY} OpenGrok container ('${OPENGROK_CONTAINER_NAME}') is not running.${RESET}"
        return 0
    fi
    echo -e "${MAGENTA}Stopping OpenGrok Docker container...${RESET}"
    docker stop $OPENGROK_CONTAINER_NAME &> /dev/null
}

startOpenGrokContainer() {
    if isOpenGrokContainerRunning; then
        echo -e "${GREEN}‚úî${GREY} OpenGrok container ('${OPENGROK_CONTAINER_NAME}') is already running.${RESET}"
        echo -e "${LIGHTYELLOW}Access it at: ${BOLD}http://localhost:${OPENGROK_HOST_PORT}${RESET}"
        return 0
    fi

    echo -e "${MAGENTA}Deploying and starting OpenGrok Docker container...${RESET}"
    for dirPath in $OPENGROK_SRC_VOLUME $OPENGROK_DATA_VOLUME $OPENGROK_ETC_VOLUME; do
        if [ ! -d "$dirPath" ]; then
            echo -e "${GREY}Creating directory with sudo: ${BLUE}$dirPath${RESET}"
            if ! mkdir -p "$dirPath"; then
                echo -e "${RED}Error: Failed to create host directory ${BLUE}$dirPath${RED} with sudo.${RESET}"
                return 1
            fi
            echo -e "${GREEN}‚úî${GREY} Directory ${BLUE}$dirPath${GREY} created.${RESET}"
        fi
    done
    echo -e "${GREEN}‚úî${GREY} Host source directory ensured: ${BLUE}$OPENGROK_SRC_VOLUME${RESET}"
    echo -e "${LIGHTYELLOW}IMPORTANT: Place your source code repositories inside ${BOLD}$OPENGROK_SRC_VOLUME${LIGHTYELLOW} for OpenGrok to index.${RESET}"
    echo -e "${GREY}OpenGrok data and configuration will be stored in Docker managed volumes ('${OPENGROK_DATA_VOLUME}', '${OPENGROK_ETC_VOLUME}').${RESET}"

    # Check if container exists (but is stopped) and remove it to avoid conflicts
    if docker ps -aq --filter "name=^/${OPENGROK_CONTAINER_NAME}$" | grep -q .; then
        echo -e "${LIGHTYELLOW}Found existing stopped OpenGrok container ('${OPENGROK_CONTAINER_NAME}'). Removing it...${RESET}"
        if sudo docker rm "$OPENGROK_CONTAINER_NAME"; then
            echo -e "${GREEN}‚úî${GREY} Successfully removed existing container '${OPENGROK_CONTAINER_NAME}'.${RESET}"
        else
            echo -e "${RED}Error: Failed to remove existing container '${OPENGROK_CONTAINER_NAME}'.${RESET}"
            return 1
        fi
    fi

    # Pull the latest OpenGrok image
    echo -e "${LIGHTYELLOW}Checking for OpenGrok image (${OPENGROK_IMAGE_NAME})...${RESET}"
    if docker image inspect "$OPENGROK_IMAGE_NAME" &> /dev/null; then
        echo -e "${GREEN}‚úî${GREY} Image '${OPENGROK_IMAGE_NAME}' already exists locally.${RESET}"
    else
        echo -e "${LIGHTYELLOW}Pulling the latest OpenGrok image (${OPENGROK_IMAGE_NAME})...${RESET}"
        if ! docker pull "$OPENGROK_IMAGE_NAME"; then
            echo -e "${RED}Error: Failed to pull OpenGrok image '${OPENGROK_IMAGE_NAME}'.${RESET}"
            return 1
        fi
    fi
    echo -e "${GREEN}‚úî${GREY} Image '${OPENGROK_IMAGE_NAME}' pulled successfully.${RESET}"

    # Start the OpenGrok container
    echo -e "${LIGHTYELLOW}Starting OpenGrok container ('${OPENGROK_CONTAINER_NAME}')...${RESET}"
    local params=(
        run -d
        --name "$OPENGROK_CONTAINER_NAME"
        "--restart=unless-stopped"  # Restart the container automatically
        -e "NOMIRROR=yes"
        -p "127.0.0.1:${OPENGROK_HOST_PORT}:${OPENGROK_CONTAINER_PORT}/tcp" # Map host port to container port (localhost only)
        -v "${OPENGROK_SRC_VOLUME}:/opengrok/src:ro"  # Mount host source directory as read-only
        -v "${OPENGROK_DATA_VOLUME}:/opengrok/data"   # Use a named volume for OpenGrok data (indexes)
        -v "${OPENGROK_ETC_VOLUME}:/opengrok/etc"     # Use a named volume for OpenGrok configuration
        "$OPENGROK_IMAGE_NAME"
    )

    # The current user is in the 'docker' group
    echo -e "${GREY}Executing: docker ${params[*]}${RESET}"
    if docker "${params[@]}"; then
        echo -e "${GREEN}‚úî${GREY} OpenGrok container '${OPENGROK_CONTAINER_NAME}' started successfully.${RESET}"
        echo -e "${LIGHTYELLOW}It might take a few minutes for OpenGrok to initialize and index your source code from ${BOLD}$OPENGROK_SRC_VOLUME${LIGHTYELLOW}.${RESET}"
        echo -e "${LIGHTYELLOW}Once ready, access OpenGrok at: ${BOLD}http://localhost:${OPENGROK_HOST_PORT}${RESET}"
        echo -e "${LIGHTYELLOW}To view container logs: ${BLUE}docker logs -f ${OPENGROK_CONTAINER_NAME}${RESET}"
    else
        echo -e "${RED}Error: Failed to start OpenGrok container '${OPENGROK_CONTAINER_NAME}'.${RESET}"
        echo -e "${LIGHTYELLOW}Check container logs for details: ${BLUE}sudo docker logs ${OPENGROK_CONTAINER_NAME}${RESET}"
        return 1
    fi

    return 0
}

restartOpenGrokContainer() {
    stopOpenGrokContainer
    startOpenGrokContainer
}

addUserIntoLibvirtGrp() {
    echo -e "${COLOR}Configuring Libvirt Group Membership for Current User${RESET}"

    if ! getent group libvirt > /dev/null; then
        echo -e "${RED}Error: The 'libvirt' group does not exist.${RESET}"
        echo -e "${LIGHTYELLOW}This might indicate that 'libvirt-daemon-system' or similar packages are not installed or not installed correctly.${RESET}"
        echo -e "${LIGHTYELLOW}Please verify libvirt installation. Skipping group membership addition.${RESET}"
        return 1
    fi

    if id -nG "$USER" | grep -qw libvirt; then
        echo -e "${GREEN}‚úî${GREY} User '$USER' is already a member of the 'libvirt' group.${RESET}"
        printf "  "
        libvirtd --version
        return 0
    fi

    echo -e "${LIGHTYELLOW}Attempting to add user '$USER' to the 'libvirt' group...${RESET}"
    if sudo usermod -aG libvirt "$USER"; then
        echo -e "${GREEN}Successfully added user '$USER' to the 'libvirt' group.${RESET}"
        echo -e "${BOLD}${MAGENTA}IMPORTANT: You must log out and log back in, or open a new shell session (or run 'newgrp libvirt'), for this group membership change to take effect.${RESET}"
    else
        echo -e "${RED}Failed to add user '$USER' to the 'libvirt' group.${RESET}"
        echo -e "${LIGHTYELLOW}Please try adding the user manually: ${BLUE}sudo usermod -aG libvirt $USER${RESET}"
        return 1
    fi

    return 0
}

installSambaServer() {
    echo -e "${COLOR}Starting Samba Server Installation/Configuration${RESET}"
    # Step 1: Check if Samba is already installed
    if command -v smbd &> /dev/null; then
        echo -e "${GREEN}‚úî${GREY} Samba (smbd) is already installed.${RESET}"
    else
        echo -e "${LIGHTYELLOW}Samba (smbd) not found. Attempting installation...${RESET}"
        if ! sudo apt update; then
            echo -e "${RED}Error: Failed to update apt package list. Aborting Samba installation.${RESET}"
            return 1
        fi
        if ! sudo DEBIAN_FRONTEND=noninteractive apt install -y samba smbclient; then
            echo -e "${RED}Error: Failed to install Samba packages. Aborting.${RESET}"
            return 1
        fi
        echo -e "${GREEN}Samba installed successfully.${RESET}"
    fi

    # Step 2: Configure Samba
    local sambaSysConfFile="/etc/samba/smb.conf"
    local mySambaConfSource="$fMainDir/assets/samba/ubuntu.smb.conf"
    if [ ! -f "$mySambaConfSource" ]; then
        echo -e "${RED}Error: Source Samba configuration file ('smb.conf') not found at ${BLUE}$mySambaConfSource${RESET}"
        echo -e "${LIGHTYELLOW}This script expects a custom 'smb.conf' to be present in the assets.${RESET}"
        exit 1
    fi
    echo -e "${LIGHTYELLOW}Validating Samba configuration with 'testparm'...${RESET}"
    if testparm -s "$mySambaConfSource"; then
        echo -e "${GREEN}‚úî${GREY} Samba configuration appears valid.${RESET}"
    else
        echo -e "${RED}Error: Samba configuration validation failed (testparm reported errors).${RESET}"
        echo -e "${LIGHTYELLOW}Please review '${BLUE}$mySambaConfSource${LIGHTYELLOW}' and the output above.${RESET}"
        exit 1
    fi
    linkFile "$mySambaConfSource" /etc/samba smb.conf

    # Step 3: Configure Samba to use the current user
    local smbUser="$USER"
    local smbShareGroup=$(id -gn "$USER")

    if [ -z "$smbUser" ]  || [ -z "$smbShareGroup" ]; then
        echo -e "${RED}Error: Could not determine current user or their primary group. Aborting Samba setup.${RESET}"
        return 1
    fi

    echo -e "${LIGHTYELLOW}Samba will be configured for the current user: ${BOLD}$smbUser${RESET}"
    echo -e "${LIGHTYELLOW}The user's primary group will be used for file sharing: ${BOLD}$smbShareGroup${RESET}"

    # Set Samba password for the Samba user, who will be authenticating
    echo -e "${LIGHTYELLOW}Setting Samba password for user '${BOLD}$smbUser${LIGHTYELLOW}'...${RESET}"
    local sambaPassword=""
    local sambaPasswordConfirm=""
    local sambaPasswordFile="/etc/samba/smbpasswd"
    if [ ! -f "$sambaPasswordFile" ] || [ ! -s "$sambaPasswordFile" ] || [ "$fSambaServerFlag" == "2" ]; then # Reset password
        while true; do
            echo -en "${GREY}Enter new Samba password for user ${BOLD}$smbUser${LIGHTYELLOW} (must not be empty): ${RESET}"
            read -r -s sambaPassword
            echo
            if [ -z "$sambaPassword" ]; then
                echo -e "${RED}Password cannot be empty. Please try again.${RESET}"
                continue
            fi
            echo -en "${GREY}Confirm Samba password: ${RESET}"
            read -r -s sambaPasswordConfirm
            echo
            if [ "$sambaPassword" = "$sambaPasswordConfirm" ]; then
                break
            else
                echo -e "${RED}Passwords do not match. Please try again.${RESET}"
            fi
        done
        # Add/update the Samba user in Samba's database and set the password
        if (echo "$sambaPassword"; echo "$sambaPassword") | sudo smbpasswd -a "$smbUser" -s; then
            echo -e "${GREEN}‚úî${GREY} Samba password for user '$smbUser' set successfully.${RESET}"
        else
            echo -e "${RED}Error: Failed to set Samba password for user '$smbUser'.${RESET}"
            echo -e "${LIGHTYELLOW}Ensure '$smbUser' is a valid system user and you have sudo privileges.${RESET}"
            return 1
        fi
    fi

    # Step 4: Enable and start Samba services
    # local servicesToManage=("smbd" "nmbd")
    local servicesToManage=("smbd")
    local overallSuccess=true
    for service in "${servicesToManage[@]}"; do
        echo -e "${LIGHTYELLOW}Managing service: $service...${RESET}"
        if sudo systemctl restart "$service"; then
            echo -e "  ${GREEN}‚úî${GREY} $service restarted successfully.${RESET}"
        else
            echo -e "  ${RED}Error: Failed to restart $service.${RESET}"
            echo -e "  ${LIGHTYELLOW}Check with: sudo systemctl status $service && journalctl -xeu $service${RESET}"
            if [ "$service" == "smbd" ]; then
                overallSuccess=false;
            fi # Critical
        fi
        if sudo systemctl is-enabled "$service" | grep -q "enabled"; then
            echo -e "  ${GREEN}‚úî${GREY} $service is already enabled to start on boot.${RESET}"
        else
            if sudo systemctl enable "$service"; then
                echo -e "  ${GREEN}‚úî${GREY} $service enabled successfully for boot start.${RESET}"
            else
                echo -e "  ${RED}Error: Failed to enable $service for boot start.${RESET}"
                if [ "$service" == "smbd" ]; then
                    overallSuccess=false;
                fi # Critical
            fi
        fi
    done
    if [ "$overallSuccess" = false ]; then
        echo -e "${RED}Critical error managing Samba services. Aborting further Samba setup.${RESET}"
        exit 1
    fi

    # Step 5: Configuring Firewall (UFW)
    if command -v ufw &> /dev/null; then
        if sudo ufw status | grep -qw "Status: active"; then
            echo -e "${LIGHTYELLOW}UFW firewall is active. Checking/Adding rules for Samba...${RESET}"
            if sudo ufw status | grep -Ewq "Samba|ALLOW IN.*137,138/(udp|UDP)|ALLOW IN.*139,445/(tcp|TCP)"; then
                 echo -e "${GREEN}‚úî${GREY} UFW rule for 'Samba' or its specific ports already seems to exist or is allowed.${RESET}"
            else
                echo -e "${LIGHTYELLOW}Attempting to allow Samba through UFW (using 'samba' application profile)...${RESET}"
                if sudo ufw allow 445/tcp; then
                    echo -e "${GREEN}‚úî${GREY} UFW rule for Samba added successfully.${RESET}"
                    echo -e "${GREY}Current UFW status: ${RESET}"
                    sudo ufw status
                else
                    echo -e "${RED}Warning: Failed to add UFW rule for Samba using 'ufw allow samba'.${RESET}"
                    echo -e "${LIGHTYELLOW}You may need to manually allow TCP ports 445: sudo ufw allow 445/tcp${RESET}"
                fi
            fi
        else
            echo -e "${GREY}UFW firewall is installed but not active. Skipping UFW rule configuration.${RESET}"
        fi
    else
        echo -e "${GREY}UFW firewall manager not found. Skipping UFW configuration.${RESET}"
    fi

    # 6. Final message
    echo -e "\n${GREEN}--- Samba Server Installation/Configuration Process Completed ---${RESET}"
    echo -e "${LIGHTYELLOW}Summary:${RESET}"
    echo -e "  - Samba packages checked/installed."
    echo -e "  - Configuration '${BLUE}$sambaSysConfFile${RESET}' applied/validated."
    echo -e "  - Samba password set for user '${BOLD}$smbUser${RESET}'."
    echo -e "  - Services ${servicesToManage[*]} restarted and enabled."
    echo -e "  - Firewall rules for Samba (if UFW active) checked/added."
    echo -e "\n${BOLD}${LIGHTYELLOW}Next Steps & Testing:${RESET}"
    echo -e "  1. Ensure your share definitions in '$sambaSysConfFile' are correct for your needs."
    echo -e "  2. ${LIGHTYELLOW}Test connection from this machine: ${BLUE}smbclient -L localhost -U $smbUser${RESET}"
    echo -e "     (You will be prompted for the Samba password you just set)."
    echo -e "  3. Test from another client machine on the network using this server's IP address."
    echo -e "     - ${BOLD}On Linux/macOS:${RESET}"
    echo -e "       - Example (list shares): ${BLUE}smbclient --list //SERVER_IP_ADDRESS -U $smbUser${RESET}"
    echo -e "       - Example (connect to a share): ${BLUE}smbclient //SERVER_IP_ADDRESS/sharename -U $smbUser${RESET}"
    echo -e "     - ${BOLD}On Windows:${RESET}"
    echo -e "       - In File Explorer, type ${BLUE}\\\\\\SERVER_IP_ADDRESS${RESET} in the address bar."
    echo -e "       - When prompted, use username '${BOLD}$smbUser${RESET}' and the password you set."
    echo -e "     Or map a network drive via your client OS's file explorer."
    echo -e "  4. Remember to change the ownership of the share directory to '${BOLD}$smbUser${RESET}'."
    echo -e "     You can do this using the '${BLUE}chown -R $smbUser:$smbShareGroup /path/to/share/directory${RESET}' command."
    echo -e "${GREY}If issues arise, check Samba logs (e.g., 'journalctl -u smbd -u nmbd', '/var/log/samba/log.<client_hostname_or_ip>') and 'sudo smbstatus'.${RESET}"

    return 0
}

addSwap() {
    # Default swap size is 8G
    local swapSize=${1:-8G}

    # Use regex to parse size and unit, only matching integers
    # ([0-9]+) matches one or more digits (integer part)
    # ([KMGTP]B?|[kMGTp]b?)? matches K, M, G, T, P or kB, MB, GB, TB, PB (case-insensitive and optional)
    local regex="^([0-9]+)([KkMmGgTtPp]B?)?$"

    # Try to match the input
    if [[ "$swapSize" =~ $regex ]]; then
        local num=${BASH_REMATCH[1]}    # Integer number part
        local unit=${BASH_REMATCH[2]}    # Unit part (can be empty)
        # Convert unit to uppercase and remove optional 'B' for unified handling
        local unit_upper=$(echo "$unit" | tr '[:lower:]' '[:upper:]' | sed 's/B$//')

        # echo -e "${LIGHTYELLOW}Swap size parsed: ${num}${unit_upper}${RESET}"
    else
        # Exit if the format is invalid or contains decimals
        echo -e "${RED}Invalid swap size format: ${swapSize}. Please use an integer followed by an optional unit (e.g., '8G', '4096M', or '8192').${RESET}"
        return 1
    fi

    echo -e "${COLOR}Adding Swap File of size ${num}${unit_upper}${RESET}"

    # ----------------------------------------------------
    # Check if ANY swap is already active
    # swapon --show outputs a header line, so we check if there is more than one line of output.
    # The 'tail -n +2' command skips the header line, and we check if any content remains.
    # ----------------------------------------------------
    if swapon --show | tail -n +2 | grep -q '.*'; then
        echo -e "${GREEN}‚úî${GREY} At least one swap area is already active.${RESET}"
        swapon --show
        return 0
    fi

    # Create or enable the Swap
    if [ -f /swapfile ]; then
        echo -e "${LIGHTYELLOW}/swapfile exists but not active. Enabling it...${RESET}"
    else
        echo -e "${LIGHTYELLOW}Creating swap file of size $swapSize...${RESET}"

        # Prefer fallocate, as it directly supports size strings with units
        # Suppress standard error output of fallocate in case of failure
        if ! sudo fallocate -l "$swapSize" /swapfile 2>/dev/null; then
            echo -e "${RED}fallocate failed. Trying dd fallback...${RESET}"

            # Fallback to dd command
            # dd requires an integer count and a bs (block size)

            local bs_val
            case "$unit_upper" in
                "K") bs_val="1K" ;;
                "M") bs_val="1M" ;;
                "G") bs_val="1G" ;;
                "T") bs_val="1T" ;;
                "")
                     # If no unit is provided (e.g., 8192), assume 'M' unit and set bs to 1M
                     echo -e "${LIGHTYELLOW}No unit provided. Assuming 'M' unit for dd fallback.${RESET}"
                     bs_val="1M"
                     ;;
                *)
                     # Should not happen if regex is correct, but safe check for dd
                     echo -e "${RED}Unsupported unit '$unit_upper' for dd fallback (Use K, M, G, or T).${RESET}"
                     return 1
                     ;;
            esac

            echo -e "${LIGHTYELLOW}dd command: sudo dd if=/dev/zero of=/swapfile bs=${bs_val} count=${num} status=progress${RESET}"
            if ! sudo dd if=/dev/zero of=/swapfile bs="$bs_val" count="$num" status=progress; then
                echo -e "${RED}dd failed.${RESET}"
                return 1
            fi
        fi

        # Set correct permissions and format the swap file
        sudo chmod 600 /swapfile
        sudo mkswap /swapfile
    fi

    # Activate the swap file
    sudo swapon /swapfile
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Swap enabled successfully.${RESET}"
        # Add to fstab for persistence across reboots
        if ! grep -q "^/swapfile" /etc/fstab; then
            echo -e "${GREY}Adding /swapfile to /etc/fstab${RESET}"
            echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab
        fi
    else
        echo -e "${RED}Failed to enable swap.${RESET}"
        exit 1
    fi
    free -h
}

installLatestPPaWireshark() {
    echo -e "${COLOR}Checking for Wireshark (Wireshark PPA)${RESET}"

    if [ -z "$fWiresharkForce" ] && command -v wireshark &>/dev/null; then
        local wiresharkPolicy
        wiresharkPolicy=$(apt-cache policy wireshark)
        if echo "$wiresharkPolicy" | grep -q "wireshark-dev/stable"; then
            local installedVersion candidateVersion
            installedVersion=$(echo "$wiresharkPolicy" | grep "Installed:" | awk '{print $2}')
            candidateVersion=$(echo "$wiresharkPolicy" | grep "Candidate:" | awk '{print $2}')
            if [ "$installedVersion" != "(none)" ] && [ "$installedVersion" == "$candidateVersion" ]; then
                echo -e "${GREEN}‚úî${GREY} Wireshark (from PPA) is already installed and up-to-date.${RESET}"
                printf "  "
                wireshark --version | head -n 1
                return 0
            fi
        fi
    fi

    # 1. Add the Wireshark PPA repository
    if grep -qr "wireshark-dev/stable" /etc/apt/sources.list /etc/apt/sources.list.d/ 2>/dev/null; then
        echo -e "${GREEN}‚úî${GREY} Wireshark PPA already configured.${RESET}"
    else
        echo -e "${LIGHTYELLOW}Adding the Wireshark PPA...${RESET}"
        if ! sudo add-apt-repository -y ppa:wireshark-dev/stable; then
            echo -e "${RED}Error: Failed to add Wireshark PPA. Aborting.${RESET}"
            return 1
        fi
        echo -e "${GREEN}Wireshark PPA added successfully.${RESET}"
    fi

    # 2. Create the preference file to prioritize PPA Wireshark
    local preferenceFilePath="/etc/apt/preferences.d/wireshark-ppa-priority"
    # The 'o' value can be found with 'apt-cache policy wireshark' -> 'LP-PPA-wireshark-dev-stable'
    local preferenceContent
    preferenceContent=$(cat <<'EOF'
Package: *
Pin: release o=LP-PPA-wireshark-dev-stable
Pin-Priority: 1001

Package: wireshark*
Pin: release o=Ubuntu*
Pin-Priority: -1
EOF
)
    echo -e "${LIGHTYELLOW}Setting up APT preferences to prioritize Wireshark PPA...${RESET}"
    if [ -f "$preferenceFilePath" ] && cmp -s <(echo "$preferenceContent") "$preferenceFilePath"; then
        echo -e "${GREY}APT preference file '$preferenceFilePath' already exists and is correctly configured.${RESET}"
    else
        echo "$preferenceContent" | sudo tee "$preferenceFilePath" > /dev/null
        if [ $? -eq 0 ]; then
            echo -e "${GREEN}APT preference file '$preferenceFilePath' created/updated successfully.${RESET}"
        else
            echo -e "${RED}Failed to create/update APT preference file '$preferenceFilePath'. Aborting.${RESET}"
            return 1
        fi
    fi

    # 3. Update package list
    echo -e "${LIGHTYELLOW}Updating package lists...${RESET}"
    if ! sudo apt update; then
        echo -e "${RED}Error: Failed to update apt package list. Aborting.${RESET}"
        return 1
    fi

    # 4. Pre-configure wireshark-common to allow non-root users to capture packets.
    # This avoids the interactive prompt during installation.
    echo -e "${LIGHTYELLOW}Pre-configuring wireshark-common to allow non-root packet capture...${RESET}"
    if ! echo "wireshark-common wireshark-common/install-setuid boolean true" | sudo debconf-set-selections; then
        echo -e "${RED}Warning: Failed to pre-configure wireshark-common via debconf. The installation might prompt for input.${RESET}"
    fi

    # 5. Install Wireshark
    echo -e "${LIGHTYELLOW}Installing Wireshark...${RESET}"
    if ! sudo DEBIAN_FRONTEND=noninteractive apt install -y wireshark; then
        echo -e "${RED}Error: Failed to install Wireshark. Aborting.${RESET}"
        return 1
    fi
    echo -e "${GREEN}Wireshark installed successfully.${RESET}"

    # 6. Add user to the 'wireshark' group
    if ! getent group wireshark > /dev/null; then
        echo -e "${RED}Error: The 'wireshark' group was not created by the installation. Manual configuration may be needed.${RESET}"
    elif id -nG "$USER" | grep -qw wireshark; then
        echo -e "${GREEN}‚úî${GREY} User '$USER' is already a member of the 'wireshark' group.${RESET}"
    else
        echo -e "${LIGHTYELLOW}Adding current user '$USER' to the 'wireshark' group...${RESET}"
        if sudo usermod -aG wireshark "$USER"; then
            echo -e "${GREEN}Successfully added user '$USER' to the 'wireshark' group.${RESET}"
        else
            echo -e "${RED}Error: Failed to add user '$USER' to the 'wireshark' group.${RESET}"
            return 1
        fi
    fi

    # 7. Final message
    echo -e "\n${BOLD}${MAGENTA}IMPORTANT: You must run 'newgrp wireshark' or you have to log out and log back in, for group changes to take effect.${RESET}"
    echo -e "${LIGHTYELLOW}This will allow you to capture network traffic as a non-root user.${RESET}"
    wireshark --version
    return 0
}

configureTcpdumpCaps() {
    echo -e "${COLOR}Configuring tcpdump for Non-root User Packet Capture${RESET}"

    # Check for required tools first
    if ! command -v tcpdump &> /dev/null; then
        echo -e "${LIGHTYELLOW}Warning: tcpdump command not found. Skipping configuration.${RESET}"
        echo -e "${GREY}Please install it via 'sudo apt install tcpdump' and re-run.${RESET}"
        return 1
    fi
    # `setcap` is a utility for setting file capabilities. By granting the 'cap_net_raw'
    # and 'cap_net_admin' capabilities to the tcpdump binary, we allow non-root users
    # to capture packets without needing full sudo privileges. This is more secure
    # than making tcpdump setuid root. The `libcap2-bin` package provides `setcap`.
    if ! command -v setcap &> /dev/null || ! command -v getcap &> /dev/null; then
        echo -e "${RED}Error: 'setcap' or 'getcap' command not found.${RESET}"
        echo -e "${LIGHTYELLOW}Please install the required package (e.g., 'sudo apt install libcap2-bin') and re-run.${RESET}"
        return 1
    fi

    local tcpdumpPath
    tcpdumpPath=$(command -v tcpdump)
    local requiredCaps="cap_net_admin,cap_net_raw+eip"
    local currentCaps
    currentCaps=$(getcap "$tcpdumpPath" 2>/dev/null)

    # Check if the capabilities are already set
    if [[ "$currentCaps" == *"cap_net_admin,cap_net_raw"* ]]; then
        echo -e "${GREEN}‚úî${GREY} tcpdump already has the required capabilities for non-root capture.${RESET}"
        printf "  "
        tcpdump --version 2>&1 | head -n 1
        return 0
    fi

    # Check if the filesystem supports extended attributes (required for setcap)
    local tcpdumpDir
    tcpdumpDir=$(dirname "$tcpdumpPath")
    local fsType
    fsType=$(df -T "$tcpdumpDir" 2>/dev/null | awk 'NR==2 {print $2}')
    if [[ "$fsType" == "nfs"* ]] || [[ "$fsType" == "cifs" ]] || [[ "$fsType" == "smbfs" ]]; then
        echo -e "${LIGHTYELLOW}‚ö† Skipping: tcpdump is on a ${fsType} filesystem which doesn't support capabilities.${RESET}"
        echo -e "${GREY}  Use 'sudo tcpdump' for packet capture on this system.${RESET}"
        return 0
    fi

    echo -e "${LIGHTYELLOW}Attempting to set network capture capabilities on the tcpdump binary...${RESET}"
    echo -e "${GREY}Executing: sudo setcap '$requiredCaps' '$tcpdumpPath'${RESET}"
    if sudo setcap "$requiredCaps" "$tcpdumpPath"; then
        echo -e "${GREEN}Successfully set capabilities on '$tcpdumpPath'.${RESET}"
        echo -e "${LIGHTYELLOW}Normal users should now be able to run tcpdump for packet capture.${RESET}"
    else
        echo -e "${LIGHTYELLOW}‚ö† Could not set capabilities on tcpdump binary.${RESET}"
        echo -e "${GREY}  This may be due to filesystem limitations, AppArmor, or SELinux.${RESET}"
        echo -e "${GREY}  Use 'sudo tcpdump' for packet capture on this system.${RESET}"
        return 0
    fi

    return 0
}

installNvmNodeJs() {
    echo -e "${COLOR}Installing NVM (Node Version Manager) and Node.js via official script${RESET}"
    local nvmDir="$HOME/.nvm"
    local nvmSh="$nvmDir/nvm.sh"
    if [ -z "$fNVMForce" ] && [ -s "$nvmSh" ]; then
        echo -e "${GREEN}‚úî${GREY} NVM is already installed in ${BLUE}$nvmDir${RESET}"
        # shellcheck disable=SC1090
        source "$nvmSh"
        printf "  " && nvm --version
        # Link current Node.js version
        [ -n "$(nvm which current 2>/dev/null)" ] && linkFile "$(nvm which current)" "$HOME/.usr/bin" "node"
        return 0
    else
        local nvmVersion="v0.40.3"
        # Remove conflicting system packages if they exist to avoid conflicts.
        echo -e "${LIGHTYELLOW}Checking and removing system-installed Node.js/npm...${RESET}"
        removeInstalledPackages nodejs npm
        # Download and run the NVM installation script
        # The script will also update .bashrc if necessary
        if ! curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/"$nvmVersion"/install.sh | bash; then
            echo -e "${RED}Error: Failed to install NVM. Aborting Node.js setup.${RESET}"
            return 1
        fi
        echo -e "${GREEN}NVM installed successfully.${RESET}"
    fi

    # Source the NVM script to make the 'nvm' command available in this shell session
    if [ -s "$nvmSh" ]; then
        export NVM_DIR="$nvmDir"
        # shellcheck disable=SC1090
        source "$nvmSh"
    else
        echo -e "${RED}Error: nvm.sh script not found after installation. Cannot proceed.${RESET}"
        return 1
    fi

    # Install the latest LTS (Long-Term Support) version of Node.js.
    # `nvm install --lts` is idempotent; it will install if not present or
    # do nothing if the latest LTS version is already installed.
    echo -e "${LIGHTYELLOW}Installing/Updating to the latest LTS version of Node.js via NVM...${RESET}"
    if ! nvm install --lts; then
        echo -e "${RED}Error: Failed to install Node.js LTS version using NVM.${RESET}"
        return 1
    fi
    echo -e "${GREEN}Successfully installed/verified Node.js LTS version.${RESET}"
    # Set this version as the default for new shell sessions
    echo -e "${LIGHTYELLOW}Setting/updating default Node.js alias to the latest LTS...${RESET}"
    nvm alias default lts/*
    echo -e "${GREEN}‚úî${GREY} Default Node.js version set to the latest LTS.${RESET}"
    echo -e "${GREEN}‚úî${GREY} Current version in use: $(nvm current)${RESET}"
    echo -e "\n${CYAN}IMPORTANT: NVM has been configured. To use it in a new terminal, you may need to RE-LOGIN or RESTART your terminal.${RESET}"
    echo -e "${LIGHTYELLOW}To use it in this current shell session immediately, run: ${BLUE}source ~/.nvm/nvm.sh${RESET}"

    [ -n "$(nvm which current 2>/dev/null)" ] && linkFile "$(nvm which current)" "$HOME/.usr/bin" "node"
    return 0
}

# https://claudiuconstantinbogdan.me/articles/litellm-vertexai-continuedev
startLiteLLMService() {
    echo -e "${COLOR}Installing/Configuring LiteLLM Proxy Server via Docker Compose${RESET}"
    if ! command -v docker &> /dev/null || ! docker compose version &> /dev/null; then
        echo -e "${RED}Error: Docker and Docker Compose are required.${RESET}"; return 1;
    fi

    local liteLLMComposeFile="$LITELLM_DIR/docker-compose.yml"
    if [ ! -d "$LITELLM_DIR/.git" ]; then
        echo -e "${LIGHTYELLOW}Cloning the LiteLLM repository from GitHub...${RESET}"
        # The directory may exist from a previous failed run or other reasons.
        # Remove it to ensure a clean clone.
        rm -rf "$LITELLM_DIR"
        if ! git clone https://github.com/BerriAI/litellm "$LITELLM_DIR"; then
            echo -e "${RED}Failed to clone the litellm repository from GitHub.${RESET}"
            return 1
        fi
    else
        echo -e "${GREEN}‚úî${GREY} LiteLLM repository already exists in $LITELLM_DIR.${RESET}"
    fi
    if [ ! -f "$liteLLMComposeFile" ]; then
        echo -e "${RED}Error: docker-compose.yml not found in the cloned repository at $LITELLM_DIR.${RESET}"
        return 1
    fi

    local envFile="$LITELLM_DIR/.env"
    local masterKey
    local saltKey
    if [ ! -f "$envFile" ]; then
        echo -e "${LIGHTYELLOW}Creating LiteLLM .env file for environment variables...${RESET}"
        while true; do
            read -r -s -p "Enter LiteLLM Master Key (e.g., sk-1234): " masterKey
            if [ -z "$masterKey" ]; then
                echo -e "${RED}Master Key cannot be empty. Please try again.${RESET}"
            else
                break
            fi
        done

        # Auto-generate a random salt key
        echo -e "${LIGHTYELLOW}Auto generating Salt Key...${RESET}"
        saltKey=$(head /dev/urandom | tr -dc A-Za-z0-9 | head -c 32)
        echo -e "${GREEN}Generated Salt Key: ${BOLD}$saltKey${RESET}"
        {
            echo "LITELLM_MASTER_KEY=$masterKey"
            echo "LITELLM_SALT_KEY=$saltKey"
        } > "$envFile"
        echo -e "${GREEN}‚úî${GREY} LiteLLM .env file created at ${BLUE}$envFile${RESET}"
    else
        echo -e "${GREEN}‚úî${GREY} LiteLLM .env file already exists at ${BLUE}$envFile${GREY}, skipping creation.${RESET}"
    fi

    echo -e "${LIGHTYELLOW}Starting LiteLLM proxy...${RESET}"
    if ! (cd "$LITELLM_DIR" && docker compose up -d); then
        echo -e "${RED}Failed to start LiteLLM. Check logs with: cd $LITELLM_DIR && docker compose logs${RESET}"
        return 1
    fi

    echo -e "\n${GREEN}--- LiteLLM proxy started successfully! ---${RESET}"
    echo -e "  - ${BOLD}Access:${RESET}   ${MAGENTA}http://localhost:4000${RESET}"
    echo -e "  - ${BOLD}Manage:${RESET}   Run commands from ${BLUE}$LITELLM_DIR${RESET}"
    echo -e "    - ${GREY}Start/Update: docker compose up -d${RESET}"
    echo -e "    - ${GREY}Stop:         docker compose down${RESET}"
    echo -e "    - ${GREY}Logs:         docker compose logs -f${RESET}"
    echo -e "  - ${BOLD}Investigate:${RESET}   Run commands from ${BLUE}Anywhere${RESET}"
    echo -e "    - ${GREY}Network:      docker network ls${RESET}"
    echo -e "    - ${GREY}Volumes:      docker volume ls${RESET}"
    return 0
}

stopLiteLLMService() {
    echo -e "${LIGHTYELLOW}Stopping LiteLLM Proxy...${RESET}"
    if ! (cd "$LITELLM_DIR" && docker compose down); then
        echo -e "${RED}Failed to stop LiteLLM. Check logs with: cd $LITELLM_DIR && docker compose logs${RESET}"
        return 1
    fi
    echo -e "${GREEN}‚úî${GREY} LiteLLM proxy stopped.${RESET}"
    return 0
}

restartLiteLLMService() {
    stopLiteLLMService
    startLiteLLMService
}

doCoreJobs() {
    ubuntuInstallApps          # Install apps for Ubuntu
    createTKSymlinks           # Create Tracked Files symlinks
    installVimPluginsManager   # Install Vim Plugins Manager
    installTmuxPluginsManager  # Install Tmux Plugins Manager
    createToolsSymlinks        # Create tool symlinks
    relinkSysCmds              # Relink system commands
    createExtraSymlinks        # Create extra symlinks
    buildBatTheme              # Build bat theme
    buildExtraFonts            # Build extra fonts
    addUserIntoLibvirtGrp      # Add user into libvirt group
    installNvmNodeJs           # Install NVM and Node.js
    installLatestGitLfs        # Install Git LFS (PackageCloud)
    installLatestRimePinyin    # Install Rime Pinyin input method
    installLatestPPaFirefox    # Install Firefox (Mozilla PPA)
    installLatestPPaDocker     # Install Docker
    installLatestPPaWireshark  # Install Wireshark (Mozilla PPA)
    configureTcpdumpCaps       # Configure tcpdump for non-root user packet capture
    installLatestGithubClangd  # Install Github Clangd
    stopUnnecessaryServices    # Stop unnecessary services
}

doEarlyExitJobs() {
    [ -n "$fLinkClangFormatPath" ] && { linkClangFormat "$1"; exit 0; }
    [ -n "$fCheckTlsConn" ]        && { checkTlsConnection "$1"; exit 0; }
    [ -n "$fSambaServerFlag" ]     && { installSambaServer; exit 0; }
    [ -n "$fSwapReq" ]             && { addSwap "$1"; exit 0; }
    [ -n  "$fVncLockAction" ]      && { vncLock "$fVncLockAction"; exit 0; }
    case "$fVncServer" in
        1) startVncServer;       exit 0 ;;
        2) stopVncServer;        exit 0 ;;
        3) restartVncServer;     exit 0 ;;
    esac
    case "$fOpenGrokContainer" in
        1) startOpenGrokContainer;   exit 0 ;;
        2) stopOpenGrokContainer;    exit 0 ;;
        3) restartOpenGrokContainer; exit 0 ;;
        4) startOpenGrokIndexer;     exit 0 ;;
    esac
    case "$fLiteLLMService" in
        1) startLiteLLMService;   exit 0 ;;
        2) stopLiteLLMService;    exit 0 ;;
        3) restartLiteLLMService; exit 0 ;;
    esac
}

showUfwStatus() {
    # UFW is Linux-specific, skip on macOS
    if [[ $(uname -s) == 'Darwin' ]]; then
        return
    fi

    if ! command -v ufw &> /dev/null || sudo ufw status | grep -qw "Status: inactive"; then
        return
    fi
    echo -e "${COLOR}Checking UFW Firewall Status${RESET}"
    sudo ufw status verbose
    echo -e "${LIGHTYELLOW}Tip: Common UFW commands:${RESET}"
    echo -e "  ${GREY}- sudo ufw status        : Check if the firewall is active.${RESET}"
    echo -e "  ${GREY}- sudo ufw enable        : Enable the firewall.${RESET}"
    echo -e "  ${GREY}- sudo ufw disable       : Disable the firewall.${RESET}"
    echo -e "  ${GREY}- sudo ufw allow <port>  : Allow traffic on a specific port (e.g., sudo ufw allow 445/tcp).${RESET}"
    echo -e "  ${GREY}- sudo ufw deny <port>   : Deny traffic on a specific port.${RESET}"
    echo -e "  ${GREY}- sudo ufw delete allow <port>: Delete an allow rule (e.g., sudo ufw delete allow 445/tcp).\n${RESET}"
}

main() {
    doEarlyExitJobs "$1"
    checkOSAndArch
    checkTlsConnection
    createEssentialPaths
    if [ "$fOSCategory" == "debian" ]; then
        doCoreJobs
        changeTMOUTToWritable
        setTimeZone
        createFirstTimeFile
    elif [ "$fOSCategory" == "mac" ]; then
        macInstallApps
        createTKSymlinks
        createMacOSBashProfile
        setMacOSDefaultShell
        installTmuxPluginsManager
        installVimPluginsManager
        createToolsSymlinks
        createExtraSymlinks
        buildBatTheme
        buildExtraFonts
    fi
    showUfwStatus
}

main "$@"
