#!/bin/bash
# shellcheck disable=SC2155 disable=SC2120
# set -x

# Tracking directories
fMainDir=$(cd "$(dirname "$(readlink -f "$0")")" || exit; pwd)
fTKFilesDir=$fMainDir/track-files
fTKCompDir=$fMainDir/completion
fTKVimColorsDir=$fMainDir/assets/vim-colors
fTKBatThemeDir=$fMainDir/assets/bat-themes
fTKFontDir=$fMainDir/assets/fonts
fTKFontConfigDir=$fMainDir/assets/fontconfig
fTKClangdConfig=$fMainDir/assets/clangd/config.yaml
fTKtemplateDir=$fMainDir/template
fTKToolsDir=$fMainDir/ftnt-tools
fDownloads=$HOME/Downloads
fJCPath=$fMainDir/jc
fFirstTimeFile=$fMainDir/".has_been_invoked"
fUpdateClangd=
fUpdateDocker=
fLinkClangFormatPath=
fLinkNodeJs=
fTlsInsecure=
fRimePinyinInputMethod=
# Misc
fVimPlugsManagerPath=$HOME/.vim/autoload/plug.vim
fzfBinPath=$HOME/.vim/bundle/fzf/bin/fzf
# A fzf plugin: fzf-tab-completion
fzfTabCompPath=$HOME/.vim/bundle/fzf-tab-completion/bash/fzf-bash-completion.sh
fBackupDir="$HOME/Public/env.bak"
fOSCategory=debian # ubuntu/debian is the default OS type
fArch=
fNoInstallTools=
# VNC server
fVncSimplePort=9
fVncRealPort="590${fVncSimplePort}"
fVncResolution=2060x1080
fVncServer= # 1: start VNC server; 2: kill VNC server 3: restart VNC server
# Docker container: OpenGrok
fOpenGrokContainer= # 1: start container; 2: stop container 3: restart container 4: start indexer
OPENGROK_IMAGE_NAME="opengrok/docker:latest" # You can pin to a specific version, e.g., opengrok/docker:1.7.30
OPENGROK_CONTAINER_NAME="opengrok"
OPENGROK_SRC_VOLUME="$HOME/.usr/local/opengrok/src" # User puts source code here on the host
OPENGROK_DATA_VOLUME="$HOME/.usr/local/opengrok/data" # Docker named volume for OpenGrok data/indexes
OPENGROK_ETC_VOLUME="$HOME/.usr/local/opengrok/etc"   # Docker named volume for OpenGrok configuration
OPENGROK_HOST_PORT="8080"
OPENGROK_CONTAINER_PORT="8080"
# Samba Server
fSambaServer= # 1: Start samba server; 2: Start samba server without setting password
# Deb Firefox
fInstallDebFirefox=
# Force options
fForceInstallPrerequisites=
fForceChinesePinyin=
# Constants
SCRIPT_NAME=$(basename $0)
# Colors
RED='\033[31m'
GREEN='\033[32m'
MAGENTA='\033[35m'
LIGHTYELLOW='\033[93m'
BOLD='\033[1m'
BLUE='\033[34m'
GREY='\033[90m'
CYAN='\033[36m'
RESET='\033[0m'
COLOR=$MAGENTA

usage() {
    cat << _EOF
Usage: $SCRIPT_NAME [OPTIONS]

This script is used to set up the coding environment in my predefined way.

Options:
    -h, --help                      Print this help message
    -n, --no-tools                  Don't install tools
    -d, --debug                     Enable debug mode
    --insecure                      Allow insecure TLS
    --docker                        Update Docker
    --clangd                        Update clangd to the latest released version
    --firefox-deb                   Install deb version of Firefox
    --link-clang-format             Link clang-format to current path
    --link-nodejs                   Link nodejs from VsCode Server to current path
    --vnc-start                     Start VNC server
    --vnc-stop                      Stop VNC server
    --vnc,--vnc-restart             Restart VNC server
    --unlock-vnc                    Unlock VNC
    --lock-vnc                      Lock VNC
    --chinese-pinyin                Install Rime Pinyin
    --opengrok-start                Start OpenGrok Docker container
    --opengrok-stop                 Stop OpenGrok Docker container
    --opengrok,--opengrok-restart   Restart OpenGrok Docker container
    --opengrok-indexer              Start OpenGrok indexer
    --samba                         Install and configure Samba Server
    --samba-bypass-password         Don't set password for Samba Server again
    --auto-remove                   Remove unused packages
    --update                        Update all packages
    --upgrade                       Upgrade all packages

Force options:
    --prerequisite           Force install prerequisites
    --chinese-pinyin-force   Force install Rime Pinyin

Examples:
    $SCRIPT_NAME -h
    $SCRIPT_NAME --link-clang-format \$HOME/crosslv

_EOF
exit 0
}

SHORTOPTS="hdnf"
LONGOPTS="help,debug,no-tools,clangd,docker,link-clang-format::,link-nodejs,auto-remove,\
          upgrade,insecure,chinese-pinyin,prerequisite,chinese-pinyin-force,vnc-restart,\
          vnc-stop,unlock-vnc,lock-vnc,vnc-start,vnc,firefox-deb,update,opengrok,opengrok-start,\
          opengrok-stop,opengrok-restart,opengrok-indexer,samba,samba-bypass-password"

# Use getopt to parse command-line options
if ! PARSED=$(getopt --options $SHORTOPTS --longoptions "$LONGOPTS" --name "$0" -- "$@"); then
    echo -e "${COLOR}Error: Failed to parse command-line options.${RESET}" >&2
    exit 1
fi

# Reset positional parameters to the parsed values
eval set -- "$PARSED"

while true; do
    case "$1" in
        -n|--no-tools)
            fNoInstallTools=true
            shift
            ;;
        --prerequisite)
            fForceInstallPrerequisites=true
            shift
            ;;
        --docker)
            fUpdateDocker=true
            shift
            ;;
        --insecure)
            fTlsInsecure="--insecure"
            shift
            ;;
        --clangd)
            fUpdateClangd=true
            shift
            ;;
        --firefox-deb)
            fInstallDebFirefox=true
            shift
            ;;
        --opengrok-start)
            fOpenGrokContainer=1
            shift
            ;;
        --opengrok-stop)
            fOpenGrokContainer=2
            shift
            ;;
        --opengrok|--opengrok-restart)
            fOpenGrokContainer=3
            shift
            ;;
        --opengrok-indexer)
            fOpenGrokContainer=4
            shift
            ;;
        --samba)
            fSambaServer=1
            shift
            ;;
        --samba-bypass-password)
            fSambaServer=2
            shift
            ;;
        --vnc-start)
            fVncServer=1
            shift
            ;;
        --vnc-stop)
            fVncServer=2
            shift
            ;;
        --vnc|--vnc-restart)
            fVncServer=3
            shift
            ;;
        --unlock-vnc)
            set -x
            loginctl unlock-session
            exit 0
            ;;
        --lock-vnc)
            set -x
            loginctl lock-session
            exit 0
            ;;
        --chinese-pinyin)
            fRimePinyinInputMethod=true
            shift
            ;;
        --chinese-pinyin-force)
            fRimePinyinInputMethod=true
            fForceChinesePinyin=true
            shift
            ;;
        --link-clang-format)
            # $1 is '--link-clang-format'
            # $2 is an empty string '' no matter whether it has an argument
            # The argument if provided will be put in sequence in the positional parameters
            # Exp: $ jc huhu --link-clang-format ~/ he
            #          --link-clang-format '' -- 'huhu' '/home/user1/' 'he'
            # CRITICAL: Always shift 2 to consume both the option token ($1)
            # and its argument/empty placeholder token ($2).
            fLinkClangFormatPath="$PWD"
            shift 2
            ;;
        --link-nodejs)
            fLinkNodeJs=true
            shift
            ;;
        --auto-remove)
            echo -e "${COLOR}Removing unused packages${RESET}"
            sudo apt autoremove -y
            shift
            exit 0
            ;;
        --update)
            echo -e "${COLOR}Updating all packages${RESET}"
            sudo apt update -y
            shift
            exit 0
            ;;
        --upgrade)
            echo -e "${COLOR}Upgrading all packages${RESET}"
            sudo apt upgrade -y
            shift
            exit 0
            ;;
        -d|--debug)
            set -x
            echo -e "${COLOR}Debug mode enabled${RESET}"
            shift
            ;;
        -h|--help)
            usage
            ;;
        --)
            shift
            break
            ;;
        *)
            echo -e "${RED}Error: Invalid option: $1${RESET}" >&2
            exit 1
            ;;
    esac
done

checkSudoPrivilege() {
    echo -e "${COLOR}Checking sudo privilege${RESET}"
    # Check if the user can run sudo without a password
    if sudo -n true 2>/dev/null; then
        echo "User likely has passwordless sudo access."
    else
        echo "User likely does not have passwordless sudo access or needs a password."
        exit 0
    fi
}

checkOSCategory() {
    echo -e "${COLOR}Checking OS platform${RESET}"
    if [[ -f /etc/os-release ]]; then
        local osName
        osName=$(awk -F= '/^ID=/{print $2}' /etc/os-release)
        fArch=$(uname -m)

        case "$osName" in
            "ubuntu")
                fOSCategory=debian
                echo -e "The current OS type is ${LIGHTYELLOW}Ubuntu${RESET}. Arch: ${LIGHTYELLOW}$fArch${RESET}"
                ;;
            "centos")
                fOSCategory=redhat
                echo "The current OS type is CentOS. Arch: $fArch"
                echo "We currently do not support CentOS."
                exit
                ;;
            "raspbian")
                fOSCategory=debian
                echo "The current OS type is raspbian. Arch: $fArch"
                ;;
            *)
                echo "We currently do not support this OS type."
                exit
                ;;
        esac
    elif [[ $(uname) == "Darwin" ]]; then
        fOSCategory=mac
        echo "The current OS type is macOS (Mac)."
    else
        echo "The OS type is not supported or could not be determined."
        echo "We currently do not support this OS type."
        exit 1
    fi
}

updatePrerequisitesForDebian() {
    [ ! -f "$fFirstTimeFile" ] && fForceInstallPrerequisites=true
    [ -z "$fForceInstallPrerequisites" ] && return
    echo -e "${COLOR}Updating prerequisites for Ubuntu${RESET}"

    checkSudoPrivilege
    prerequisitesForUbuntu=(
        opencc # Simplified Chinese
        tmux # Basic tools
        rsync
        fd-find # fd
        ripgrep # rg
        universal-ctags
        openssl
        libssl-dev
        gdb
        bat
        curl
        firefox
        # Recommended Chinese fonts for good character display
        fonts-noto-cjk
        fonts-wqy-microhei
        fonts-wqy-zenhei
        jq # JSON parser
        xsel # X11 clipboard
        xclip
        libcurl4
        libcurl4-openssl-dev
        dos2unix
        expect
        sshfs
        sshpass
        shellcheck
        net-tools
        nftables
        bash-completion
        openssh-server
        python3-dev
        ffmpeg
        nodejs # Node.js
        npm
        build-essential # build essentials
        cmake
        libboost-all-dev
        gnupg
        lsb-release
        ragel
        sqlite3
        libsqlite3-dev
        libpcap-dev
        libvirt-daemon-system # libvirt
        libvirt-clients
        virt-manager
        qemu-kvm
        qemu-utils
        texinfo
        libisl-dev
        libgmp-dev
        libncurses-dev
        source-highlight
        libsource-highlight-dev
        libmpfr-dev
        libtool
        autoconf
        gettext
        autopoint
        ifupdown
        bridge-utils
        bear # llvm & clangd
        libear
        gdm3 # gnome display manager
        ubuntu-desktop
        gnome-keyring
        network-manager-gnome
        xfce4 # xfce
        xfce4-goodies
        xfce4-screensaver
        tigervnc-standalone-server # TigerVNC
        tigervnc-xorg-extension
        tigervnc-viewer
        remmina # remote desktop client
    )

    sudo apt update
    sudo apt remove --purge -y thunderbird lightdm xrdp xorgxrdp

    echo "gdm3 shared/default-x-display-manager select gdm3" | sudo debconf-set-selections
    sudo DEBIAN_FRONTEND=noninteractive apt install -y --no-install-recommends "${prerequisitesForUbuntu[@]}"
    sudo DEBIAN_FRONTEND=noninteractive dpkg-reconfigure gdm3
    sudo apt autoremove -y
}

updatePrequesitesForMac() {
    checkSudoPrivilege
    prerequisitesForMac=(
        yt-dlp
        fzf
        fd
        bat
        vim
    )

    echo -e "${COLOR}Updating prerequisites for macOS${RESET}"
    brew update
    brew install "${prerequisitesForMac[@]}"
}

setTimeZone() {
    echo -e "${COLOR}Setting timezone to Vancouver${RESET}"
    # check time zone if it is already vancouver
    if [ "$(timedatectl | grep "Time zone" | awk '{print $3}')" == "America/Vancouver" ]; then
        echo -e "${GREEN}✔${GREY} Time zone is already vancouver${RESET}"
        return
    fi
    sudo timedatectl set-timezone America/Vancouver
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Success!${RESET}"
    else
        echo -e "${RED}Failed!${RESET}"
        exit 1
    fi
}

stopAndDisableDaemonService() {
    local targetServiceName="${1:-networking.service}"
    # Check if the service exists
    if ! systemctl cat "$targetServiceName" >/dev/null 2>&1; then
        echo -e "${RED}Error: Service '${targetServiceName}' does not exist.${RESET}"
        return 1
    fi
    # Stop the service
    local targetServiceStatus=$(systemctl is-active "$targetServiceName" 2>&1)
    if [ "$targetServiceStatus" == "active" ]; then
        echo -e "${LIGHTYELLOW}Service '${targetServiceName}' is active. Attempting to stop it...${RESET}"
        if sudo systemctl stop "$targetServiceName"; then
            echo -e "${GREEN}✔${GREY} Successfully stopped service '${targetServiceName}'.${RESET}"
        else
            echo -e "${RED}Failed to stop service '${targetServiceName}'.${RESET}"
        fi
    elif [ "$targetServiceStatus" == "inactive" ] || [ "$targetServiceStatus" == "failed" ]; then
        echo -e "${GREEN}✔${GREY} Service '${targetServiceName}' is inactive (status: $targetServiceStatus).${RESET}"
    else
        echo -e "${RED}Failed to check status for service '${targetServiceName}'.${RESET}"
        return 1
    fi

    # Disable the service
    local targetServiceEnabledStatus=$(systemctl is-enabled "$targetServiceName" 2>&1)
    case "$targetServiceEnabledStatus" in
        "disabled")
            echo -e "${GREEN}✔${GREY} Service '${targetServiceName}' is already disabled.${RESET}"
            return 0
            ;;
        "static")
            echo -e "${GREEN}✔${GREY} Service '${targetServiceName}' is static (cannot be enabled/disabled conventionally). No action needed.${RESET}"
            return 0
            ;;
        "masked")
            echo -e "${GREEN}✔${GREY} networking.service is masked. No disable action needed.${RESET}"
            return 0
            ;;
        *)
            echo -e "${LIGHTYELLOW}Attempting to disable service '${targetServiceName}' (current status: '$targetServiceEnabledStatus')...${RESET}"
            if sudo systemctl disable "$targetServiceName"; then
                echo -e "${GREEN}✔${GREY} Successfully disabled service '${targetServiceName}'.${RESET}"
            else
                echo -e "${RED}Failed to disable service '${targetServiceName}'. It might be already disabled or an error occurred.${RESET}"
                return 1
            fi
            ;;
    esac
}

# There are two primary services associated with networking in Debian/Ubuntu-based systems:
# 1. networking.service:
#    - This is the traditional System V init-style networking service.
#    - It primarily manages network interfaces configured in `/etc/network/interfaces`.
#    - It's often used for statically configured interfaces or simpler network setups.
#    - On modern systems, especially desktops and laptops, NetworkManager often takes precedence.
#
# 2. NetworkManager.service:
#    - This is a more dynamic and feature-rich network management daemon.
#    - It's the default on most modern desktop Linux distributions, including Ubuntu Desktop.
#    - It provides automatic detection and configuration for various network types (Ethernet, Wi-Fi, VPNs, etc.).
#    - It manages connections through profiles and can handle roaming, multiple connections, and user-specific settings.
#    - It usually takes control of interfaces *not* explicitly managed by `/etc/network/interfaces` (unless configured otherwise).
#
# Coexistence and Conflicts:
# - Generally, it's recommended to use *either* `networking.service` (via `/etc/network/interfaces`) *or* `NetworkManager.service` to manage a particular network interface, but not both.
# - Having both active and attempting to manage the same interfaces can lead to conflicts, unpredictable behavior, or connection issues.
# - For desktop environments, NetworkManager is usually preferred for its ease of use and dynamic capabilities.
# - For servers, especially with static IPs, `networking.service` with `/etc/network/interfaces` is often sufficient and more straightforward.
# - The script below checks if NetworkManager is active. If it is, and `networking.service` is also active,
#   it attempts to stop and disable `networking.service` to prevent potential conflicts, assuming NetworkManager
#   is the intended primary network manager.
checkNetworkManagerStatus() {
    echo -e "${COLOR}Checking NetworkManager.service status...${RESET}"
    local nmServiceStatus=$(systemctl is-active NetworkManager.service 2>&1)
    if [ "$nmServiceStatus" == "active" ]; then
        echo -e "${GREEN}✔${GREY} NetworkManager is active.${RESET}"
        stopAndDisableDaemonService "networking.service"
    elif [ "$nmServiceStatus" == "inactive" ] || [ "$nmServiceStatus" == "failed" ]; then
        echo -e "${LIGHTYELLOW}NetworkManager is not active (status: ${nmServiceStatus}).${RESET}"
        echo -e "${LIGHTYELLOW}Consider enabling and starting NetworkManager if it's intended to manage network connections.${RESET}"
        if [ "$(systemctl is-active networking.service 2>/dev/null)" == "active" ]; then
            echo -e "${GREY}networking.service is active. This might be intentional if NetworkManager is not used.${RESET}"
        fi
    else
        echo -e "${RED}Could not determine status of NetworkManager (status: '$nmServiceStatus').${RESET}"
    fi
}

stopUnnecessaryServices() {
    checkNetworkManagerStatus
    echo -e "${COLOR}Stopping unnecessary services...${RESET}"
    local services_to_manage=(
        "cups.service"          # CUPS (Common UNIX Printing System)
        "nmbd.service"          # NetBIOS Name Service
        "xrdp-sesman.service"   # Remote Desktop Protocol
    )
    for service in "${services_to_manage[@]}"; do
        stopAndDisableDaemonService "$service"
    done
}

installTmuxPluginsManager() {
    if [ -d ~/.tmux/plugins/tpm ]; then
        return
    fi
    echo -e "${COLOR}Installing TPM${RESET}"
    git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Success!${RESET}"
    else
        echo -e "${RED}Failed!${RESET}"
        exit 1
    fi
}

updateVimPlugins (){
    echo -e "${COLOR}Installing Vim Plugins Manager${RESET}"

    if [ ! -f ~/.vimrc ]; then
        echo "No .vimrc found, Abort!"
        exit 1
    fi

    if [ ! -f "$fVimPlugsManagerPath" ]; then
        # use the --insecure option to avoid certificate check
        curl $fTlsInsecure -fLo "$fVimPlugsManagerPath" --create-dirs \
        https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
    else
        echo -e "${GREEN}✔${GREY} Vim Plug Manager is already installed${RESET}"
    fi

    echo -e "${COLOR}Updating Vim Plugins${RESET}"
    vim +PlugInstall +PlugUpdate +qall
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}✔ Success!${RESET}"
    else
        echo -e "${RED}x Failed!${RESET}"
        exit 1
    fi
}

tackleTheExceptions() {
    if [ "$(hostname)" != "VAN-935558-PC0" ]; then
        return
    fi
    echo -e "${COLOR}Tackling exceptions${RESET}"
    # Copy back the privileged git config.
    gitconfigCheckFile=$HOME/.gitconfig.fortinet
    if [ -f "$gitconfigCheckFile"  ]; then
        echo -e "${LIGHTYELLOW}The privileged file $gitconfigCheckFile exists.${RESET}"
        echo -e "Relink $HOME/.gitconfig to $gitconfigCheckFile"
        ln -sf "$gitconfigCheckFile" "$HOME"/.gitconfig
        if [ $? -eq 0 ]; then
            echo -e "${GREEN}Success!${RESET}"
        else
            echo -e "${RED}Failed!${RESET}"
            exit 1
        fi
    fi
}

# linkFile: Creates a symbolic link for a file to a directory (destination).
#
# Usage:
#   linkFile /path/of/source/file /path/to/destination/dir
#   e.g., linkFile ~/myfile.txt /data/backup
#
# Arguments:
#   $1 - Source file
#   $2 - Destination directory path to link to
#   $3 - New link name (optional, default: as is)
#
# Returns:
#   0 if successful, 1 if already linked, 2 if source file does not exist
# ln [OPTION] TARGET LINK_NAME
linkFile() {
    local target="$1"      # The target to link
    local linkPath="$2"    # Destination directory to link to
    local newLinkName="$3" # New link name (optional, default: as is)

    if [ ! -d "$linkPath" ]; then
        echo -e "${RED}Destination directory $linkPath does not exist, abort!${RESET}"
        exit 1
    fi
    local filename=$(basename "$target")
    local linkName=${newLinkName:-$filename}
    local src="$target"
    local dst="$linkPath/${linkName}"
    local execPrefix=

    [ ! -f "$target" ] && echo "Source file $target does not exist, abort!" && exit 1
    if [ -f "$dst" ] && [ ! -L "$dst" ]; then
        [ ! -d "$fBackupDir" ] && mkdir -p "$fBackupDir"
        echo -e "${CYAN}Warning: $dst is not a link, backing it up into $fBackupDir${RESET}"
        mv "$dst" "$fBackupDir/${linkName}.bak"
    fi

    if [ -L "$dst" ] && [ "$(readlink "$dst")" == "$src" ]; then
        echo -e "${GREEN}✔${GREY} Link ${BLUE}${linkName}${GREY} is already up to date.${RESET}"
        return 1
    fi

    # echo -e "${LIGHTYELLOW}Creating symlink${RESET}: $linkName -> $src"
    echo -e "${LIGHTYELLOW}Creating symlink${RESET}: $dst"
    echo "               => $src"
    for _ in {1..2}; do
        $execPrefix ln -sf "$target" "$dst"
        if [ $? -eq 0 ]; then
            echo -e "${GREEN}Success!${RESET}"
            break
        else
            echo -e "${RED}Failed! Retrying with sudo...${RESET}"
            execPrefix="sudo "
            continue
        fi
    done
}

# linkFiles: Creates symbolic links for all files in a source directory to a specified destination directory.
#
# Usage:
#   linkFiles /path/to/source/dir /path/to/destination/dir [linknamePrefix]
#   e.g., linkFiles ~/mydir /data/backup
#
# Arguments:
#   $1 - Source directory
#   $2 - Destination directory path to link to
#   $3 - Prefix for destination filename (optional, Exp: . for hidden files)
#
# Returns:
#   0 if successful, 1 if already linked, 2 if source directory does not exist
# ln [OPTION] TARGET LINK_NAME
linkFiles() {
    local targetDir="$1"        # Source directory
    local linkPath="$2"         # Destination directory
    local linknamePrefix="$3"   # Prefix for destination filename. Exp: . for hidden files

    echo -e "${COLOR}Creating symlinks pointing from ${linkPath}/* to $(basename "$targetDir")/*${RESET}"
    [ ! -d "$targetDir" ] && echo "Source directory $targetDir does not exist, abort!" && exit 1
    [ ! -d "$linkPath" ] && mkdir -p "$linkPath"

    for file in "$targetDir"/*; do
        linkFile "$file" "$linkPath" "${linknamePrefix}$(basename "$file")"
    done

    if [ "$linkPath" == "$HOME" ]; then
        return
    fi

    COLOR=$GREEN
    find "$linkPath" -type l ! \
            -exec test -e {} \; \
            -exec rm -f {} \; \
            -exec echo -e "${COLOR}Deleting broken link: {}${RESET}" \;
    COLOR=$MAGENTA
}

# relinkCommand: Creates a symbolic link for a system command with a new name in new path.
#
# Usage:
#   relinkCommand <sysCmd> <linkName> [linkPath]
#   e.g., relinkCommand batcat bat
#
#   ~/.usr/bin/bat -> /bin/batcat
#
# Arguments:
#   $1 - System command to link
#   $2 - Link name (new name)
#   $3 - Optional destination directory path (new path, default: $HOME/.usr/bin)
#
# Returns:
#   0 if successful, 1 if already linked, 2 if system command does not exist
# ln [OPTION] TARGET LINK_NAME
relinkCommand() {
    local sysCmd=$1
    local linkName=$2
    local linkPath=$HOME/.usr/bin
    [ -n "$3" ] && linkPath=$3
    local dst=$linkPath/$linkName
    local execPrefix=

    [ ! -d "$linkPath" ] && mkdir -p "$linkPath"
    sysCmdPath=$(command -v "$sysCmd")
    if [ -z "$sysCmdPath" ]; then
        echo "${sysCmd} is not installed"
        return 2
    fi

    if [ -L "$dst" ] && [ "$(readlink "$dst")" == "$sysCmdPath" ]; then
        echo -e "${GREEN}✔${GREY} Link ${BLUE}${linkName}${GREY} is already up to date.${RESET}"
        return 1
    fi

    echo -e "${COLOR}Creating symlink: ${linkName} -> syscmd: ${sysCmdPath}${RESET}"
    for _ in {1..2}; do
        $execPrefix ln -sf "$sysCmdPath" "$dst"
        if [ $? -eq 0 ]; then
            echo -e "${GREEN}Success!${RESET}"
            break
        else
            echo -e "${RED}Failed! Retrying with sudo...${RESET}"
            execPrefix="sudo "
            continue
        fi
    done
}

buildBatTheme() {
    # https://github.com/sharkdp/bat/tree/master/assets/themes
    echo -e "${COLOR}Building bat theme${RESET}"
    local batThemeDir=$HOME/.config/bat/themes
    local needBuild=
    [ ! -d "$batThemeDir" ] && mkdir -p "$batThemeDir"

    for theme in "$fTKBatThemeDir"/*; do
        linkFile "$theme" "$batThemeDir"
        if [ $? -eq 1 ]; then
            continue
        fi
        needBuild=true
    done

    [ -z "$needBuild" ] && return
    bat cache --build
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Success!${RESET}"
    else
        echo -e "${RED}Failed!${RESET}"
        exit 1
    fi
}

buildExtraFonts() {
    echo -e "${COLOR}Building extra fonts${RESET}"
    local needBuild=
    local fontConfigDir="$HOME/.config/fontconfig/conf.d"
    local fontDir=$HOME/.local/share/fonts
    [ ! -d "$fontDir" ] && mkdir -p "$fontDir"
    [ ! -d "$fontConfigDir" ] && mkdir -p "$fontConfigDir"

    for fontConfig in "$fTKFontConfigDir"/*; do
        linkFile "$fontConfig" "$fontConfigDir"
        if [ $? -eq 1 ]; then
            continue
        fi
    done

    for font in "$fTKFontDir"/*; do
        local fontFile=$(basename "$font")
        local fontExists=$(fc-list | grep -i "$fontFile")
        if [ -n "$fontExists" ]; then
            echo -e "${GREEN}✔${GREY} Font ${BLUE}${fontFile}${GREY} is already up to date.${RESET}"
            continue
        fi

        linkFile "$font" "$fontDir"
        if [ $? -eq 1 ]; then
            continue
        fi
        needBuild=true
    done

    [ -z "$needBuild" ] && return
    echo -e "${COLOR}Building font cache...${RESET}"
    sudo fc-cache -fv
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Success!${RESET}"
    else
        echo -e "${RED}Failed!${RESET}"
        exit 1
    fi
}

changeTMOUTToWritable() {
    # TMOUT is readonly in /etc/profile, change it to writable so that we can unset it in .bashrc
    if ! grep -q "TMOUT" /etc/profile; then
        return
    fi
    echo -e "${COLOR}Changing TMOUT to writable${RESET}"
    if grep -q "^readonly TMOUT" /etc/profile; then
        echo -e "${GREY}TMOUT is readonly in /etc/profile, change it to writable${RESET}"
    else
        echo -e "${GREEN}✔${GREY} TMOUT is already writable$ in /etc/profile${RESET}"
        return
    fi

    sudo sed -i 's/^readonly TMOUT/# readonly TMOUT/g' /etc/profile
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Success!${RESET}"
    else
        echo -e "${RED}Failed!${RESET}"
        exit 1
    fi
}

createTKSymlinks() {
    # The directories are guaranteed to exist when this function is called.
    linkFiles "$fTKFilesDir" "$HOME" "."
    linkFiles "$fTKCompDir" "$HOME/.bash_completion.d"
    linkFiles "$fTKVimColorsDir" "$HOME/.vim/colors"
}

linkNodeJsFromCodeServer() {
    [ -z $fLinkNodeJs ] && return
    local vscodeServerDir="$HOME/.vscode-server"
    if [ ! -d "$vscodeServerDir" ]; then
        echo -e "${LIGHTYELLOW}VSCode Server directory not found: ${BLUE}$vscodeServerDir${RESET}"
        echo -e "${LIGHTYELLOW}Skipping linking Node.js from VSCode Server.${RESET}"
        return
    fi
    echo -e "${LIGHTYELLOW}Searching for Node.js executable in ${BLUE}$vscodeServerDir${RESET}..."
    local latestNodeJsPath=$(find "$vscodeServerDir" -name "node" -type f -executable \
            -exec stat -c '%W %n' {} \; 2>/dev/null | sort -nr | cut -d' ' -f2- | head -n1)

    echo -e "${GREEN}Found latest Node.js executable at: ${BLUE}$latestNodeJsPath${RESET}"
    linkFile "$latestNodeJsPath" "$HOME/.usr/bin" "node"
}

createExtraSymlinks() {
    if [ -z "$fNoInstallTools" ]; then
        linkFiles "$fTKToolsDir" "$HOME/.usr/bin"
        linkFiles "$fTKtemplateDir" "$HOME/Templates"
    fi

    echo -e "${COLOR}Creating extra symlinks${RESET}"
    # The directories are guaranteed to exist when this function is called.
    linkFile "$fTKClangdConfig" "$HOME/.config/clangd"
    linkFile "$fzfTabCompPath" "$HOME/.bash_completion.d" "fzf_tab_completion.bash"
    linkFile "$fzfBinPath" "$HOME/.usr/bin"
    linkFile "$fJCPath" "$HOME/.usr/bin"
    linkFile "$fMainDir"/assets/vscode/remote.settings.json "$HOME"/.vscode-server/data/Machine "settings.json"

    echo -e "${COLOR}Relinking system commands${RESET}"
    relinkCommand "/bin/batcat" "bat"
    relinkCommand "/bin/fdfind" "fd"
    relinkCommand "/bin/bash" "sh" "/bin/"

    # Link Node.js from VSCode Server
    linkNodeJsFromCodeServer
}

setupCoreDirectories() {
    local dirsToCheck=(
        "$fBackupDir"
        "$HOME/Downloads"
        "$HOME/Templates"
        "$HOME/.vnc"
        "$HOME/.bash_completion.d"
        "$HOME/.usr/bin"
        "$HOME/.local/share/fonts"
        "$HOME/.config/bat/themes"
        "$HOME/.config/fontconfig/conf.d"
        "$HOME/.config/clangd"
    )

    for dir in "${dirsToCheck[@]}"; do
        if [ ! -d "$dir" ]; then
            echo -e "${LIGHTYELLOW}Creating directory: ${BLUE}$dir${RESET}"
            mkdir -p "$dir"
            if [ $? -ne 0 ]; then
                echo -e "${RED}Error: Failed to create directory $dir${RESET}"
                exit 1
            fi
        fi
    done

    cd "$fMainDir" || exit
}

installUpdateClangd() {
    echo -e "${COLOR}Updating Clangd${RESET}"
    # Check if the current architecture is arm64
    if [ "$fArch" == "aarch64" ]; then
        sudo apt install clangd -y
        return
    fi

    if ! command -v jq &> /dev/null; then
        echo -e "${RED}Error: jq is required but not installed. Please install jq first.${RESET}"
        return 1
    fi

    local currentVersion=""
    local clangdPath=$(command -v clangd 2>/dev/null)
    if [ -n "$clangdPath" ]; then
        currentVersion=$($clangdPath --version | head -n1 | grep -oP 'version \K[0-9]+\.[0-9]+\.[0-9]+' || echo "")
        echo -e "Current clangd version: ${BLUE}$currentVersion${RESET}"
    else
        echo -e "${LIGHTYELLOW}clangd is not currently installed${RESET}"
        currentVersion="0.0.0"
    fi

    # Get the latest stable release version and download URL
    echo -e "${LIGHTYELLOW}Fetching latest Clangd binary information${RESET}"
    # 20.1.0
    # https://github.com/clangd/clangd/releases/download/20.1.0/clangd-linux-20.1.0.zip
    local output=$(curl $fTlsInsecure -s https://api.github.com/repos/clangd/clangd/releases |
        jq -r '[.[] | select(.prerelease == false)] | .[0] |
               .name, (.assets[] | select(.name | contains("clangd-linux")) | .browser_download_url)')
    mapfile -t lines <<< "$output"
    local latestVersion="${lines[0]}"
    local downloadUrl="${lines[1]}"
    if [ -z "$latestVersion" ] || [ "$latestVersion" == "null" ]; then
        echo -e "${RED}Error: Failed to get latest version information${RESET}"
        return 1
    fi

    echo -e "Latest available clangd version: ${COLOR}$latestVersion${RESET}"
    if [ -n "$currentVersion" ]; then
        if [ "$(printf '%s\n' "$latestVersion" "$currentVersion" | sort -V -r | head -n1)" == "$currentVersion" ]; then
            echo -e "${GREY}No update needed. Current version is up to date.${RESET}"
            return 0
        fi
    fi

    echo -e "${LIGHTYELLOW}Downloading latest version of Clangd${RESET}"
    local fileName=$(basename "$downloadUrl")
    local downloadDst="$fDownloads/$fileName"
    if [ -f "$downloadDst" ]; then
        echo -e "${GREY}File $fileName already exists in $fDownloads, skipping download.${RESET}"
    else
        curl $fTlsInsecure -Lo "$downloadDst" "$downloadUrl"
        if [ $? -ne 0 ]; then
            echo -e "${RED}Error: Failed to download the latest version${RESET}"
            return 1
        fi
    fi

    cd "$fDownloads" || exit 1
    local peekInfo=$(zipinfo -1 "$downloadDst" | head -n 1)
    local extractDir="$fDownloads/$(dirname "$peekInfo")"
    if [ -d "$extractDir" ]; then
        echo -e "${GREY}Directory $extractDir already exists, skipping extraction.${RESET}"
    else
        echo -e "${LIGHTYELLOW}Extracting Clangd${RESET}"
        unzip "$downloadDst"
        if [ ! -d "$extractDir" ]; then
            echo -e "${RED}Error: Failed to extract the downloaded file${RESET}"
            exit 1
        fi
        echo -e "${GREEN}Successfully extracted to $extractDir${RESET}"
    fi

    # find binary named clangd under the extracted directory
    local clangdBinary=$(find "$extractDir" -type f -name "clangd" -executable | head -n 1)
    if [ -z "$clangdBinary" ]; then
        echo -e "${RED}Error: Failed to find the clangd binary in the extracted directory${RESET}"
        return 1
    fi

    linkFile "$clangdBinary" "$HOME/.usr/bin"
}

createFirstTimeFile() {
    [ -f "$fFirstTimeFile" ] && return
    touch "$fFirstTimeFile"
}

installDocker() {
    echo -e "${COLOR}Checking Docker...${RESET}"
    if command -v docker &> /dev/null && [ -z "$fUpdateDocker" ]; then
        echo -e "${GREEN}✔${GREY} Docker is already installed.${RESET}"
        printf "  "
        docker --version
        return 0
    fi

    echo -e "${COLOR}Installing Docker${RESET}"

    # 1. Uninstall old versions
    echo -e "${LIGHTYELLOW}Uninstalling old Docker versions (if any)...${RESET}"
    sudo apt-get remove -y docker docker-engine docker.io containerd runc > /dev/null 2>&1
    sudo apt-get autoremove -y > /dev/null 2>&1
    echo -e "${GREY}Old versions uninstalled/autoremoved (if any existed).${RESET}"

    # 2. Set up the repository
    echo -e "${LIGHTYELLOW}Setting up Docker repository...${RESET}"
    if ! sudo apt-get update; then
        echo -e "${RED}Failed to update apt package list.${RESET}"
        exit 1
    fi

    if [ ! -d /etc/apt/keyrings ] && ! sudo install -m 0755 -d /etc/apt/keyrings; then
        echo -e "${RED}Failed to create /etc/apt/keyrings directory.${RESET}"
        exit 1
    fi

    # Download Docker's official GPG key
    local dockerGpgKey="/etc/apt/keyrings/docker.gpg"
    if [ -f "$dockerGpgKey" ]; then
        echo -e "${GREY}Docker GPG key already exists at $dockerGpgKey. Verifying permissions...${RESET}"
    else
        echo -e "${LIGHTYELLOW}Downloading Docker's official GPG key...${RESET}"
        if ! curl $fTlsInsecure -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o "$dockerGpgKey"; then
            echo -e "${RED}Failed to download or dearmor Docker GPG key.${RESET}"
            exit 1
        fi
        echo -e "${GREEN}Docker GPG key downloaded and dearmored successfully.${RESET}"
    fi
    if ! sudo chmod a+r /etc/apt/keyrings/docker.gpg; then
        echo -e "${RED}Failed to set permissions for Docker GPG key.${RESET}"
        exit 1
    fi

    # Add Docker repository to Apt sources
    # shellcheck disable=SC2024 # sudo tee is generally fine with output redirection here.
    if ! echo \
      "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
      $(lsb_release -cs) stable" | \
      sudo tee /etc/apt/sources.list.d/docker.list > /dev/null; then
        echo -e "${RED}Failed to add Docker repository to apt sources.${RESET}"
        exit 1
    fi
    echo -e "${GREEN}Docker repository set up successfully.${RESET}"

    # 3. Install Docker Engine
    echo -e "${LIGHTYELLOW}Installing Docker Engine...${RESET}"
    if ! sudo apt-get update; then
        echo -e "${RED}Failed to update apt package list after adding Docker repo.${RESET}"
        exit 1
    fi
    if ! sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin; then
        echo -e "${RED}Failed to install Docker Engine packages.${RESET}"
        exit 1
    fi
    echo -e "${GREEN}Docker Engine installed successfully.${RESET}"

    # 4. Verify installation
    echo -e "${LIGHTYELLOW}Verifying Docker installation by running hello-world...${RESET}"
    if sudo docker run hello-world; then
        echo -e "${GREEN}Docker hello-world container ran successfully.${RESET}"
    else
        echo -e "${RED}Docker hello-world container failed to run. Docker might be installed but requires attention.${RESET}"
    fi

    # 5. Post-installation steps
    echo -e "${LIGHTYELLOW}Configuring Docker to run without sudo for current user ($USER)...${RESET}"
    if ! getent group docker > /dev/null; then
        echo -e "${GREY}Docker group does not exist, creating it...${RESET}"
        if ! sudo groupadd docker; then
            echo -e "${RED}Failed to create 'docker' group. You may need to do this manually.${RESET}"
        else
            echo -e "${GREEN}'docker' group created.${RESET}"
        fi
    else
        echo -e "${GREY}'docker' group already exists.${RESET}"
    fi

    if getent group docker > /dev/null; then
        if sudo usermod -aG docker "$USER"; then
            echo -e "${LIGHTYELLOW}IMPORTANT: You must log out and log back in, or run 'newgrp docker' in your terminal, for this change to take full effect.${RESET}"
        else
            echo -e "${RED}Failed to add user $USER to the 'docker' group. You may need to do this manually (e.g., sudo usermod -aG docker \"\$USER\").${RESET}"
        fi
    else
        echo -e "${RED}Cannot add user to 'docker' group as the group does not exist or could not be created.${RESET}"
    fi

    echo -e "${GREEN}Docker installation and basic configuration process completed.${RESET}"
}

installRimePinyinInputMethod() {
    echo -e "${COLOR}Checking Rime Pinyin input method...${RESET}"
    if [ -z "$fForceChinesePinyin" ]; then
        if command -v fcitx5-configtool &> /dev/null || \
           command -v fcitx-configtool  &> /dev/null; then
                echo -e "${GREEN}✔${GREY} Rime Pinyin input method is already installed.${RESET}"
                return 0
        fi
    fi

    echo -e "${COLOR}Installing Rime Pinyin input method${RESET}"
    echo -e "${LIGHTYELLOW}Updating package lists...${RESET}"
    if ! sudo apt update; then
        echo -e "${RED}Failed to update apt package list. Aborting Rime installation.${RESET}"
        return 1
    fi

    local fcitxXProfilePath=$fMainDir/assets/vnc/fcitx5.xprofile
    # --- Attempt Fcitx5-Rime first ---
    echo -e "${COLOR}Checking for Fcitx5-Rime availability...${RESET}"
    if apt-cache show fcitx5-rime > /dev/null 2>&1; then
        echo -e "${GREEN}Fcitx5-Rime (fcitx5-rime) appears to be available. Attempting installation.${RESET}"
        local packagesToInstallFcitx5=(
            fcitx5
            fcitx5-rime
            fcitx5-chinese-addons # Provides general Chinese support, dictionaries, etc.
            # fcitx5-configtool     # GUI configuration tool (e.g., fcitx5-config-qt)
            fcitx5-config-qt      # GUI configuration tool
            im-config             # Input method configuration tool (sets fcitx5 as default)
        )

        # Link the xprofile file
        linkFile "$fcitxXProfilePath" "$HOME" .xprofile
        echo -e "${LIGHTYELLOW}Installing Fcitx5 packages: ${packagesToInstallFcitx5[*]}${RESET}"
        if sudo DEBIAN_FRONTEND=noninteractive apt install -y "${packagesToInstallFcitx5[@]}"; then
            echo -e "${GREEN}Successfully installed Fcitx5 and Rime packages.${RESET}"
            echo -e "${LIGHTYELLOW}Setting fcitx5 as the default input method system-wide using im-config...${RESET}"
            if sudo im-config -n fcitx5; then
                echo -e "${GREEN}Successfully configured fcitx5 as the default input method via im-config.${RESET}"
                echo -e "${GREY}(im-config handles setting environment variables like XMODIFIERS, GTK_IM_MODULE, QT_IM_MODULE for graphical sessions)${RESET}"
            else
                echo -e "${RED}Failed to set fcitx5 as the default input method using im-config.${RESET}"
                echo -e "${LIGHTYELLOW}You might need to run 'im-config' (as a regular user, not sudo) to select fcitx5, or configure it via your desktop environment's settings.${RESET}"
                echo -e "${LIGHTYELLOW}Alternatively, for X11 sessions, ensure these lines are in your ~/.xprofile or similar (e.g., ~/.profile, ~/.xinitrc):${RESET}"
                echo -e "${LIGHTYELLOW}  export GTK_IM_MODULE=fcitx5${RESET}"
                echo -e "${LIGHTYELLOW}  export QT_IM_MODULE=fcitx5${RESET}"
                echo -e "${LIGHTYELLOW}  export XMODIFIERS=@im=fcitx5${RESET}"
            fi

            echo -e "${GREEN}Fcitx5-Rime installation and basic configuration process completed.${RESET}"
            echo -e "${BOLD}${MAGENTA}IMPORTANT: A system REBOOT or RE-LOGIN is REQUIRED for all changes to take full effect.${RESET}"
            echo -e "${LIGHTYELLOW}After rebooting/re-logging in:${RESET}"
            echo -e "${LIGHTYELLOW}1. Fcitx5 should start automatically. If not, add 'fcitx5' to your session's startup applications.${RESET}"
            echo -e "${LIGHTYELLOW}2. Open 'Fcitx 5 Configuration' (command: ${BLUE}fcitx5-configtool${RESET}).${RESET}"
            echo -e "${LIGHTYELLOW}3. In the 'Input Method' tab, ensure 'Pinyin' (from Rime) is in the list of active input methods. ${RESET}"
            echo -e "${LIGHTYELLOW}   If not, click the '+' button, uncheck 'Only Show Current Language' if needed, find 'Pinyin' (Rime), and add it.${RESET}"
            echo -e "${LIGHTYELLOW}4. You can switch input methods using the configured hotkey (often Ctrl+Space or Super+Space). Check 'Global Options' tab in fcitx5-configtool for 'Trigger Input Method'.${RESET}"
            echo -e "${LIGHTYELLOW}5. For Rime specific settings (e.g., traditional Chinese, fuzzy pinyin), create/edit files in ${BLUE}~/.local/share/fcitx5/rime/${RESET} (e.g., default.custom.yaml). Refer to Rime documentation.${RESET}"
            return 0
        else
            echo -e "${RED}Failed to install Fcitx5-Rime packages. Will try Fcitx4-Rime as a fallback.${RESET}"
        fi
    else
        echo -e "${LIGHTYELLOW}Fcitx5-Rime (fcitx5-rime) not found in official repositories. Checking for Fcitx4-Rime.${RESET}"
    fi

    # --- Attempt Fcitx4-Rime (fcitx) if Fcitx5-Rime was not available or failed ---
    echo -e "${COLOR}Checking for Fcitx4-Rime (fcitx-rime) availability...${RESET}"
    if apt-cache show fcitx-rime > /dev/null 2>&1; then
        echo -e "${GREEN}Fcitx4-Rime (fcitx-rime) appears to be available. Attempting installation.${RESET}"
        local packagesToInstallFcitx4=(
            fcitx
            fcitx-rime
            fcitx-table-all       # Common tables for fcitx4, includes pinyin etc.
            fcitx-frontend-gtk3
            fcitx-frontend-qt5    # Or fcitx-libs-qt5 on older systems
            fcitx-config-gtk      # GUI config tool for fcitx4 (or fcitx-configtool)
            im-config
        )

        # Link .xprofile to ~/.xprofile
        fcitxXProfilePath=$fMainDir/assets/vnc/fcitx.xprofile
        linkFile "$fcitxXProfilePath" "$HOME" .xprofile
        echo -e "${LIGHTYELLOW}Installing Fcitx4 packages: ${packagesToInstallFcitx4[*]}${RESET}"
        if sudo DEBIAN_FRONTEND=noninteractive apt install -y "${packagesToInstallFcitx4[@]}"; then
            echo -e "${GREEN}Successfully installed Fcitx4 and Rime packages.${RESET}"

            echo -e "${LIGHTYELLOW}Setting fcitx as the default input method system-wide using im-config...${RESET}"
            if sudo im-config -n fcitx; then # Note: 'fcitx' for fcitx4
                echo -e "${GREEN}Successfully configured fcitx as the default input method via im-config.${RESET}"
            else
                echo -e "${RED}Failed to set fcitx as the default input method using im-config.${RESET}"
                echo -e "${LIGHTYELLOW}You might need to run 'im-config' (as a regular user) to select fcitx, or configure it via your desktop environment's settings.${RESET}"
                echo -e "${LIGHTYELLOW}Alternatively, for X11 sessions, ensure these lines are in your ~/.xprofile or similar:${RESET}"
                echo -e "${LIGHTYELLOW}  export GTK_IM_MODULE=fcitx${RESET}"
                echo -e "${LIGHTYELLOW}  export QT_IM_MODULE=fcitx${RESET}"
                echo -e "${LIGHTYELLOW}  export XMODIFIERS=@im=fcitx${RESET}"
            fi

            echo -e "${GREEN}Fcitx4-Rime installation and basic configuration process completed.${RESET}"
            echo -e "${BOLD}${MAGENTA}IMPORTANT: A system REBOOT or RE-LOGIN is REQUIRED for all changes to take full effect.${RESET}"
            echo -e "${LIGHTYELLOW}After rebooting/re-logging in:${RESET}"
            echo -e "${LIGHTYELLOW}1. Fcitx should start automatically. If not, add 'fcitx' to your session's startup applications.${RESET}"
            echo -e "${LIGHTYELLOW}2. Open 'Fcitx Configuration' (command: ${BLUE}fcitx-config-gtk${RESET} or ${BLUE}fcitx-configtool${RESET}).${RESET}"
            echo -e "${LIGHTYELLOW}3. Ensure 'Rime' is in the list of active input methods. If not, add it.${RESET}"
            echo -e "${LIGHTYELLOW}4. Switch input methods using the configured hotkey (e.g., Ctrl+Space).${RESET}"
            echo -e "${LIGHTYELLOW}5. Rime user data for fcitx4 is typically in ${BLUE}~/.config/fcitx/rime/${RESET}. Check Rime documentation.${RESET}"
            return 0
        else
            echo -e "${RED}Failed to install Fcitx4-Rime packages.${RESET}"
        fi
    else
        echo -e "${LIGHTYELLOW}Fcitx4-Rime (fcitx-rime) not found in official repositories.${RESET}"
    fi

    echo -e "${RED}Could not install Rime (neither Fcitx5-Rime nor Fcitx4-Rime) from official repositories.${RESET}"
    echo -e "${LIGHTYELLOW}Please ensure your system is Ubuntu/Debian based and your package sources are correctly configured.${RESET}"
    echo -e "${LIGHTYELLOW}No Rime input method was installed.${RESET}"
    return 1
}

installDebFirefox() {
    echo -e "${COLOR}Checking for DEB version of Firefox...${RESET}"
    if ! apt-cache show fcitx5-rime > /dev/null 2>&1; then
        return 0
    fi
    # Check if Firefox is installed and if it's the DEB version from Mozilla PPA
    if command -v firefox &>/dev/null; then
        firefoxPolicy=$(apt-cache policy firefox)
        if echo "$firefoxPolicy" | grep -q "mozillateam/ppa"; then
            installedVersion=$(echo "$firefoxPolicy" | grep "Installed:" | awk '{print $2}')
            candidateVersion=$(echo "$firefoxPolicy" | grep "Candidate:" | awk '{print $2}')
            if [ "$installedVersion" != "(none)" ] && [ "$installedVersion" == "$candidateVersion" ]; then
                echo -e "${GREEN}✔${GREY} Firefox (DEB version from Mozilla PPA) is already installed and up-to-date (${installedVersion}).${RESET}"
                return 0
            fi
        elif echo "$firefoxPolicy" | grep -q "snap"; then
            echo -e "${LIGHTYELLOW}Snap version of Firefox found. Will attempt to replace with DEB version.${RESET}"
        fi
    fi

    echo -e "${COLOR}Installing Firefox (DEB version) from Mozilla PPA${RESET}"
    # 1. Add the Mozilla PPA
    echo -e "${LIGHTYELLOW}Adding Mozilla PPA (ppa:mozillateam/ppa)...${RESET}"
    if ! sudo add-apt-repository -y ppa:mozillateam/ppa; then
        echo -e "${RED}Failed to add Mozilla PPA. Aborting Firefox DEB installation.${RESET}"
        return 1
    fi
    echo -e "${GREEN}Mozilla PPA added successfully.${RESET}"

    # 2. Create the preference file to prioritize PPA Firefox
    local preferenceFilePath="/etc/apt/preferences.d/mozilla-firefox-nosnap"
    local preferenceContent=$(cat <<EOF
Package: *
Pin: release o=LP-PPA-mozillateam
Pin-Priority: 1001

Package: firefox
Pin: release o=Ubuntu*
Pin-Priority: -1
EOF
)
    echo -e "${LIGHTYELLOW}Setting up APT preferences to prioritize Mozilla PPA Firefox...${RESET}"
    if [ -f "$preferenceFilePath" ] && cmp -s <(echo "$preferenceContent") "$preferenceFilePath"; then
        echo -e "${GREY}APT preference file '$preferenceFilePath' already exists and is correctly configured.${RESET}"
    else
        echo "$preferenceContent" | sudo tee "$preferenceFilePath" > /dev/null
        if [ $? -eq 0 ]; then
            echo -e "${GREEN}APT preference file '$preferenceFilePath' created/updated successfully.${RESET}"
        else
            echo -e "${RED}Failed to create/update APT preference file '$preferenceFilePath'. Aborting.${RESET}"
            return 1
        fi
    fi

    # 3. Uninstall Snap Firefox (if present)
    if snap list firefox &>/dev/null; then
        echo -e "${LIGHTYELLOW}Uninstalling Snap version of Firefox...${RESET}"
        if ! sudo snap remove firefox; then
            echo -e "${RED}Failed to remove Snap Firefox. This might interfere. Continuing, but manual removal might be needed.${RESET}"
        else
            echo -e "${GREEN}Snap Firefox removed successfully.${RESET}"
        fi
    else
        echo -e "${GREY}Snap version of Firefox not found. Skipping removal.${RESET}"
    fi

    # 4. Install DEB Firefox
    echo -e "${LIGHTYELLOW}Updating package lists...${RESET}"
    if ! sudo apt update; then
        echo -e "${RED}Failed to update apt package list after PPA and preference changes. Aborting Firefox installation.${RESET}"
        return 1
    fi

    echo -e "${LIGHTYELLOW}Installing Firefox (DEB version)...${RESET}"
    if ! sudo apt install -y firefox; then
        echo -e "${RED}Failed to install Firefox (DEB version).${RESET}"
        echo -e "${LIGHTYELLOW}Attempting to install specific components that might be missing (e.g., language packs)...${RESET}"
        sudo apt install -y firefox-locale-en # Example for English, adjust if needed
        if ! sudo apt install -y firefox; then # Retry main installation
             echo -e "${RED}Still failed to install Firefox (DEB version) after attempting component install.${RESET}"
             return 1
        fi
    fi

    # 5. Verify installation
    if command -v firefox &>/dev/null; then
        firefoxVersion=$(firefox --version)
        firefoxPolicyAfter=$(apt-cache policy firefox)
        if echo "$firefoxPolicyAfter" | grep -q "mozillateam/ppa"; then
            echo -e "${GREEN}Firefox (DEB version) installed successfully! Version: $firefoxVersion${RESET}"
            echo -e "${GREY}Policy check confirms it's from Mozilla PPA.${RESET}"
        else
            echo -e "${RED}Firefox installed, but it might not be the DEB version from Mozilla PPA. Please check 'apt-cache policy firefox'.${RESET}"
        fi
    else
        echo -e "${RED}Firefox installation failed or binary not found in PATH.${RESET}"
        return 1
    fi
    return 0
}

linkClangFormat() {
    local argVal="$1"
    if [ -n "$argVal" ]; then
        if [ ! -d "$argVal" ]; then
            echo -e "${RED}Error: Link path '$argVal' is not a valid directory.${RESET}" >&2
            exit 1
        fi
        fLinkClangFormatPath="$argVal"
    fi

    local realClangFormatPath=$fMainDir/assets/clangd/clang-format
    echo -e "${LIGHTYELLOW}Linking clang-format to $fLinkClangFormatPath/.clang-format${RESET}"
    linkFile "$realClangFormatPath" "$fLinkClangFormatPath" .clang-format
}

isVncServerRunning() {
    if ! command -v tigervncserver &> /dev/null; then
        echo -e "${RED}Error: vncserver is not installed.${RESET}" >&2
        exit 1
    fi
    if lsof -i :$fVncRealPort | grep --quiet LISTEN; then
        return 0
    else
        return 1
    fi
}

stopVncServer() {
    if isVncServerRunning; then
        echo -e "${LIGHTYELLOW}Stopping VNC server on port $fVncRealPort...${RESET}"
        tigervncserver -kill :$fVncSimplePort
    else
        echo -e "${LIGHTYELLOW}VNC server on port $fVncRealPort is not running.${RESET}"
    fi
}

startVncServer() {
    if isVncServerRunning; then
        echo -e "${LIGHTYELLOW}VNC server on port $fVncRealPort is already running.${RESET}"
        return 0
    fi
    local hostIpAddress=$(hostname -I | awk '{print $1}')
    local hostUsername=$(whoami)
    local xstartupPath=$fMainDir/assets/vnc/xstartup
    local xstartupDest=$HOME/.vnc/xstartup
    [ -d "$HOME"/.vnc ] || mkdir -p "$HOME"/.vnc
    cd "$HOME"/.vnc || exit
    linkFile "$xstartupPath" "$HOME/.vnc" xstartup
    linkFile "$fMainDir/assets/gdm3/custom.conf" "/etc/gdm3" custom.conf
    echo -e "${GREEN}Starting VNC server...${RESET}"
    local startCmd="tigervncserver :$fVncSimplePort -geometry $fVncResolution -SecurityTypes None -localhost yes -xstartup $xstartupDest"
    echo -e "${MAGENTA}$startCmd${RESET}"
    $startCmd
    if [ $? -ne 0 ]; then
        echo -e "${RED}Failed to start VNC server.${RESET}"
        return 1
    fi
    echo -e "${MAGENTA}VNC server started successfully:${RESET}"
    sudo lsof -i :5909
    echo -e "${CYAN}===================================================${RESET}"
    echo -e "${BOLD}${LIGHTYELLOW}- On your local machine, setup the SSH tunnel as follows:${RESET}"
    echo -e "  ${GREEN}Option 1.${RESET} Use Vs Code Port Forward feature to forward the port ${MAGENTA}$fVncRealPort${RESET}"
    echo -e "  ${GREEN}Option 2.${RESET} Open a terminal and run the following command:"
    echo -e "    ${BLUE}ssh -NL ${MAGENTA}$fVncRealPort${BLUE}:localhost:${MAGENTA}$fVncRealPort ${MAGENTA}$hostUsername@$hostIpAddress${RESET}"
    echo -e "    ${GREY}or simply:${RESET} ${BLUE}ssh -NL ${MAGENTA}$fVncRealPort${BLUE}:localhost:${MAGENTA}$fVncRealPort ${MAGENTA}droplet1${RESET}"
    echo -e "${BOLD}${LIGHTYELLOW}- Connect to the VNC server using a VNC viewer:${RESET}"
    echo -e "  ${BLUE}vncviewer localhost:${MAGENTA}$fVncRealPort${RESET}"
    echo -e "${CYAN}===================================================${RESET}"
}

restartVncServer() {
    stopVncServer
    sleep 1
    startVncServer
}

isOpenGrokContainerRunning() {
    if ! command -v docker &> /dev/null; then
        echo -e "${RED}Error: Docker is not installed. Please install Docker first.${RESET}"
        exit 1
    fi
    if ! docker info > /dev/null 2>&1; then
        echo -e "${RED}Error: Docker daemon does not seem to be running or accessible.${RESET}"
        echo -e "${LIGHTYELLOW}Please ensure Docker is started and you have permissions (e.g., current user in 'docker' group, or running commands with sudo).${RESET}"
        exit 1
    fi
    if docker ps -q --filter "name=^/${OPENGROK_CONTAINER_NAME}$" | grep -q .; then
        return 0
    else
        return 1
    fi
}

startOpenGrokIndexer() {
    # docker exec -it opengrok bash
    if ! isOpenGrokContainerRunning; then
        echo -e "${GREEN}✔${GREY} OpenGrok container ('${OPENGROK_CONTAINER_NAME}') is not running.${RESET}"
        return 0
    fi
    echo -e "${MAGENTA}Starting OpenGrok indexer...${RESET}"
    docker exec $OPENGROK_CONTAINER_NAME java \
    -Djava.util.logging.config.file=/opengrok/etc/logging.properties \
    -jar /opengrok/lib/opengrok.jar \
    -c /usr/local/bin/ctags \
    -s /opengrok/src \
    -d /opengrok/data \
    -H -P -S -G \
    -W /opengrok/etc/configuration.xml
}

stopOpenGrokContainer() {
    if ! isOpenGrokContainerRunning; then
        echo -e "${GREEN}✔${GREY} OpenGrok container ('${OPENGROK_CONTAINER_NAME}') is not running.${RESET}"
        return 0
    fi
    echo -e "${MAGENTA}Stopping OpenGrok Docker container...${RESET}"
    docker stop $OPENGROK_CONTAINER_NAME &> /dev/null
}

startOpenGrokContainer() {
    if isOpenGrokContainerRunning; then
        echo -e "${GREEN}✔${GREY} OpenGrok container ('${OPENGROK_CONTAINER_NAME}') is already running.${RESET}"
        echo -e "${LIGHTYELLOW}Access it at: ${BOLD}http://localhost:${OPENGROK_HOST_PORT}${RESET}"
        return 0
    fi

    echo -e "${MAGENTA}Deploying and starting OpenGrok Docker container...${RESET}"
    for dirPath in $OPENGROK_SRC_VOLUME $OPENGROK_DATA_VOLUME $OPENGROK_ETC_VOLUME; do
        if [ ! -d "$dirPath" ]; then
            echo -e "${GREY}Creating directory with sudo: ${BLUE}$dirPath${RESET}"
            if ! mkdir -p "$dirPath"; then
                echo -e "${RED}Error: Failed to create host directory ${BLUE}$dirPath${RED} with sudo.${RESET}"
                return 1
            fi
            echo -e "${GREEN}✔${GREY} Directory ${BLUE}$dirPath${GREY} created.${RESET}"
        fi
    done
    echo -e "${GREEN}✔${GREY} Host source directory ensured: ${BLUE}$OPENGROK_SRC_VOLUME${RESET}"
    echo -e "${LIGHTYELLOW}IMPORTANT: Place your source code repositories inside ${BOLD}$OPENGROK_SRC_VOLUME${LIGHTYELLOW} for OpenGrok to index.${RESET}"
    echo -e "${GREY}OpenGrok data and configuration will be stored in Docker managed volumes ('${OPENGROK_DATA_VOLUME}', '${OPENGROK_ETC_VOLUME}').${RESET}"

    # Check if container exists (but is stopped) and remove it to avoid conflicts
    if docker ps -aq --filter "name=^/${OPENGROK_CONTAINER_NAME}$" | grep -q .; then
        echo -e "${LIGHTYELLOW}Found existing stopped OpenGrok container ('${OPENGROK_CONTAINER_NAME}'). Removing it...${RESET}"
        if sudo docker rm "$OPENGROK_CONTAINER_NAME"; then
            echo -e "${GREEN}✔${GREY} Successfully removed existing container '${OPENGROK_CONTAINER_NAME}'.${RESET}"
        else
            echo -e "${RED}Error: Failed to remove existing container '${OPENGROK_CONTAINER_NAME}'.${RESET}"
            return 1
        fi
    fi

    # Pull the latest OpenGrok image
    echo -e "${LIGHTYELLOW}Checking for OpenGrok image (${OPENGROK_IMAGE_NAME})...${RESET}"
    if docker image inspect "$OPENGROK_IMAGE_NAME" &> /dev/null; then
        echo -e "${GREEN}✔${GREY} Image '${OPENGROK_IMAGE_NAME}' already exists locally.${RESET}"
    else
        echo -e "${LIGHTYELLOW}Pulling the latest OpenGrok image (${OPENGROK_IMAGE_NAME})...${RESET}"
        if ! docker pull "$OPENGROK_IMAGE_NAME"; then
            echo -e "${RED}Error: Failed to pull OpenGrok image '${OPENGROK_IMAGE_NAME}'.${RESET}"
            return 1
        fi
    fi
    echo -e "${GREEN}✔${GREY} Image '${OPENGROK_IMAGE_NAME}' pulled successfully.${RESET}"

    # Start the OpenGrok container
    echo -e "${LIGHTYELLOW}Starting OpenGrok container ('${OPENGROK_CONTAINER_NAME}')...${RESET}"
    local params=(
        run -d
        --name "$OPENGROK_CONTAINER_NAME"
        "--restart=unless-stopped"  # Restart the container automatically
        -e "NOMIRROR=yes"
        -p "127.0.0.1:${OPENGROK_HOST_PORT}:${OPENGROK_CONTAINER_PORT}/tcp" # Map host port to container port (localhost only)
        -v "${OPENGROK_SRC_VOLUME}:/opengrok/src:ro"  # Mount host source directory as read-only
        -v "${OPENGROK_DATA_VOLUME}:/opengrok/data"   # Use a named volume for OpenGrok data (indexes)
        -v "${OPENGROK_ETC_VOLUME}:/opengrok/etc"     # Use a named volume for OpenGrok configuration
        "$OPENGROK_IMAGE_NAME"
    )

    # The current user is in the 'docker' group
    echo -e "${GREY}Executing: docker ${params[*]}${RESET}"
    if docker "${params[@]}"; then
        echo -e "${GREEN}✔${GREY} OpenGrok container '${OPENGROK_CONTAINER_NAME}' started successfully.${RESET}"
        echo -e "${LIGHTYELLOW}It might take a few minutes for OpenGrok to initialize and index your source code from ${BOLD}$OPENGROK_SRC_VOLUME${LIGHTYELLOW}.${RESET}"
        echo -e "${LIGHTYELLOW}Once ready, access OpenGrok at: ${BOLD}http://localhost:${OPENGROK_HOST_PORT}${RESET}"
        echo -e "${LIGHTYELLOW}To view container logs: ${BLUE}docker logs -f ${OPENGROK_CONTAINER_NAME}${RESET}"
    else
        echo -e "${RED}Error: Failed to start OpenGrok container '${OPENGROK_CONTAINER_NAME}'.${RESET}"
        echo -e "${LIGHTYELLOW}Check container logs for details: ${BLUE}sudo docker logs ${OPENGROK_CONTAINER_NAME}${RESET}"
        return 1
    fi

    return 0
}

restartOpenGrokContainer() {
    stopOpenGrokContainer
    startOpenGrokContainer
}

addUserIntoLibvirtGrp() {
    echo -e "${COLOR}Configuring Libvirt group membership for current user ($USER)...${RESET}"

    if ! getent group libvirt > /dev/null; then
        echo -e "${RED}Error: The 'libvirt' group does not exist.${RESET}"
        echo -e "${LIGHTYELLOW}This might indicate that 'libvirt-daemon-system' or similar packages are not installed or not installed correctly.${RESET}"
        echo -e "${LIGHTYELLOW}Please verify libvirt installation. Skipping group membership addition.${RESET}"
        return 1
    fi

    if id -nG "$USER" | grep -qw libvirt; then
        echo -e "${GREEN}✔${GREY} User '$USER' is already a member of the 'libvirt' group.${RESET}"
        return 0
    fi

    echo -e "${LIGHTYELLOW}Attempting to add user '$USER' to the 'libvirt' group...${RESET}"
    if sudo usermod -aG libvirt "$USER"; then
        echo -e "${GREEN}Successfully added user '$USER' to the 'libvirt' group.${RESET}"
        echo -e "${BOLD}${MAGENTA}IMPORTANT: You must log out and log back in, or open a new shell session (or run 'newgrp libvirt'), for this group membership change to take effect.${RESET}"
    else
        echo -e "${RED}Failed to add user '$USER' to the 'libvirt' group.${RESET}"
        echo -e "${LIGHTYELLOW}Please try adding the user manually: ${BLUE}sudo usermod -aG libvirt $USER${RESET}"
        return 1
    fi

    return 0
}

installSambaServer() {
    echo -e "${COLOR}Starting Samba Server Installation/Configuration${RESET}"
    # Step 1: Check if Samba is already installed
    if command -v smbd &> /dev/null; then
        echo -e "${GREEN}✔${GREY} Samba (smbd) is already installed.${RESET}"
    else
        echo -e "${LIGHTYELLOW}Samba (smbd) not found. Attempting installation...${RESET}"
        if ! sudo apt update; then
            echo -e "${RED}Error: Failed to update apt package list. Aborting Samba installation.${RESET}"
            return 1
        fi
        if ! sudo DEBIAN_FRONTEND=noninteractive apt install -y samba smbclient; then
            echo -e "${RED}Error: Failed to install Samba packages. Aborting.${RESET}"
            return 1
        fi
        echo -e "${GREEN}Samba installed successfully.${RESET}"
    fi

    # Step 2: Configure Samba
    local sambaSysConfFile="/etc/samba/smb.conf"
    local mySambaConfSource="$fMainDir/assets/samba/ubuntu.smb.conf"
    if [ ! -f "$mySambaConfSource" ]; then
        echo -e "${RED}Error: Source Samba configuration file ('smb.conf') not found at ${BLUE}$mySambaConfSource${RESET}"
        echo -e "${LIGHTYELLOW}This script expects a custom 'smb.conf' to be present in the assets.${RESET}"
        exit 1
    fi
    linkFile "$mySambaConfSource" /etc/samba smb.conf
    echo -e "${LIGHTYELLOW}Validating Samba configuration with 'testparm'...${RESET}"
    if sudo testparm -s; then
        echo -e "${GREEN}✔${GREY} Samba configuration appears valid.${RESET}"
    else
        echo -e "${RED}Error: Samba configuration validation failed (testparm reported errors).${RESET}"
        echo -e "${LIGHTYELLOW}Please review '${BLUE}$sambaSysConfFile${LIGHTYELLOW}' and the output above.${RESET}"
        exit 1
    fi

    # Step 3: Create a dedicated Samba group and user
    local sambaShareGroup="sambashare"
    local sambaSysUser="smbowner" # A system user for file ownership
    if getent group "$sambaShareGroup" &>/dev/null; then
        echo -e "${GREEN}✔${GREY} Samba group '${sambaShareGroup}' already exists.${RESET}"
    else
        echo -e "${LIGHTYELLOW}Samba group '${sambaShareGroup}' does not exist. Creating it...${RESET}"
        if sudo groupadd "$sambaShareGroup"; then
            echo -e "${GREEN}✔${GREY} Group '${sambaShareGroup}' created successfully.${RESET}"
        else
            echo -e "${RED}Error: Failed to create group '${sambaShareGroup}'. Aborting.${RESET}"
            return 1
        fi
    fi

    # Create a dedicated system user for file ownership if it doesn't exist
    if id -u "$sambaSysUser" &>/dev/null; then
        echo -e "${GREEN}✔${GREY} System user '${sambaSysUser}' for file ownership already exists.${RESET}"
    else
        echo -e "${LIGHTYELLOW}System user '${sambaSysUser}' does not exist. Creating it...${RESET}"
        # -r: create a system account
        # -g: primary group
        # -M: do not create home directory
        # -s /usr/sbin/nologin: prevent interactive login
        if sudo useradd -r -g "$sambaShareGroup" -M -s /usr/sbin/nologin "$sambaSysUser"; then
            echo -e "${GREEN}✔${GREY} System user '${sambaSysUser}' created successfully.${RESET}"
        else
            echo -e "${RED}Error: Failed to create system user '${sambaSysUser}'.${RESET}"
            return 1
        fi
    fi

    # Add the current user to the Samba group
    if id -nG "$USER" | grep -qw "$sambaShareGroup"; then
        echo -e "${GREEN}✔${GREY} Current user '$USER' is already a member of the '${sambaShareGroup}' group.${RESET}"
    else
        echo -e "${LIGHTYELLOW}Adding current user '$USER' to the '${sambaShareGroup}' group...${RESET}"
        if sudo usermod -aG "$sambaShareGroup" "$USER"; then
            echo -e "${GREEN}Successfully added user '$USER' to the '${sambaShareGroup}' group.${RESET}"
            echo -e "${BOLD}${MAGENTA}NOTE: A re-login or new shell is required for this group change to take effect for the current session.${RESET}"
        else
            echo -e "${RED}Error: Failed to add user '$USER' to group '${sambaShareGroup}'.${RESET}"
            return 1
        fi
    fi

    # Set Samba password for the Samba user, who will be authenticating
    echo -e "${LIGHTYELLOW}Setting Samba password for user '${BOLD}$sambaSysUser${LIGHTYELLOW}'...${RESET}"
    local sambaPassword=""
    local sambaPasswordConfirm=""
    if [[ "$fSambaServer" != "2" ]]; then # Do not set password again
        while true; do
            echo -en "${LIGHTYELLOW}Enter new Samba password for user ${BOLD}$sambaSysUser${LIGHTYELLOW} (must not be empty): ${RESET}"
            read -r -s sambaPassword
            echo
            if [ -z "$sambaPassword" ]; then
                echo -e "${RED}Password cannot be empty. Please try again.${RESET}"
                continue
            fi
            echo -en "${LIGHTYELLOW}Confirm Samba password: ${RESET}"
            read -r -s sambaPasswordConfirm
            echo
            if [ "$sambaPassword" = "$sambaPasswordConfirm" ]; then
                break
            else
                echo -e "${RED}Passwords do not match. Please try again.${RESET}"
            fi
        done
        # Add/update the Samba user in Samba's database and set the password
        if (echo "$sambaPassword"; echo "$sambaPassword") | sudo smbpasswd -a "$sambaSysUser" -s; then
            echo -e "${GREEN}✔${GREY} Samba password for user '$sambaSysUser' set successfully.${RESET}"
        else
            echo -e "${RED}Error: Failed to set Samba password for user '$sambaSysUser'.${RESET}"
            echo -e "${LIGHTYELLOW}Ensure '$sambaSysUser' is a valid system user and you have sudo privileges.${RESET}"
            return 1
        fi
    fi

    # Step 4: Enable and start Samba services
    # local servicesToManage=("smbd" "nmbd")
    local servicesToManage=("smbd")
    local overallSuccess=true
    for service in "${servicesToManage[@]}"; do
        echo -e "${LIGHTYELLOW}Managing service: $service...${RESET}"
        if sudo systemctl restart "$service"; then
            echo -e "  ${GREEN}✔${GREY} $service restarted successfully.${RESET}"
        else
            echo -e "  ${RED}Error: Failed to restart $service.${RESET}"
            echo -e "  ${LIGHTYELLOW}Check with: sudo systemctl status $service && journalctl -xeu $service${RESET}"
            if [ "$service" == "smbd" ]; then
                overallSuccess=false;
            fi # Critical
        fi
        if sudo systemctl is-enabled "$service" | grep -q "enabled"; then
            echo -e "  ${GREEN}✔${GREY} $service is already enabled to start on boot.${RESET}"
        else
            if sudo systemctl enable "$service"; then
                echo -e "  ${GREEN}✔${GREY} $service enabled successfully for boot start.${RESET}"
            else
                echo -e "  ${RED}Error: Failed to enable $service for boot start.${RESET}"
                if [ "$service" == "smbd" ]; then
                    overallSuccess=false;
                fi # Critical
            fi
        fi
    done
    if [ "$overallSuccess" = false ]; then
        echo -e "${RED}Critical error managing Samba services. Aborting further Samba setup.${RESET}"
        exit 1
    fi

    # Step 5: Configuring Firewall (UFW)
    if command -v ufw &> /dev/null; then
        if sudo ufw status | grep -qw "Status: active"; then
            echo -e "${LIGHTYELLOW}UFW firewall is active. Checking/Adding rules for Samba...${RESET}"
            if sudo ufw status | grep -Ewq "Samba|ALLOW IN.*137,138/(udp|UDP)|ALLOW IN.*139,445/(tcp|TCP)"; then
                 echo -e "${GREEN}✔${GREY} UFW rule for 'Samba' or its specific ports already seems to exist or is allowed.${RESET}"
            else
                echo -e "${LIGHTYELLOW}Attempting to allow Samba through UFW (using 'samba' application profile)...${RESET}"
                if sudo ufw allow 445/tcp; then
                    echo -e "${GREEN}✔${GREY} UFW rule for Samba added successfully.${RESET}"
                    echo -e "${GREY}Current UFW status: ${RESET}"
                    sudo ufw status
                else
                    echo -e "${RED}Warning: Failed to add UFW rule for Samba using 'ufw allow samba'.${RESET}"
                    echo -e "${LIGHTYELLOW}You may need to manually allow TCP ports 445: sudo ufw allow 445/tcp${RESET}"
                fi
            fi
        else
            echo -e "${GREY}UFW firewall is installed but not active. Skipping UFW rule configuration.${RESET}"
        fi
    else
        echo -e "${GREY}UFW firewall manager not found. Skipping UFW configuration.${RESET}"
    fi

    # 6. Final message
    echo -e "\n${GREEN}--- Samba Server Installation/Configuration Process Completed ---${RESET}"
    echo -e "${LIGHTYELLOW}Summary:${RESET}"
    echo -e "  - Samba packages checked/installed."
    echo -e "  - Configuration '${BLUE}$sambaSysConfFile${LIGHTYELLOW}' applied/validated."
    echo -e "  - Samba password set for user '${BOLD}$sambaSysUser${LIGHTYELLOW}'."
    echo -e "  - Services ${servicesToManage[*]} restarted and enabled."
    echo -e "  - Firewall rules for Samba (if UFW active) checked/added."
    echo -e "\n${BOLD}${LIGHTYELLOW}Next Steps & Testing:${RESET}"
    echo -e "  1. Ensure your share definitions in '${BLUE}$sambaSysConfFile${LIGHTYELLOW}' are correct for your needs."
    echo -e "  2. Test connection from this machine: ${BLUE}smbclient -L localhost -U $sambaSysUser${RESET}"
    echo -e "     (You will be prompted for the Samba password you just set)."
    echo -e "  3. Test from another client machine on the network using this server's IP address."
    echo -e "     - ${BOLD}On Linux/macOS:${RESET}"
    echo -e "       - Example (list shares): ${BLUE}smbclient -L //SERVER_IP_ADDRESS -U $sambaSysUser${RESET}"
    echo -e "       - Example (connect to a share): ${BLUE}smbclient //SERVER_IP_ADDRESS/sharename -U $sambaSysUser${RESET}"
    echo -e "     - ${BOLD}On Windows:${RESET}"
    echo -e "       - In File Explorer, type ${BLUE}\\\\\\SERVER_IP_ADDRESS${RESET} in the address bar."
    echo -e "       - When prompted, use username '${BOLD}$sambaSysUser${RESET}' and the password you set."
    echo -e "     Or map a network drive via your client OS's file explorer."
    echo -e "  4. Remember to change the group ownership of the share directory to '${BOLD}$sambaSysUser${RESET}'."
    echo -e "     You can do this using the '${BLUE}chgrp -R $sambaSysUser /path/to/share/directory${RESET}' command."
    echo -e "${GREY}If issues arise, check Samba logs (e.g., 'journalctl -u smbd -u nmbd', '/var/log/samba/log.<client_hostname_or_ip>') and 'sudo smbstatus'.${RESET}"

    return 0
}

doCoreJobs() {
    updatePrerequisitesForDebian
    createTKSymlinks
    updateVimPlugins
    installTmuxPluginsManager
    createExtraSymlinks
    addUserIntoLibvirtGrp
    installDocker
    stopUnnecessaryServices
}

doEarlyExitJobs() {
    [ -n "$fLinkClangFormatPath" ]   && { linkClangFormat "$1"; exit 0; }
    [ -n "$fInstallDebFirefox" ]     && { installDebFirefox; exit 0; }
    [ -n "$fUpdateClangd" ]          && { installUpdateClangd; exit 0; }
    [ -n "$fRimePinyinInputMethod" ] && { installRimePinyinInputMethod; exit 0; }
    [ -n "$fSambaServer" ]           && { installSambaServer; exit 0; }
    case "$fVncServer" in
        1) startVncServer;       exit 0 ;;
        2) stopVncServer;        exit 0 ;;
        3) restartVncServer;     exit 0 ;;
    esac
    case "$fOpenGrokContainer" in
        1) startOpenGrokContainer;   exit 0 ;;
        2) stopOpenGrokContainer;    exit 0 ;;
        3) restartOpenGrokContainer; exit 0 ;;
        4) startOpenGrokIndexer;     exit 0 ;;
    esac
}

showUfwStatus() {
    if ! command -v ufw &> /dev/null || sudo ufw status | grep -qw "Status: inactive"; then
        return
    fi
    echo -e "${COLOR}Checking UFW Firewall Status...${RESET}"
    # echo -e "${BOLD}${LIGHTYELLOW}UFW Firewall Status:${RESET}"
    sudo ufw status verbose
    echo -e "${LIGHTYELLOW}Tip: Common UFW commands:${RESET}"
    echo -e "  ${GREY}- sudo ufw status        : Check if the firewall is active.${RESET}"
    echo -e "  ${GREY}- sudo ufw enable        : Enable the firewall.${RESET}"
    echo -e "  ${GREY}- sudo ufw disable       : Disable the firewall.${RESET}"
    echo -e "  ${GREY}- sudo ufw allow <port>  : Allow traffic on a specific port (e.g., sudo ufw allow 445/tcp).${RESET}"
    echo -e "  ${GREY}- sudo ufw deny <port>   : Deny traffic on a specific port.${RESET}"
    echo -e "  ${GREY}- sudo ufw delete allow <port>: Delete an allow rule (e.g., sudo ufw delete allow 445/tcp).\n${RESET}"
}

main() {
    doEarlyExitJobs "$1"
    checkOSCategory
    setupCoreDirectories
    if [ "$fOSCategory" == "debian" ]; then
        doCoreJobs
        buildBatTheme
        buildExtraFonts
        tackleTheExceptions
        setTimeZone
        changeTMOUTToWritable
        createFirstTimeFile
    elif [ "$fOSCategory" == "mac" ]; then # Deprecated
        createTKSymlinks
        installTmuxPluginsManager
        updateVimPlugins
        createExtraSymlinks
        buildBatTheme
        buildExtraFonts
    fi
    showUfwStatus
}

main "$@"
