#!/usr/bin/env python3
import os
import sys
import re
import subprocess
import argparse

# ANSI escape codes for colors defined at global scope
GREEN = '\033[92m'
RED = '\033[91m'
LIGHTYELLOW = '\033[93m'
GREY = '\033[90m'
BLUE = '\033[94m'
CYAN = '\033[96m'
MAGENTA = '\033[95m'
BOLD = '\033[1m'
UNDERLINE = '\033[4m'
RESET = '\033[0m'

class JDECODE:
    def __init__(self):
        self.script_name = os.path.basename(sys.argv[0])
        self.version = "0.2"
        self.exe_file_path = "./sysinit/init"
        self.crash_txt_path = "/data/bugzilla/crash.txt"
        self.decoded_output_path = "/data/bugzilla/crash_decoded.txt"
        self.write = False
        self.no_verbose = False
        self.parse_arguments()

    def parse_arguments(self):
        parser = argparse.ArgumentParser(
            prog=self.script_name,
            description=f"Crash Log Decoder v{self.version}\n\n"
                "Examples:\n"
                f"  {self.script_name} --exe ./sysinit/init --crash /data/bugzilla/crash.txt -v\n"
                f"  {self.script_name} --write",
            formatter_class=argparse.RawTextHelpFormatter,  # Preserves newlines in help text
            add_help=True
        )

        # Add arguments
        parser.add_argument('-e', '--exe', dest='exe_file_path', help='Path to the executable file')
        parser.add_argument('-i', '--input', dest='crash_txt_path', help='Path to the crash txt file')
        parser.add_argument('-o', '--output', dest='decoded_output_path', help='Path to the decoded output file')
        parser.add_argument('-w', '--write', dest='write', action='store_true', help='Write output to file')
        parser.add_argument('--no-verbose', dest='no_verbose', action='store_true', help='Disable verbose mode')

        # Parse arguments
        args = parser.parse_args()
        if args.exe_file_path:
            self.exe_file_path = args.exe_file_path
        if args.crash_txt_path:
            self.crash_txt_path = args.crash_txt_path
        if args.decoded_output_path:
            self.decoded_output_path = args.decoded_output_path
        if args.no_verbose:
            self.no_verbose = True
        if args.write:
            self.write = True

        # expanduser() expands '~' to the user's home directory
        self.exe_file_path = os.path.expanduser(self.exe_file_path)
        self.crash_txt_path = os.path.expanduser(self.crash_txt_path)
        self.decoded_output_path = os.path.expanduser(self.decoded_output_path)

    def verify_exe_file(self):
        print(f"\n{BOLD}❯ {CYAN}Verifying executable:{RESET} {GREEN}{self.exe_file_path}{RESET}")
        if not (os.path.exists(self.exe_file_path) and os.access(self.exe_file_path, os.X_OK)):
            print(f"{RED}✖ Error: {self.exe_file_path} does not exist or is not executable{RESET}")
            sys.exit(1)
        print(f"{GREY}✓ Executable verified successfully{RESET}")

    def start_decoding(self, pointer, f):
        cmd = ['gdb', self.exe_file_path, '-q', '-batch', '-nx', '-ex', 'list *' + pointer, '-ex', 'quit']
        try:
            result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        except Exception as e:
            print(f"{RED}✖ {e}{RESET}")
            sys.exit(1)

        if result.returncode == 0:
            # Split the output into lines
            lines = result.stdout.split('\n')

            # Print the first and middle lines if the verbose flag is set
            if lines:
                first_line = lines[0]
                middle_line_index = len(lines) // 2
                middle_line = lines[middle_line_index] if middle_line_index < len(lines) else ""

                combined_line = f"{MAGENTA}▶ {first_line}{RESET}"
                if not self.no_verbose and middle_line:
                    combined_line = f"{MAGENTA}▶ {first_line}{RESET}\n{BLUE}{middle_line}{RESET}"
                print(combined_line)
                if self.write:
                    f.write(f"{first_line}\n")
                    if not self.no_verbose and middle_line:
                        f.write(f"{middle_line}\n")
                    f.flush()
        else:
            print(f"{RED}✖ Error running GDB command:{RESET}")
            print(f"  {result.stderr}")

    def start_decoding_batch(self, pointers, f):
        """Batch decode multiple pointers, launching GDB only once."""
        if not pointers:
            return

        # Build batch commands
        # -q: quiet mode
        # -batch: batch mode
        # -nx: prevents GDB from reading the .gdbinit initialization file
        # -ex: executes gdb commands
        # -quit: exits GDB
        gdb_commands = []
        for pointer in pointers:
            gdb_commands.extend(['-ex', f'list *{pointer}'])
        gdb_commands.extend(['-ex', 'quit'])

        cmd = ['gdb', self.exe_file_path, '-q', '-batch', '-nx'] + gdb_commands

        try:
            result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        except Exception as e:
            print(f"{RED}✖ {e}{RESET}")
            return

        # import pdb; pdb.set_trace() # DEBUG
        if result.returncode == 0:
            # Process output line by line, detecting results of each list command
            all_lines = result.stdout.split('\n')
            current_block = []

            for line in all_lines:
                # GDB list command first line format: 0x... is in function_name (...)
                # Identify new parsing block by detecting lines starting with "0x" and containing " is in "
                if line.startswith('0x') and ' is in ' in line:
                    # If there's content, process the previous block first
                    if current_block:
                        self._process_gdb_output_block(current_block, f)
                    # Start a new block
                    current_block = [line]
                elif current_block:
                    # Continue adding to the current block (including code lines and empty lines)
                    current_block.append(line)

            # Process the last block
            if current_block:
                self._process_gdb_output_block(current_block, f)
        else:
            print(f"{RED}✖ Error running GDB command:{RESET}")
            print(f"  {result.stderr}")

    def _process_gdb_output_block(self, lines, f):
        """Processes a single GDB list command output block."""
        if not lines:
            return

        # Filter out empty lines
        non_empty_lines = [l for l in lines if l.strip()]
        if not non_empty_lines:
            return

        first_line = non_empty_lines[0]
        middle_line_index = len(non_empty_lines) // 2
        middle_line = non_empty_lines[middle_line_index] if middle_line_index < len(non_empty_lines) else ""

        combined_line = f"{MAGENTA}▶ {first_line}{RESET}"
        if not self.no_verbose and middle_line:
            combined_line = f"{MAGENTA}▶ {first_line}{RESET}\n{BLUE}{middle_line}{RESET}"
        print(combined_line)

        if self.write:
            f.write(f"{first_line}\n")
            if not self.no_verbose and middle_line:
                f.write(f"{middle_line}\n")
            f.flush()

    def read_crash_file(self):
        print(f"{BOLD}❯ {CYAN}Reading crash file:{RESET} {GREEN}{self.crash_txt_path}{RESET}")
        if not os.path.exists(self.crash_txt_path):
            print(f"{RED}✖ Error: '{self.crash_txt_path}' does not exist{RESET}")
            sys.exit(1)
        try:
            with open(self.crash_txt_path, "r") as f:
                lines = f.readlines()
                print(f"{GREY}✓ Found {len(lines)} lines in crash file{RESET}")
                return lines
        except Exception as e:
            print(f"{RED}✖ Error reading crash file: {e}{RESET}")
            sys.exit(1)

    # Function to check if a line contains a function pointer
    def extract_func_pointer(self, line):
        """
        Extracts the function pointer (file offset address) from a coredump log line.

        This function handles two main formats:
        1. Lines containing a runtime address and a base address, requiring calculation
           to derive the file offset.
           Example format:
           360: 2025-10-10 14:01:28 <01056> [0x55ca28364e54]  => /bin/wad {0x55ca26bfc000}
           Calculation method:
           0x55ca28364e54 (runtime address) - 0x55ca26bfc000 (base address) = 0x0000001768e54 (file offset)

        2. Lines directly providing the file offset address.
           Example format:
           462: 2025-01-06 11:34:55 <03432> [0x01e58bac] => wad_ips

        Args:
            line (str): A line string from the coredump log.

        Returns:
            str: The calculated or extracted file offset address (e.g., '0x1768e54'),
                 or an empty string if no valid address pattern is found.
        """
        # Case 1: The line contains a runtime address and a base address, requiring calculation.
        # Use regex to match [runtime address and {base address}
        match_calc = re.search(r'\[(0x[0-9a-fA-F]+)\]\s*=>\s*[^\{]*\{ *(0x[0-9a-fA-F]+) *\}', line)
        if match_calc:
            runtime_addr_str = match_calc.group(1)
            base_addr_str = match_calc.group(2)
            try:
                runtime_addr = int(runtime_addr_str, 16)
                base_addr = int(base_addr_str, 16)
                file_offset = runtime_addr - base_addr
                # Return the calculated file offset address as a hexadecimal string starting with '0x'.

                return hex(file_offset)
            except ValueError:
                # Theoretically, if the regex match is successful, a ValueError should not occur here.
                # As a robustness measure, return an empty string if conversion fails.
                return ""

        # Case 2: The line directly provides the file offset address.
        # Use regex to match [file offset address
        match_direct = re.search(r'\[(0x[0-9a-fA-F]+)\]\s*=>', line)
        if match_direct:
            file_offset_str = match_direct.group(1)
            return file_offset_str

        # If neither of the two patterns is matched, return an empty string.
        return ""

    def run(self):
        print(f"{BOLD}{CYAN}══════════════════════════════════════{RESET}")
        print(f"{BOLD}{CYAN} JDECODE CRASH LOG DECODER{RESET}")
        print(f"{BOLD}{CYAN}══════════════════════════════════════{RESET}")

        # Print arguments in a more structured way
        print(f"{BOLD}{LIGHTYELLOW}▼ Configuration{RESET}")
        print(f"  {BLUE}Write to file:{RESET}    {'Yes' if self.write else 'No'}")
        print(f"  {BLUE}Verbose mode :{RESET}    {'Yes' if not self.no_verbose else 'No'}")
        print(f"  {BLUE}Executable   :{RESET}    {self.exe_file_path}")
        print(f"  {BLUE}Crash log txt:{RESET}    {self.crash_txt_path}")
        if self.write:
            print(f"  {BLUE}Decoded Output:{RESET}   {self.decoded_output_path}")

        self.verify_exe_file()
        crash_lines = self.read_crash_file()

        f = None
        if self.write:
            # 'w+' will create the file if it doesn't exist
            try:
                print(f"{BOLD}❯ {CYAN}Preparing output file:{RESET} {GREEN}{self.decoded_output_path}{RESET}")
                output_dir = os.path.dirname(self.decoded_output_path)
                if output_dir and not os.path.exists(output_dir):
                    os.makedirs(output_dir)

                f = open(self.decoded_output_path, 'w+')
                print(f"{GREY}✓ Output file ready{RESET}")
            except Exception as e:
                print(f"{RED}✖ Error creating output file: {e}{RESET}")
                self.write = False

        print(f"\n{BOLD}❯ {CYAN}Extracting pointers...{RESET}")
        pointers = []
        non_pointer_lines = []

        for line in crash_lines:
            pointer = self.extract_func_pointer(line)
            if pointer != "":
                pointers.append(pointer)
            else:
                non_pointer_lines.append(line)

        print(f"{GREY}✓ Found {len(pointers)} pointers to decode{RESET}")

        print(f"\n{BOLD}❯ {CYAN}Starting batch decode process...{RESET}")
        print(f"{BOLD}{'─' * 50}{RESET}")

        # Process all pointers in batch
        pointer_count = len(pointers)
        self.start_decoding_batch(pointers, f)

        # Output non-pointer lines
        # for line in non_pointer_lines:
        #     print(f"  {line.strip()}")
        #     if self.write:
        #         f.write(line)
        #         f.flush()

        print(f"{BOLD}{'─' * 50}{RESET}")
        if self.write:
            f.close()
            print(f"\n{CYAN}✓ Done! {pointer_count} pointers decoded.{RESET}")
            print(f"  Output saved to: {BOLD}{self.decoded_output_path}{RESET}\n")
        else:
            print(f"\n{CYAN}✓ Completed! {pointer_count} pointers decoded.{RESET}\n")

# Entry point for the script
if __name__ == "__main__":
    jdecode = JDECODE()
    jdecode.run()
