#!/usr/bin/env python3
import os
import sys
import re
import subprocess
import argparse

# ANSI escape codes for colors defined at global scope
GREEN = '\033[92m'
RED = '\033[91m'
LIGHTYELLOW = '\033[93m'
GREY = '\033[90m'
BLUE = '\033[94m'
CYAN = '\033[96m'
MAGENTA = '\033[95m'
BOLD = '\033[1m'
UNDERLINE = '\033[4m'
RESET = '\033[0m'

class JDECODE:
    def __init__(self):
        self.scriptName = os.path.basename(sys.argv[0])
        self.version = "0.2"
        self.exeFilePath = "./sysinit/init"
        self.crashTxtPath = "/data/bugzilla/crash.txt"
        self.decodedOutputPath = "/data/bugzilla/crash_decoded.txt"
        self.listSize = 3
        self.write = False
        self.verboseLevel = "middle"
        self.parseArguments()

    def parseArguments(self):
        parser = argparse.ArgumentParser(
            prog=self.scriptName,
            description=(
                f"Crash Log Decoder v{self.version}\n\n"
                "Examples:\n"
                f"  {self.scriptName} --exe ./sysinit/init --crash /data/bugzilla/crash.txt -v\n"
                f"  {self.scriptName} --write\n"
                f"  {self.scriptName} --write -v all\n" # Show all source lines
                f"  {self.scriptName} -v backtrace\n"   # Show backtrace only
            ),
            formatter_class=argparse.RawTextHelpFormatter,
            add_help=True
        )

        # Add arguments
        parser.add_argument('-e', '--exe', dest='exeFilePath', help='Path to the executable file')
        parser.add_argument('-i', '--input', dest='crashTxtPath', help='Path to the crash txt file')
        parser.add_argument('-o', '--output', dest='decodedOutputPath', help='Path to the decoded output file')
        parser.add_argument('-l', '--list-size', dest='listSize', type=int, default=self.listSize, help=f'Number of source lines gdb will list by default is {self.listSize}')
        parser.add_argument('-w', '--write', dest='write', action='store_true', help='Write output to file')
        parser.add_argument('-v', '--verbose', dest='verboseLevel', type=str,
                    choices=['all', 'middle', 'backtrace'],
                    default=self.verboseLevel,
                    help='Verbose level: all=show all source lines, middle=show middle line only (default), backtrace=show backtrace only (no code)')

        # Parse arguments
        args = parser.parse_args()
        if args.exeFilePath:
            self.exeFilePath = args.exeFilePath
        if args.crashTxtPath:
            self.crashTxtPath = args.crashTxtPath
        if args.decodedOutputPath:
            self.decodedOutputPath = args.decodedOutputPath
        if args.listSize:
            self.listSize = args.listSize
        if args.verboseLevel:
            self.verboseLevel = args.verboseLevel
        if args.write:
            self.write = True

        # expanduser() expands '~' to the user's home directory
        self.exeFilePath = os.path.expanduser(self.exeFilePath)
        self.crashTxtPath = os.path.expanduser(self.crashTxtPath)
        self.decodedOutputPath = os.path.expanduser(self.decodedOutputPath)

    def verifyExeFile(self):
        print(f"\n❯ {CYAN}Verifying executable:{RESET} {GREEN}{self.exeFilePath}{RESET}")
        if not (os.path.exists(self.exeFilePath) and os.access(self.exeFilePath, os.X_OK)):
            print(f"{RED}✖ Error: {self.exeFilePath} does not exist or is not executable{RESET}")
            sys.exit(1)
        print(f"{GREY}✓ Executable verified successfully{RESET}")

    def startDecodingBatch(self, pointers, f):
        """Batch decode multiple pointers, launching GDB only once."""
        if not pointers:
            return

        # Build batch commands
        # -q: quiet mode
        # -batch: batch mode
        # -nx: prevents GDB from reading the .gdbinit initialization file
        # -ex: executes gdb commands
        # -quit: exits GDB
        gdbCommands = []

        # Only set listsize if we need to show code lines
        if self.verboseLevel != 'backtrace':
            gdbCommands.extend(['-ex', f'set listsize {self.listSize}'])

        for pointer in pointers:
            gdbCommands.extend(['-ex', f'list *{pointer}'])
        gdbCommands.extend(['-ex', 'quit'])

        cmd = ['gdb', self.exeFilePath, '-q', '-batch', '-nx'] + gdbCommands

        try:
            result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        except Exception as e:
            print(f"{RED}✖ {e}{RESET}")
            return

        # import pdb; pdb.set_trace() # DEBUG
        if result.returncode == 0:
            # Process output line by line, detecting results of each list command
            allLines = result.stdout.split('\n')
            currentBlock = []

            for line in allLines:
                # GDB list command first line format: 0x... is in function_name (...)
                # Identify new parsing block by detecting lines starting with "0x" and containing " is in "
                if line.startswith('0x') and ' is in ' in line:
                    # If there's content, process the previous block first
                    if currentBlock:
                        self._processGdbOutputBlock(currentBlock, f)
                    # Start a new block
                    currentBlock = [line]
                elif currentBlock:
                    # Continue adding to the current block (including code lines and empty lines)
                    currentBlock.append(line)

            # Process the last block
            if currentBlock:
                self._processGdbOutputBlock(currentBlock, f)
        else:
            print(f"{RED}✖ Error running GDB command:{RESET}")
            print(f"  {result.stderr}")

    def _processGdbOutputBlock(self, lines, f):
        """Processes a single GDB list command output block."""
        if not lines:
            return

        # Filter out empty lines
        nonEmptyLines = [l for l in lines if l.strip()]
        if not nonEmptyLines:
            return

        firstLine = nonEmptyLines[0]  # Backtrace info line (always show)
        displayLines = [f"{MAGENTA}▶ {firstLine}{RESET}"] # Initialize output lines (first line always included)
        writeLines = [firstLine]

        # Add additional lines based on verbose level
        if self.verboseLevel == 'backtrace':
            # Only show backtrace, no code lines
            pass  # No additional lines needed
        elif self.verboseLevel == 'middle':
            # Show backtrace + middle line only
            middleLineIndex = len(nonEmptyLines) // 2
            if middleLineIndex < len(nonEmptyLines):
                middleLine = nonEmptyLines[middleLineIndex]
                displayLines.append(f"{BLUE}{middleLine}{RESET}")
                writeLines.append(middleLine)
        elif self.verboseLevel == 'all':
            # Show all lines
            for line in nonEmptyLines[1:]:  # Skip first line (already added)
                displayLines.append(f"{BLUE}{line}{RESET}")
                writeLines.append(line)

        # Unified output
        for line in displayLines:
            print(line)

        if self.write:
            for line in writeLines:
                f.write(f"{line}\n")
            f.flush()

    def readCrashFile(self):
        print(f"❯ {CYAN}Reading crash file:{RESET} {GREEN}{self.crashTxtPath}{RESET}")
        if not os.path.exists(self.crashTxtPath):
            print(f"{RED}✖ Error: '{self.crashTxtPath}' does not exist{RESET}")
            sys.exit(1)
        try:
            with open(self.crashTxtPath, "r") as f:
                lines = f.readlines()
                print(f"{GREY}✓ Found {len(lines)} lines in crash file{RESET}")
                return lines
        except Exception as e:
            print(f"{RED}✖ Error reading crash file: {e}{RESET}")
            sys.exit(1)

    # Function to check if a line contains a function pointer
    def extractFuncPointer(self, line):
        """
        Extracts the function pointer (file offset address) from a coredump log line.

        This function handles two main formats:
        1. Lines containing a runtime address and a base address, requiring calculation
           to derive the file offset.
           Example format:
           360: 2025-10-10 14:01:28 <01056> [0x55ca28364e54]  => /bin/wad {0x55ca26bfc000}
           Calculation method:
           0x55ca28364e54 (runtime address) - 0x55ca26bfc000 (base address) = 0x0000001768e54 (file offset)

        2. Lines directly providing the file offset address.
           Example format:
           462: 2025-01-06 11:34:55 <03432> [0x01e58bac] => wad_ips

        Args:
            line (str): A line string from the coredump log.

        Returns:
            str: The calculated or extracted file offset address (e.g., '0x1768e54'),
                 or an empty string if no valid address pattern is found.
        """
        # Case 1: The line contains a runtime address and a base address, requiring calculation.
        # Use regex to match [runtime address and {base address}
        matchCalc = re.search(r'\[(0x[0-9a-fA-F]+)\]\s*=>\s*[^\{]*\{ *(0x[0-9a-fA-F]+) *\}', line)
        if matchCalc:
            runtimeAddrStr = matchCalc.group(1)
            baseAddrStr = matchCalc.group(2)
            try:
                runtimeAddr = int(runtimeAddrStr, 16)
                baseAddr = int(baseAddrStr, 16)
                fileOffset = runtimeAddr - baseAddr
                # Return the calculated file offset address as a hexadecimal string starting with '0x'.

                return hex(fileOffset)
            except ValueError:
                # Theoretically, if the regex match is successful, a ValueError should not occur here.
                # As a robustness measure, return an empty string if conversion fails.
                return ""

        # Case 2: The line directly provides the file offset address.
        # Use regex to match [file offset address
        matchDirect = re.search(r'\[(0x[0-9a-fA-F]+)\]\s*=>', line)
        if matchDirect:
            fileOffsetStr = matchDirect.group(1)
            return fileOffsetStr

        # If neither of the two patterns is matched, return an empty string.
        return ""

    def run(self):
        print(f"{CYAN}══════════════════════════════════════{RESET}")
        print(f"{CYAN} JDECODE CRASH LOG DECODER{RESET}")
        print(f"{CYAN}══════════════════════════════════════{RESET}")

        # Print arguments in a more structured way
        print(f"{BOLD}{LIGHTYELLOW}▼ Configuration{RESET}")
        print(f"  {BLUE}Write to file:{RESET}    {'Yes' if self.write else 'No'}")
        print(f"  {BLUE}Verbose mode :{RESET}    {self.verboseLevel}")
        print(f"  {BLUE}Executable   :{RESET}    {self.exeFilePath}")
        print(f"  {BLUE}Crash log txt:{RESET}    {self.crashTxtPath}")
        if self.write:
            print(f"  {BLUE}Decoded Output:{RESET}   {self.decodedOutputPath}")

        self.verifyExeFile()
        crashLines = self.readCrashFile()

        f = None
        if self.write:
            # 'w+' will create the file if it doesn't exist
            try:
                print(f"❯ {CYAN}Preparing output file:{RESET} {GREEN}{self.decodedOutputPath}{RESET}")
                outputDir = os.path.dirname(self.decodedOutputPath)
                if outputDir and not os.path.exists(outputDir):
                    os.makedirs(outputDir)

                f = open(self.decodedOutputPath, 'w+')
                print(f"{GREY}✓ Output file ready{RESET}")
            except Exception as e:
                print(f"{RED}✖ Error creating output file: {e}{RESET}")
                self.write = False

        print(f"\n❯ {CYAN}Extracting pointers...{RESET}")
        pointers = []
        nonPointerLines = []

        for line in crashLines:
            pointer = self.extractFuncPointer(line)
            if pointer != "":
                pointers.append(pointer)
            else:
                nonPointerLines.append(line)

        print(f"{GREY}✓ Found {len(pointers)} pointers to decode{RESET}")

        print(f"\n❯ {CYAN}Starting batch decode process...{RESET}")
        print(f"{BOLD}{'─' * 50}{RESET}")

        # Process all pointers in batch
        pointerCount = len(pointers)
        self.startDecodingBatch(pointers, f)

        # Output non-pointer lines
        # for line in nonPointerLines:
        #     print(f"  {line.strip()}")
        #     if self.write:
        #         f.write(line)
        #         f.flush()

        print(f"{BOLD}{'─' * 50}{RESET}")
        if self.write:
            f.close()
            print(f"\n{CYAN}✓ Done! {pointerCount} pointers decoded.{RESET}")
            print(f"  Output saved to: {BOLD}{self.decodedOutputPath}{RESET}\n")
        else:
            print(f"\n{CYAN}✓ Completed! {pointerCount} pointers decoded.{RESET}\n")

# Entry point for the script
if __name__ == "__main__":
    jdecode = JDECODE()
    jdecode.run()
