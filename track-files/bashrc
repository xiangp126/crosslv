#!/bin/bash
# shellcheck disable=SC2155 disable=SC1090 disable=SC1091 disable=SC2032

# Cache uname result once (avoid repeated forks)
_UNAME_S=$(uname -s)

# On macOS, always initialize Homebrew environment
if [[ $_UNAME_S == 'Darwin' ]]; then
    if [ -x /opt/homebrew/bin/brew ]; then
        eval "$(/opt/homebrew/bin/brew shellenv)"
    elif [ -x /usr/local/bin/brew ]; then
        eval "$(/usr/local/bin/brew shellenv)"
    fi
fi

# If not running interactively, don't do anything
[ -z "$PS1" ] && return

# don't put duplicate lines or lines starting with space in the history.
# See bash(1) for more options
HISTCONTROL=ignoreboth

# append to the history file, don't overwrite it
shopt -s histappend

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=2000
HISTFILESIZE=10000

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# If set, the pattern "**" used in a pathname expansion context will
# match all files and zero or more directories and subdirectories.
# shopt -s globstar

# export PS1="\u@${HOSTNAME:0:10}:\W\$ "
# Bash provides an environment variable called PROMPT_COMMAND.
# The contents of this variable are executed as a regular Bash command just before Bash displays a prompt.
# Pure bash version (no fork) - much faster on NFS
_prompt_shorten_path() {
    local p="${PWD/#$HOME/\~}"
    local result="" part
    local IFS='/'
    read -ra parts <<< "$p"
    local last_idx=$((${#parts[@]} - 1))
    for i in "${!parts[@]}"; do
        part="${parts[i]}"
        if [[ $i -eq $last_idx ]] || [[ -z "$part" ]]; then
            result+="$part"
        else
            # Keep first char (or first 2 if starts with dot)
            if [[ "$part" == .* ]]; then
                result+="${part:0:2}/"
            else
                result+="${part:0:1}/"
            fi
        fi
    done
    pwd2="$result"
}
PROMPT_COMMAND='_prompt_shorten_path'
PS1="${USER:0:3}@${HOSTNAME:0:11}:\${pwd2:0:30}\$ "

# Disable XON/XOFF software flow control to make <C-S> work in Vim.
stty -ixon

# Below is my own configuration.
# LS_COLORS="rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:\
#        cd=40;33;01:or=01;05;37;41:mi=01;05;37;41:su=37;41:sg=30;43:ca=30;41:tw=30;42"
# ow is other-writable, st is sticky
# export LS_COLORS=$LS_COLORS:'ex=0;0:ln=36:di=34:ow=01;90'
export LS_COLORS=$LS_COLORS:'ex=0;0:ln=36:di=34'

if [[ $_UNAME_S == 'Darwin' ]]; then
    alias ls='ls -G' # Compatible with Mac
elif [[ $_UNAME_S == 'Linux' ]]; then
    alias ls='ls --color=auto'
    alias dir='dir --color=auto'
    source /mswg/projects/fw/fw_ver/hca_fw_tools/.fwvalias # NV specific 1
fi
alias ll='ls -lF'
alias ll.='ls -alF'
alias rm='rm -i'
alias mv='mv -i'
alias cp='cp -i'
alias grep='grep -i --color=auto'
alias gdb='gdb -q'
alias rg='rg --smart-case --color=ansi'
alias tmux='tmux -u'
alias yt-dlp='yt-dlp --verbose'
alias youtube-dl='yt-dlp --external-downloader aria2c --external-downloader-args "-x 16 -s 16" -f "bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best" --write-auto-subs --sub-langs zh-Hans'
alias rsync='rsync -azPv'
alias jn='jr --no-clipboard'
# alias jm='jr --no-clipboard --kernel'
# alias jk='jr --kernel'
alias jk='jmake'

function __cd () {
    if [ -d "$1" ]; then
        cd "$1" || exit
    fi
}
alias cdg='__cd $HOME/myGit'
alias cdv='__cd $HOME/myGit/crosslv'
alias cdb='__cd $HOME/.usr/bin'
alias cdt='__cd $HOME/test'
alias cdT='__cd $HOME/Templates'
alias cdD='__cd $HOME/Downloads'
alias cdM='__cd $HOME/Media'
alias cdU='__cd $HOME/Uploads'
alias cdP='__cd $HOME/Public'
alias cdB='__cd /data/bugzilla'
alias cdL='__cd /data/bugzilla'
alias cdd='__cd /data'
alias cdf='__cd /data/fos'
alias cdo='__cd /opt'
alias cds='__cd /opt/src'
# NV specific 2
alias mss='sudo mst status -v'
alias cdw='__cd /auto/fwgwork1/pexiang/golan_fw'
alias cdN='__cd /auto/fwgwork1/pexiang/nicx'
for i in {2..3}; do
    # shellcheck disable=SC2139
    alias "cdw$i=__cd /auto/fwgwork1/pexiang/golan_fw$i"
done

# Print entry names without quotation marks
export QUOTING_STYLE=literal
export BAT_THEME=TwoDark

# Useful local variables.
unset LC_ALL
export LC_CTYPE=en_US.UTF-8
export LC_TIME=C  # 24-hour format (always available)
export LANG=en_US.UTF-8
export SSLKEYLOGFILE=~/.ssl-keys.log # Wireshark to decode SSL/TLS traffic
PKG_CONFIG_PATH=$HOME/.usr/lib/pkgconfig:/usr/local/lib/pkgconfig
LD_LIBRARY_PATH=/usr/lib:/usr/lib64:/usr/local/lib:/usr/local/lib64
LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$HOME/.usr/lib:$HOME/.usr/lib64
PATH="/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin"
# On macOS, add Homebrew paths
if [[ $_UNAME_S == 'Darwin' ]]; then
    PATH="/opt/homebrew/bin:/opt/homebrew/sbin:$PATH"
fi
if [ -d "$HOME/.usr/bin" ] && [[ ":$PATH:" != *":$HOME/.usr/bin:"* ]]; then
    PATH="$HOME/.usr/bin:$PATH"
fi
if [ -d "$HOME/.local/bin" ] && [[ ":$PATH:" != *":$HOME/.local/bin:"* ]]; then
    PATH="$HOME/.local/bin:$PATH"
fi
export PATH
export PKG_CONFIG_PATH
export LD_LIBRARY_PATH
unset TMOUT

# load system bash completion
if ! shopt -oq posix; then
  if [ -f /usr/share/bash-completion/bash_completion ]; then
    source /usr/share/bash-completion/bash_completion
  elif [ -f /etc/bash_completion ]; then
    source /etc/bash_completion
  fi
fi
# For macOS only, load Homebrew bash completion
if [[ $_UNAME_S == 'Darwin' ]]; then
    # Homebrew bash-completion@2 requires Bash 4.2+
    if [[ "${BASH_VERSINFO[0]}" -ge 5 || ("${BASH_VERSINFO[0]}" -eq 4 && "${BASH_VERSINFO[1]}" -ge 2) ]]; then
        if [[ -r "/opt/homebrew/share/bash-completion/bash_completion" ]]; then
            source "/opt/homebrew/share/bash-completion/bash_completion"
        elif [[ -r "/usr/local/share/bash-completion/bash_completion" ]]; then
            source "/usr/local/share/bash-completion/bash_completion"
        fi
    # Fallback to bash-completion@1 (for Bash 3.2)
    elif [[ -r "/opt/homebrew/etc/profile.d/bash_completion.sh" ]]; then
        source "/opt/homebrew/etc/profile.d/bash_completion.sh"
    elif [[ -r "/usr/local/etc/profile.d/bash_completion.sh" ]]; then
        source "/usr/local/etc/profile.d/bash_completion.sh"
    fi
fi
# Load custom bash completions (requires Bash 4.0+ for some scripts)
TK_COMPLETION_SELF="$HOME/.bash_completion.d"
if [ -d "$TK_COMPLETION_SELF" ] && [ "${BASH_VERSINFO[0]}" -ge 4 ]; then
    for file in "$TK_COMPLETION_SELF"/*; do
        [[ -f $file ]] && source "$file"
    done
fi
# Load xprofile - bash profile for X11
if [ -f ~/.xprofile ]; then
    source ~/.xprofile
fi
# Lazy load nvm - only initialize when needed (speeds up shell startup)
export NVM_DIR="$HOME/.nvm"
nvm() {
    unset -f nvm node npm npx
    [ -s "$NVM_DIR/nvm.sh" ] && source "$NVM_DIR/nvm.sh"
    [ -s "$NVM_DIR/bash_completion" ] && source "$NVM_DIR/bash_completion"
    nvm "$@"
}
node() { nvm use default &>/dev/null; unset -f node; node "$@"; }
npm() { nvm use default &>/dev/null; unset -f npm; npm "$@"; }
npx() { nvm use default &>/dev/null; unset -f npx; npx "$@"; }

# Settings for fzf -- the fuzzy finder
# Use fd (https://github.com/sharkdp/fd) instead of the default find
if command -v fd &> /dev/null; then
    FZF_DEFAULT_COMMAND="fd . \
                         --hidden \
                         --follow \
                         --no-ignore \
                         --exclude '.vscode-server' \
                         --exclude '.git' \
                         --exclude '.cache' \
                         --exclude '*.sw[p|o]' \
                         --exclude '*.[a|o]' \
                         --exclude '*.so' \
                        "
    FZF_DEFAULT_COMMAND=${FZF_DEFAULT_COMMAND//+([[:space:]])/ }
    FZF_ALT_C_COMMAND="fd . \
                       --type d \
                       --hidden \
                       --follow \
                       --no-ignore \
                       --exclude '.vscode-server' \
                       --exclude '.git' \
                       "
    FZF_ALT_C_COMMAND=${FZF_ALT_C_COMMAND//+([[:space:]])/ }
    export FZF_DEFAULT_COMMAND
    export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
    export FZF_ALT_C_COMMAND

    _fzf_compgen_path() {
        eval "$FZF_DEFAULT_COMMAND"
    }
    # Use fd to generate the list for directory completion
    _fzf_compgen_dir() {
        eval "$FZF_ALT_C_COMMAND"
    }
fi
export LINES=100
export FZF_TMUX_HEIGHT=60%
                #   --style default \
                #   --tmux center,95%,80% \
FZF_DEFAULT_OPTS="--layout=reverse \
                  --inline-info \
                  --color=fg+:247 \
                  --multi \
                  "
FZF_DEFAULT_OPTS=${FZF_DEFAULT_OPTS//+([[:space:]])/ }
export FZF_DEFAULT_OPTS
# Use \ as the trigger sequence instead of the default **. Followed by a TAB
export FZF_COMPLETION_TRIGGER='*'
# Options to fzf command
export FZF_COMPLETION_OPTS='+c -x'

# Load customized code wrapper (supports both VS Code and Cursor)
{ [ -d "$HOME/.vscode-server/cli/servers" ] || [ -d "$HOME/.cursor-server" ]; } && \
  [ -f "$HOME/Templates/code-function.sh" ] && source ~/Templates/code-function.sh

# For fzf-tab-completion vim plugin (requires Bash 4.0+)
if [ "${BASH_VERSINFO[0]}" -ge 4 ]; then
    bind -r "\\\t"
    bind -x '"\\\t": fzf_bash_completion'
fi
