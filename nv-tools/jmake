#!/usr/bin/env bash
# shellcheck disable=SC2155 disable=SC2120 disable=SC2024
# set -x

# Build flags & Options
fBuildModel=
fBuildCommand=
fBuildAll=
fLoopModels=
fLoopVerifiedModels=()
fLoopCurrentModel=
fLoopPendingModels=()
fNumOfJobs=$(nproc)
fWorkingDir=$(pwd)
fMaxBuildAttempt=1
fGenerateCompileCmds=
fLinkCompileDb=
fNeedBuild=
fPrintBuildFlags=
fClean=
fGitClean=
fNoVerbose=
fInputCmd=
fBuildTimeFormatted=
# Git associated variables
fCompileCommandsJson="compile_commands.json"
fRMCompileCommandsJson=

# Common Constants
SEPARATOR="==================================================="
SCRIPT_NAME=$(basename $0)
# Colors
CYAN='\033[36m'
RED='\033[31m'
BOLD='\033[1m'
GREEN='\033[32m'
MAGENTA='\033[35m'
BLUE='\033[34m'
GREY='\033[90m'
YELLOW='\033[33m'
LIGHTYELLOW='\033[93m'
RESET='\033[0m'
COLOR=$MAGENTA
USER_NOTATION="${CYAN}▸${RESET}"

# GOLAN supported models
GOLAN_MODELS="arava viper tamar carmel mustang gilboa argaman alpine"
DEFAULT_MODEL="mustang"

# https://patorjk.com/software/taag/
showLogo() {
    cat << _EOF
      _              __
     (_)__ _  ___ _ / /__ ___
    / //  ' \/ _ '//  '_// -_)
 __/ //_/_/_/\_,_//_/\_\ \__/
|___/
_EOF
}

usage() {
    cat << _EOF
Usage: $SCRIPT_NAME [OPTIONS]

Build tool for NVIDIA golan_fw firmware.

Build Flags:
    -D, --debug                 Enable debug mode
    -c, --clean                 Run make clean (./build.sh -C)
        --clean-db              Also remove $fCompileCommandsJson during clean
        --git-clean             Deep clean using git clean -fdx (preserves submodules)
    -o, --build                 Run build commands
        --no-verbose            Suppress full compilation output (default: verbose)

Build Options:
    -a, --all                   Build all models (no -d flag to build.sh)
    -b, --bear                  Generate compile_commands.json (implies -c --clean-db -o)
    -m, --model                 Set the build model (default: $DEFAULT_MODEL)
        --loop                  Loop through all models and execute command for each
    -j, --jobs                  Set the number of parallel jobs (default: $fNumOfJobs)
    -w, --working-dir           Set working directory (default: current dir)
    --max-attempt               Set max build attempts (default: $fMaxBuildAttempt)

Other Options:
    -h, --help                  Print this help message
    -l, --list                  List available models
        --link                  Link compile_commands.json for clangd (use with -m)

Supported Models:
    $GOLAN_MODELS

Examples:
    $SCRIPT_NAME -o                        # Build mustang (default, verbose)
    $SCRIPT_NAME -a                        # Build all models (single build.sh invocation)
    $SCRIPT_NAME --loop                    # Loop build each model one by one
    $SCRIPT_NAME -c -o                     # Clean and build mustang
    $SCRIPT_NAME --no-verbose -o           # Build with quiet mode
    $SCRIPT_NAME -b -m gilboa              # Build gilboa with compile_commands.json

_EOF
    exit 0
}

[[ $# -eq 0 ]] && usage
fInputCmd="$SCRIPT_NAME $*"

# Detect and use GNU getopt if available (required for long options on macOS)
GETOPT_BIN="getopt"
if command -v /opt/homebrew/opt/gnu-getopt/bin/getopt &> /dev/null; then
    GETOPT_BIN="/opt/homebrew/opt/gnu-getopt/bin/getopt"
elif command -v /usr/local/opt/gnu-getopt/bin/getopt &> /dev/null; then
    GETOPT_BIN="/usr/local/opt/gnu-getopt/bin/getopt"
fi

SHORTOPTS="hcoam:j:w:Dlb"
LONGOPTS="help,clean,debug,bear,build,clean-db,git-clean,model:,jobs:,working-dir:,max-attempt:,no-verbose,list,link,all,loop"

if ! PARSED=$("$GETOPT_BIN" --options $SHORTOPTS --longoptions $LONGOPTS --name "$0" -- "$@"); then
    echo -e "${MAGENTA}Error: Failed to parse command-line options.${RESET}" >&2
    exit 1
fi

eval set -- "$PARSED"

while true; do
    case "$1" in
        -h|--help)
            usage
            shift
            ;;
        -D|--debug)
            set -x
            shift
            ;;
        -m|--model)
            fBuildModel="$2"
            fNeedBuild=true
            shift 2
            ;;
        -w|--working-dir)
            fWorkingDir="$2"
            fNeedBuild=true
            shift 2
            ;;
        -j|--jobs)
            fNumOfJobs="$2"
            fNeedBuild=true
            shift 2
            ;;
        --max-attempt)
            fMaxBuildAttempt="$2"
            fNeedBuild=true
            shift 2
            ;;
        -o|--build)
            fNeedBuild=true
            shift
            ;;
        -c|--clean)
            fClean=true
            shift
            ;;
        --clean-db)
            fClean=true
            fRMCompileCommandsJson=true
            shift
            ;;
        --git-clean)
            fGitClean=true
            fClean=true
            shift
            ;;
        -b|--bear)
            fGenerateCompileCmds=true
            fNeedBuild=true
            fClean=true
            fRMCompileCommandsJson=true  # -b/--bear implies -c --clean-db -o
            shift
            ;;
        --no-verbose)
            fNoVerbose=true
            shift
            ;;
        -l|--list)
            echo -e "${BOLD}Available models:${RESET}"
            echo -e "${GREEN}$GOLAN_MODELS${RESET}"
            exit 0
            ;;
        --link)
            fLinkCompileDb=true
            shift
            ;;
        -a|--all)
            fBuildAll=true
            fNeedBuild=true
            shift
            ;;
        --loop)
            fLoopModels=true
            fNeedBuild=true
            shift
            ;;
        --)
            shift
            break
            ;;
        *)
            echo -e "$USER_NOTATION ${MAGENTA}Invalid option: $1${RESET}"
            exit 1
            ;;
    esac
done

if [[ $# -gt 0 ]]; then
    echo -e "$USER_NOTATION ${COLOR}Illegal non-option arguments: $*${RESET}"
    exit 1
fi

# Auto-set flags:
# --bear implies -o and -C (already set above)

getCurrentTime() {
    COLOR="$RED"
    echo -e "${COLOR}$(date +"%m/%d/%Y %H:%M:%S")${RESET}"
}

# $1: available models, $2: target model
searchBuildModel() {
    matchedModels=()
    local availModels="$1"
    local targetModel="$2"

    for model in $availModels; do
        if [[ "$model" == *"$targetModel"* ]]; then
            matchedModels+=("$model")
            if [[ "$model" == "$targetModel" ]]; then
                fBuildModel="$model"
            fi
        fi
    done

    COLOR="$RED"
    case ${#matchedModels[@]} in
        0)
            echo -e "$USER_NOTATION No matched model found for ${COLOR}$targetModel${RESET}"
            echo -e "$USER_NOTATION Available models: ${CYAN}$GOLAN_MODELS${RESET}"
            exit 1
            ;;
        1)
            fBuildModel="${matchedModels[0]}"
            ;;
        *)
            echo "$USER_NOTATION Multiple matched models found for $targetModel"
            echo "$USER_NOTATION Please specify the model from the following list:"
            for model in "${matchedModels[@]}"; do
                echo -e "${COLOR}$model${RESET}"
            done
            exit 1
            ;;
    esac
}

preConfigure() {
    [ -n "$fClean" ] || [ -n "$fNeedBuild" ] || [ -n "$fGenerateCompileCmds" ] || [ -n "$fRMCompileCommandsJson" ] || [ -n "$fLinkCompileDb" ] && fPrintBuildFlags=true
    [ -z "$fPrintBuildFlags" ] && return

    fWorkingDir=$(realpath "$fWorkingDir")
    cd "$fWorkingDir" || exit 1

    # Verify this is a golan_fw project
    if [[ ! -x "./build.sh" ]]; then
        echo -e "$USER_NOTATION ${RED}Error: build.sh not found. Are you in a golan_fw directory?${RESET}"
        exit 1
    fi

    # Skip model configuration if building all
    if [ -n "$fBuildAll" ]; then
        return
    fi

    # Lower case the build model
    fBuildModel=$(echo "$fBuildModel" | tr '[:upper:]' '[:lower:]')
    if [ -z "$fBuildModel" ]; then
        fBuildModel="$DEFAULT_MODEL"
    else
        searchBuildModel "$GOLAN_MODELS" "$fBuildModel"
    fi
}

printBuildFlags() {
    echo $SEPARATOR
    if [ -n "$fPrintBuildFlags" ]; then
        COLOR="$GREEN"
        echo -e "${BOLD}Build Flags:${RESET}"
        [ -n "$fClean" ]                 && echo -e "[C] ${COLOR}Clean${RESET} the build"
        [ -n "$fGitClean" ]              && echo -e "[G] ${COLOR}Git deep clean${RESET} (git clean -fdx)"
        [ -n "$fNeedBuild" ]             && echo -e "[o] ${COLOR}Build${RESET} the project"
        [ -n "$fNoVerbose" ]             && echo -e "[V] ${COLOR}No Verbose${RESET} mode"
        [ -n "$fRMCompileCommandsJson" ] && echo -e "[/] ${COLOR}Remove${RESET} existing $fCompileCommandsJson"
        [ -n "$fGenerateCompileCmds" ]   && echo -e "[g] ${COLOR}Generate${RESET} compile_commands.json"
        [ -n "$fLinkCompileDb" ]         && echo -e "[L] ${COLOR}Link${RESET} compile_commands.json for clangd"
    fi

    if [ -n "$fNeedBuild" ]; then
        echo -e "${BOLD}Build Options:${RESET}"
        COLOR="$RED"
        if [ -n "$fLoopModels" ]; then
            echo -e "[L] Build Mode:   ${COLOR}LOOP (all models one by one)${RESET}"
        elif [ -n "$fBuildAll" ]; then
            echo -e "[a] Build Model:  ${COLOR}ALL${RESET}"
        else
            echo -e "[m] Build Model:  ${COLOR}$fBuildModel${RESET}"
        fi
        COLOR="$CYAN"
        echo -e "[w] Build Directory: ${COLOR}$fWorkingDir${RESET}"
        echo -e "[T] Maximum Build Attempts: ${COLOR}$fMaxBuildAttempt${RESET}"
        echo -e "[j] Parallel Jobs: ${COLOR}$fNumOfJobs${RESET}"
    fi
    echo "$SEPARATOR"
    echo -en "${BOLD}Input Command: ${RESET}" >&2
    echo -e "${LIGHTYELLOW}$fInputCmd${RESET}" >&2
}

cleanTheRepo() {
    [ -z "$fClean" ] && return
    cd "$fWorkingDir" || exit
    echo -e "$USER_NOTATION ${CYAN}Cleaning the build...${RESET}"

    if [ -n "$fGitClean" ]; then
        # Deep clean using git clean -fdx
        echo -e "$USER_NOTATION ${CYAN}Deep cleaning with git clean -fdx...${RESET}"
        
        # Build exclude options
        # Always exclude *.code-workspace files by default
        local excludeOpts="--exclude=*.code-workspace"
        if [ -z "$fRMCompileCommandsJson" ]; then
            if [ -L "$fCompileCommandsJson" ]; then
                # It's a symlink, exclude the real file instead of the symlink itself
                realFile=$(readlink -f "$fCompileCommandsJson")
                excludeOpts="$excludeOpts --exclude=$(basename "$realFile")"
            else
                excludeOpts="$excludeOpts --exclude=$fCompileCommandsJson"
            fi
        fi
        
        local cleanCmd="git clean -fdx $excludeOpts"
        echo -e "$USER_NOTATION Running: ${BLUE}$cleanCmd${RESET}"
        eval "$cleanCmd"
        
        # Also clean submodules
        echo -e "$USER_NOTATION ${CYAN}Cleaning submodules...${RESET}"
        git submodule foreach --recursive git clean -fdx "$excludeOpts"
        
        echo -e "$USER_NOTATION ${MAGENTA}Deep clean completed.${RESET}"
    else
        # Standard make clean
        local cleanCmd="./build.sh -C"
        echo -e "$USER_NOTATION Running: ${BLUE}$cleanCmd${RESET}"
        sleep 1
        COLOR=$MAGENTA
        eval "$cleanCmd"
        if [[ $? -ne 0 ]]; then
            echo -e "$USER_NOTATION ${COLOR}There seems to be some errors during the clean process${RESET}"
            echo -e "$USER_NOTATION ${RESET}But going on anyway${RESET}"
        else
            echo -e "$USER_NOTATION ${COLOR}Cleaned the build successfully.${RESET}"
        fi

        # Remove compile_commands.json if requested
        if [ -n "$fRMCompileCommandsJson" ]; then
            if [ -L "$fCompileCommandsJson" ]; then
                # It's a symlink - remove both the symlink and the real file it points to
                local realFile
                realFile=$(readlink -f "$fCompileCommandsJson")
                echo -e "$USER_NOTATION Removing symlink ${CYAN}$fCompileCommandsJson${RESET}"
                rm -f "$fCompileCommandsJson"
                if [ -f "$realFile" ]; then
                    echo -e "$USER_NOTATION Removing real file ${CYAN}$realFile${RESET}"
                    rm -f "$realFile"
                fi
            elif [ -f "$fCompileCommandsJson" ]; then
                # It's a regular file - just remove it
                echo -e "$USER_NOTATION Removing ${CYAN}$fCompileCommandsJson${RESET}"
                rm -f "$fCompileCommandsJson"
            fi
        fi
    fi
}

updateSubmodules() {
    # Only update submodules when building
    [ -z "$fNeedBuild" ] && return
    cd "$fWorkingDir" || exit

    # Check if submodules are initialized by looking for a key file
    if [[ ! -f "shared/glib/glib.mak" ]]; then
        echo -e "$USER_NOTATION ${CYAN}Initializing submodules with: ${YELLOW}git submodule update --init --recursive${RESET}"
        eval "git submodule update --init --recursive"
    else
        echo -e "$USER_NOTATION ${CYAN}Updating submodules with: ${YELLOW}git submodule update --recursive${RESET}"
        eval "git submodule update --recursive"
    fi

    if [[ $? -ne 0 ]]; then
        echo -e "$USER_NOTATION ${RED}Error: Submodule update failed${RESET}"
        exit 1
    else
        echo -e "$USER_NOTATION ${GREEN}Submodules updated successfully.${RESET}"
    fi
}

printLoopStatusChart() {
    echo "$SEPARATOR"
    echo -e "$USER_NOTATION ${BOLD}${RED}Build Failed - Loop Status Chart:${RESET}"
    echo -e "$USER_NOTATION ${RED}✗ Failed:${RESET}      $fLoopCurrentModel"
    if [[ ${#fLoopVerifiedModels[@]} -gt 0 ]]; then
        echo -e "$USER_NOTATION ${GREEN}✓ Verified:${RESET}    ${fLoopVerifiedModels[*]}"
    else
        echo -e "$USER_NOTATION ${GREEN}✓ Verified:${RESET}    (none)"
    fi
    if [[ ${#fLoopPendingModels[@]} -gt 0 ]]; then
        echo -e "$USER_NOTATION ${YELLOW}○ Pending:${RESET}     ${fLoopPendingModels[*]}"
    else
        echo -e "$USER_NOTATION ${YELLOW}○ Pending:${RESET}     (none)"
    fi
    echo "$SEPARATOR"
}

makeBuildCommand() {
    fBuildCommand="./build.sh"
    [ -z "$fBuildAll" ] && fBuildCommand+=" -d $fBuildModel"
    fBuildCommand+=" -c $fNumOfJobs"
    [ -z "$fNoVerbose" ] && fBuildCommand+=" --verbose"
    [ -n "$fGenerateCompileCmds" ] && fBuildCommand+=" --bear"
}

runBuildCommands() {
    [ -z "$fNeedBuild" ] && return
    cd "$fWorkingDir" || exit

    makeBuildCommand # set fBuildCommand

    local currAttempt=1
    local maxAttempt=$fMaxBuildAttempt
    local buildStartTime buildEndTime
    local eval_status=1

    while [[ $currAttempt -le $maxAttempt ]]; do
        buildStartTime=$(date +%s)
        COLOR="$GREEN"
        echo -e "$USER_NOTATION Running: ${LIGHTYELLOW}$fBuildCommand${RESET}"
        echo -e "$USER_NOTATION ${COLOR}Build attempt $currAttempt/$maxAttempt${RESET}"
        sleep 1

        eval "$fBuildCommand"
        eval_status=$?

        if [[ $eval_status -eq 0 ]]; then
            break
        else
            currAttempt=$((currAttempt + 1))
        fi
    done
    buildEndTime=$(date +%s)

    if [[ $eval_status -ne 0 ]]; then
        COLOR="$MAGENTA"
        echo -e "$USER_NOTATION ${COLOR}Build failed. Please search for 'error:' in the build output.${RESET}"
        [ -n "$fLoopModels" ] && printLoopStatusChart
        exit 1
    fi

    local buildTime=$((buildEndTime - buildStartTime))
    local hours=$((buildTime / 3600))
    local minutes=$((buildTime % 3600 / 60))
    local seconds=$((buildTime % 60))
    fBuildTimeFormatted="${seconds}s"

    if [[ $minutes -gt 0 ]]; then
        fBuildTimeFormatted="${minutes}m${fBuildTimeFormatted}"
    fi

    if [[ $hours -gt 0 ]]; then
        fBuildTimeFormatted="${hours}h${fBuildTimeFormatted}"
    fi

    echo -e "$USER_NOTATION Build completed successfully at $(getCurrentTime) in $fBuildTimeFormatted"
}

runLoopModels() {
    [ -z "$fLoopModels" ] && return 1
    
    local totalStartTime=$(date +%s)
    local allModels=($GOLAN_MODELS)
    
    echo -e "$USER_NOTATION ${BOLD}${CYAN}Starting loop build for all models...${RESET}"
    echo "$SEPARATOR"
    
    for i in "${!allModels[@]}"; do
        local model="${allModels[$i]}"
        
        # Set current model and calculate pending models
        fLoopCurrentModel="$model"
        fLoopPendingModels=("${allModels[@]:$((i+1))}")
        fBuildModel="$model"
        
        echo -e "$USER_NOTATION ${BOLD}Current building model: ${GREEN}$model${RESET}"
        
        runBuildCommands  # exits on failure with status chart
        
        # If we get here, build succeeded
        fLoopVerifiedModels+=("$model")
        echo -e "$USER_NOTATION ${GREEN}✓ $model build succeeded${RESET}"
        echo "$SEPARATOR"
    done
    
    local totalEndTime=$(date +%s)
    local totalTime=$((totalEndTime - totalStartTime))
    local hours=$((totalTime / 3600))
    local minutes=$((totalTime % 3600 / 60))
    local seconds=$((totalTime % 60))
    local totalTimeFormatted="${seconds}s"
    [[ $minutes -gt 0 ]] && totalTimeFormatted="${minutes}m${totalTimeFormatted}"
    [[ $hours -gt 0 ]] && totalTimeFormatted="${hours}h${totalTimeFormatted}"
    
    echo -e "$USER_NOTATION ${BOLD}Loop Build Summary:${RESET}"
    echo -e "$USER_NOTATION Total time: ${CYAN}$totalTimeFormatted${RESET}"
    echo -e "$USER_NOTATION ${GREEN}All ${#fLoopVerifiedModels[@]} models verified:${RESET} ${fLoopVerifiedModels[*]}"
    return 0
}

linkCompileDatabase() {
    [ -z "$fGenerateCompileCmds" ] && [ -z "$fLinkCompileDb" ] && return
    # Skip linking when building all models (no single model-specific database)
    if [ -n "$fBuildAll" ]; then
        echo -e "$USER_NOTATION ${GREY}Skipping compile database link (building all models)${RESET}"
        return
    fi
    cd "$fWorkingDir" || exit

    local dbFile="bin/build_tools/compile_db/compile_commands_${fBuildModel}_irisc.json"
    local targetLink="$fWorkingDir/compile_commands.json"
    local clangdSource="/labhome/pexiang/myGit/crosslv/assets/.clangd"
    local clangdTarget="$fWorkingDir/.clangd"

    # Link compile_commands.json
    # Skip if link already exists and points to correct target (only for --link, not --bear)
    if [ -n "$fLinkCompileDb" ] && [ -z "$fGenerateCompileCmds" ]; then
        if [[ -L "$targetLink" && "$(readlink "$targetLink")" == "$dbFile" ]]; then
            echo -e "$USER_NOTATION ${GREEN}Link already exists:${RESET} compile_commands.json -> $dbFile"
        else
            if [[ -f "$dbFile" ]]; then
                echo -e "$USER_NOTATION ${CYAN}Linking compile database for clangd...${RESET}"
                ln -sf "$dbFile" "$targetLink"
                echo -e "$USER_NOTATION Created: ${GREEN}compile_commands.json${RESET} -> ${BLUE}$dbFile${RESET}"
            else
                echo -e "$USER_NOTATION ${RED}Warning: Compile database not found: $dbFile${RESET}"
            fi
        fi
    else
        if [[ -f "$dbFile" ]]; then
            echo -e "$USER_NOTATION ${CYAN}Linking compile database for clangd...${RESET}"
            ln -sf "$dbFile" "$targetLink"
            echo -e "$USER_NOTATION Created: ${GREEN}compile_commands.json${RESET} -> ${BLUE}$dbFile${RESET}"
        else
            echo -e "$USER_NOTATION ${RED}Warning: Compile database not found: $dbFile${RESET}"
        fi
    fi

    # Link .clangd config
    if [[ -L "$clangdTarget" && "$(readlink "$clangdTarget")" == "$clangdSource" ]]; then
        echo -e "$USER_NOTATION ${GREEN}Link already exists:${RESET} .clangd -> $clangdSource"
    elif [[ -f "$clangdSource" ]]; then
        ln -sf "$clangdSource" "$clangdTarget"
        echo -e "$USER_NOTATION Created: ${GREEN}.clangd${RESET} -> ${BLUE}$clangdSource${RESET}"
    else
        echo -e "$USER_NOTATION ${RED}Warning: .clangd config not found: $clangdSource${RESET}"
    fi
}

removeWriteFromJson() {
    [ -z "$fNeedBuild" ] && return
    # Skip when building all models
    [ -n "$fBuildAll" ] && return
    cd "$fWorkingDir" || exit

    # Operate on the actual target file, not the symlink
    local dbFile="bin/build_tools/compile_db/compile_commands_${fBuildModel}_irisc.json"
    if [[ -f "$dbFile" ]]; then
        if [[ -w "$dbFile" ]]; then
            echo -e "$USER_NOTATION ${CYAN}Removing write privilege from ${YELLOW}$dbFile${RESET}"
            chmod u-w "$dbFile"
        else
            echo -e "$USER_NOTATION ${GREY}$dbFile is already read-only${RESET}"
        fi
    fi
}

main() {
    preConfigure "$@"
    showLogo
    printBuildFlags
    cleanTheRepo
    updateSubmodules
    # Handle loop mode or regular build
    if [ -n "$fLoopModels" ]; then
        runLoopModels
    else
        runBuildCommands
    fi
    linkCompileDatabase
    removeWriteFromJson
}

main "$@"
