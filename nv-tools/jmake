#!/bin/bash
# set -x

# Platform: GOLAN (default) or FORTINET (reserved for future use)
fPlatform="GOLAN"

# Build flags & Options
fBuildModel=
fNumOfJobs=$(nproc)
fWorkingDir=$(pwd)
fMaxBuildAttempt=1
fGenerateCompileCmds=
fLinkCompileDb=
fNeedBuild=
fPrintBuildFlags=
fClean=
fGitClean=
fVerbose=true
fInputCmd=
fBuildTimeFormatted=
# Git associated variables
fCompileCommandsJson="compile_commands.json"
fRMCompileCommandsJson=

# Fortinet-specific variables (reserved for future use)
fPoundPattern='#\s*$'
ftntUser=
ftntPasswd=
fRunConfigure=
fSyncTarget=
fSyncFile=
fSyncPort=22
fSyncUsername="admin"
fSyncPassword="password"

# Common Constants
SEPARATOR="==================================================="
SCRIPT_NAME=$(basename $0)
# Colors
CYAN='\033[36m'
RED='\033[31m'
BOLD='\033[1m'
GREEN='\033[32m'
MAGENTA='\033[35m'
BLUE='\033[34m'
GREY='\033[90m'
LIGHTYELLOW='\033[93m'
RESET='\033[0m'
COLOR=$MAGENTA
USER_NOTATION="${CYAN}â–¸${RESET}"

# GOLAN supported models
GOLAN_MODELS="arava viper tamar carmel mustang gilboa argaman alpine"
DEFAULT_MODEL="mustang"

# https://patorjk.com/software/taag/
showLogo() {
    cat << _EOF
      _              __
     (_)__ _  ___ _ / /__ ___
    / //  ' \/ _ '//  '_// -_)
 __/ //_/_/_/\_,_//_/\_\ \__/
|___/
_EOF
}

usage() {
    cat << _EOF
Usage: $SCRIPT_NAME [OPTIONS]

Build tool for NVIDIA golan_fw firmware.

Build Flags:
    -D, --debug                 Enable debug mode
    -c, --clean                 Run make clean (./build.sh -C)
        --clean-db              Also remove $fCompileCommandsJson during clean
        --git-clean             Deep clean using git clean -fdx (preserves submodules)
    -o, --build                 Run build commands
        --no-verbose            Suppress full compilation output (default: verbose)

Build Options:
    -b, --bear                  Generate compile_commands.json (implies -c --clean-db -o)
    -m, --model                 Set the build model (default: $DEFAULT_MODEL)
    -j, --jobs                  Set the number of parallel jobs (default: $fNumOfJobs)
    -w, --working-dir           Set working directory (default: current dir)
    --max-attempt               Set max build attempts (default: $fMaxBuildAttempt)

Other Options:
    -h, --help                  Print this help message
    -l, --list                  List available models
        --link                  Link compile_commands.json for clangd (use with -m)

Supported Models:
    $GOLAN_MODELS

Examples:
    $SCRIPT_NAME -o                        # Build mustang (default, verbose)
    $SCRIPT_NAME -c -o                     # Clean and build mustang
    $SCRIPT_NAME --no-verbose -o           # Build with quiet mode
    $SCRIPT_NAME -b -m gilboa              # Build gilboa with compile_commands.json

_EOF
    exit 0
}

[[ $# -eq 0 ]] && usage
fInputCmd="$SCRIPT_NAME $*"

# Detect and use GNU getopt if available (required for long options on macOS)
GETOPT_BIN="getopt"
if command -v /opt/homebrew/opt/gnu-getopt/bin/getopt &> /dev/null; then
    GETOPT_BIN="/opt/homebrew/opt/gnu-getopt/bin/getopt"
elif command -v /usr/local/opt/gnu-getopt/bin/getopt &> /dev/null; then
    GETOPT_BIN="/usr/local/opt/gnu-getopt/bin/getopt"
fi

SHORTOPTS="hcom:j:w:Dlb"
LONGOPTS="help,clean,debug,bear,build,clean-db,git-clean,model:,jobs:,working-dir:,max-attempt:,no-verbose,list,link"

if ! PARSED=$("$GETOPT_BIN" --options $SHORTOPTS --longoptions $LONGOPTS --name "$0" -- "$@"); then
    echo -e "${MAGENTA}Error: Failed to parse command-line options.${RESET}" >&2
    exit 1
fi

eval set -- "$PARSED"

while true; do
    case "$1" in
        -h|--help)
            usage
            shift
            ;;
        -D|--debug)
            set -x
            shift
            ;;
        -m|--model)
            fBuildModel="$2"
            fNeedBuild=true
            shift 2
            ;;
        -w|--working-dir)
            fWorkingDir="$2"
            fNeedBuild=true
            shift 2
            ;;
        -j|--jobs)
            fNumOfJobs="$2"
            fNeedBuild=true
            shift 2
            ;;
        --max-attempt)
            fMaxBuildAttempt="$2"
            fNeedBuild=true
            shift 2
            ;;
        -o|--build)
            fNeedBuild=true
            shift
            ;;
        -c|--clean)
            fClean=true
            shift
            ;;
        --clean-db)
            fClean=true
            fRMCompileCommandsJson=true
            shift
            ;;
        --git-clean)
            fGitClean=true
            fClean=true
            shift
            ;;
        -b|--bear)
            fGenerateCompileCmds=true
            fNeedBuild=true
            fClean=true
            fRMCompileCommandsJson=true  # -b/--bear implies -c --clean-db -o
            shift
            ;;
        --no-verbose)
            fVerbose=
            shift
            ;;
        -l|--list)
            echo -e "${BOLD}Available models:${RESET}"
            echo -e "${GREEN}$GOLAN_MODELS${RESET}"
            exit 0
            ;;
        --link)
            fLinkCompileDb=true
            shift
            ;;
        --)
            shift
            break
            ;;
        *)
            echo -e "$USER_NOTATION ${MAGENTA}Invalid option: $1${RESET}"
            exit 1
            ;;
    esac
done

if [[ $# -gt 0 ]]; then
    echo -e "$USER_NOTATION ${COLOR}Illegal non-option arguments: $*${RESET}"
    exit 1
fi

# Auto-set flags:
# --bear implies -o and -C (already set above)

getCurrentTime() {
    COLOR="$RED"
    echo -e "${COLOR}$(date +"%m/%d/%Y %H:%M:%S")${RESET}"
}

# $1: available models, $2: target model
searchBuildModel() {
    matchedModels=()
    local availModels="$1"
    local targetModel="$2"

    for model in $availModels; do
        if [[ "$model" == *"$targetModel"* ]]; then
            matchedModels+=("$model")
            if [[ "$model" == "$targetModel" ]]; then
                fBuildModel="$model"
            fi
        fi
    done

    COLOR="$RED"
    case ${#matchedModels[@]} in
        0)
            echo -e "$USER_NOTATION No matched model found for ${COLOR}$targetModel${RESET}"
            echo -e "$USER_NOTATION Available models: ${CYAN}$GOLAN_MODELS${RESET}"
            exit 1
            ;;
        1)
            fBuildModel="${matchedModels[0]}"
            ;;
        *)
            echo "$USER_NOTATION Multiple matched models found for $targetModel"
            echo "$USER_NOTATION Please specify the model from the following list:"
            for model in "${matchedModels[@]}"; do
                echo -e "${COLOR}$model${RESET}"
            done
            exit 1
            ;;
    esac
}

preConfigure() {
    [ -n "$fClean" ] || [ -n "$fNeedBuild" ] || [ -n "$fGenerateCompileCmds" ] || [ -n "$fRMCompileCommandsJson" ] || [ -n "$fLinkCompileDb" ] && fPrintBuildFlags=true
    [ -z "$fPrintBuildFlags" ] && return

    fWorkingDir=$(realpath "$fWorkingDir")
    cd "$fWorkingDir" || exit 1

    # Verify this is a golan_fw project
    if [[ ! -x "./build.sh" ]]; then
        echo -e "$USER_NOTATION ${RED}Error: build.sh not found. Are you in a golan_fw directory?${RESET}"
        exit 1
    fi

    # Lower case the build model
    fBuildModel=$(echo "$fBuildModel" | tr '[:upper:]' '[:lower:]')
    if [ -z "$fBuildModel" ]; then
        fBuildModel="$DEFAULT_MODEL"
    else
        searchBuildModel "$GOLAN_MODELS" "$fBuildModel"
    fi
}

printBuildFlags() {
    echo $SEPARATOR
    if [ -n "$fPrintBuildFlags" ]; then
        COLOR="$GREEN"
        echo -e "${BOLD}Build Flags:${RESET}"
        [ -n "$fClean" ]                 && echo -e "[C] ${COLOR}Clean${RESET} the build"
        [ -n "$fGitClean" ]              && echo -e "[G] ${COLOR}Git deep clean${RESET} (git clean -fdx)"
        [ -n "$fNeedBuild" ]             && echo -e "[o] ${COLOR}Build${RESET} the project"
        [ -z "$fVerbose" ]               && echo -e "[q] ${COLOR}Quiet${RESET} mode (--no-verbose)"
        [ -n "$fRMCompileCommandsJson" ] && echo -e "[/] ${COLOR}Remove${RESET} existing $fCompileCommandsJson"
        [ -n "$fGenerateCompileCmds" ]   && echo -e "[g] ${COLOR}Generate${RESET} compile_commands.json"
        [ -n "$fLinkCompileDb" ]         && echo -e "[L] ${COLOR}Link${RESET} compile_commands.json for clangd"
    fi

    if [ -n "$fNeedBuild" ]; then
        echo -e "${BOLD}Build Options:${RESET}"
        COLOR="$RED"
        echo -e "[m] Build Model:  ${COLOR}$fBuildModel${RESET}"
        COLOR="$CYAN"
        echo -e "[w] Build Directory: ${COLOR}$fWorkingDir${RESET}"
        echo -e "[T] Maximum Build Attempts: ${COLOR}$fMaxBuildAttempt${RESET}"
        echo -e "[j] Parallel Jobs: ${COLOR}$fNumOfJobs${RESET}"
    fi
    echo "$SEPARATOR"
    echo -en "${BOLD}Input Command: ${RESET}" >&2
    echo -e "${LIGHTYELLOW}$fInputCmd${RESET}" >&2
}

cleanTheRepo() {
    [ -z "$fClean" ] && return
    cd "$fWorkingDir" || exit
    echo -e "$USER_NOTATION ${CYAN}Cleaning the build...${RESET}"

    if [ -n "$fGitClean" ]; then
        # Deep clean using git clean -fdx
        echo -e "$USER_NOTATION ${CYAN}Deep cleaning with git clean -fdx...${RESET}"
        
        # Build exclude options
        local excludeOpts=""
        [ -z "$fRMCompileCommandsJson" ] && excludeOpts="--exclude=$fCompileCommandsJson"
        
        local cleanCmd="git clean -fdx $excludeOpts"
        echo -e "$USER_NOTATION Running: ${BLUE}$cleanCmd${RESET}"
        eval "$cleanCmd"
        
        # Also clean submodules
        echo -e "$USER_NOTATION ${CYAN}Cleaning submodules...${RESET}"
        git submodule foreach --recursive git clean -fdx
        
        echo -e "$USER_NOTATION ${MAGENTA}Deep clean completed.${RESET}"
    else
        # Standard make clean
        local cleanCmd="./build.sh -C"
        echo -e "$USER_NOTATION Running: ${BLUE}$cleanCmd${RESET}"
        sleep 1
        COLOR=$MAGENTA
        eval "$cleanCmd"
        if [[ $? -ne 0 ]]; then
            echo -e "$USER_NOTATION ${COLOR}There seems to be some errors during the clean process${RESET}"
            echo -e "$USER_NOTATION ${RESET}But going on anyway${RESET}"
        else
            echo -e "$USER_NOTATION ${COLOR}Cleaned the build successfully.${RESET}"
        fi

        # Remove compile_commands.json if requested
        if [ -n "$fRMCompileCommandsJson" ]; then
            if [ -L "$fCompileCommandsJson" ]; then
                # It's a symlink - remove both the symlink and the real file it points to
                local realFile
                realFile=$(readlink -f "$fCompileCommandsJson")
                echo -e "$USER_NOTATION Removing symlink ${CYAN}$fCompileCommandsJson${RESET}"
                rm -f "$fCompileCommandsJson"
                if [ -f "$realFile" ]; then
                    echo -e "$USER_NOTATION Removing real file ${CYAN}$realFile${RESET}"
                    rm -f "$realFile"
                fi
            elif [ -f "$fCompileCommandsJson" ]; then
                # It's a regular file - just remove it
                echo -e "$USER_NOTATION Removing ${CYAN}$fCompileCommandsJson${RESET}"
                rm -f "$fCompileCommandsJson"
            fi
        fi
    fi
}

updateSubmodules() {
    # Only update submodules when building
    [ -z "$fNeedBuild" ] && return
    cd "$fWorkingDir" || exit

    # Check if submodules are initialized by looking for a key file
    if [[ ! -f "shared/glib/glib.mak" ]]; then
        echo -e "$USER_NOTATION ${CYAN}Initializing submodules (first time)...${RESET}"
        git submodule update --init --recursive
    else
        echo -e "$USER_NOTATION ${CYAN}Updating submodules...${RESET}"
        git submodule update --recursive
    fi

    if [[ $? -ne 0 ]]; then
        echo -e "$USER_NOTATION ${RED}Error: Submodule update failed${RESET}"
        exit 1
    else
        echo -e "$USER_NOTATION ${GREEN}Submodules updated successfully.${RESET}"
    fi
}

runBuildCommands() {
    [ -z "$fNeedBuild" ] && return
    cd "$fWorkingDir" || exit

    local buildCommand="./build.sh -d $fBuildModel -c $fNumOfJobs"
    [ -n "$fVerbose" ] && buildCommand+=" --verbose"
    [ -n "$fGenerateCompileCmds" ] && buildCommand+=" --bear"

    local currAttempt=1
    local maxAttempt=$fMaxBuildAttempt
    local buildStartTime buildEndTime
    local eval_status=1

    while [[ $currAttempt -le $maxAttempt ]]; do
        buildStartTime=$(date +%s)
        COLOR="$GREEN"
        echo -e "$USER_NOTATION Running: ${LIGHTYELLOW}$buildCommand${RESET}"
        echo -e "$USER_NOTATION ${COLOR}Build attempt $currAttempt/$maxAttempt${RESET}"
        sleep 1

        eval "$buildCommand"
        eval_status=$?

        if [[ $eval_status -eq 0 ]]; then
            break
        else
            currAttempt=$((currAttempt + 1))
        fi
    done
    buildEndTime=$(date +%s)

    if [[ $eval_status -ne 0 ]]; then
        COLOR="$MAGENTA"
        echo -e "$USER_NOTATION ${COLOR}Build failed. Please search for error: in the build output.${RESET}"
        exit 1
    fi

    local buildTime=$((buildEndTime - buildStartTime))
    local hours=$((buildTime / 3600))
    local minutes=$((buildTime % 3600 / 60))
    local seconds=$((buildTime % 60))
    fBuildTimeFormatted="${seconds}s"

    if [[ $minutes -gt 0 ]]; then
        fBuildTimeFormatted="${minutes}m${fBuildTimeFormatted}"
    fi

    if [[ $hours -gt 0 ]]; then
        fBuildTimeFormatted="${hours}h${fBuildTimeFormatted}"
    fi

    echo -e "$USER_NOTATION Build completed successfully at $(getCurrentTime) in $fBuildTimeFormatted"
}

linkCompileDatabase() {
    [ -z "$fGenerateCompileCmds" ] && [ -z "$fLinkCompileDb" ] && return
    cd "$fWorkingDir" || exit

    local dbFile="bin/build_tools/compile_db/compile_commands_${fBuildModel}_irisc.json"
    local targetLink="$fWorkingDir/compile_commands.json"
    local clangdSource="/labhome/pexiang/myGit/crosslv/assets/.clangd"
    local clangdTarget="$fWorkingDir/.clangd"

    # Link compile_commands.json
    # Skip if link already exists and points to correct target (only for --link, not --bear)
    if [ -n "$fLinkCompileDb" ] && [ -z "$fGenerateCompileCmds" ]; then
        if [[ -L "$targetLink" && "$(readlink "$targetLink")" == "$dbFile" ]]; then
            echo -e "$USER_NOTATION ${GREEN}Link already exists:${RESET} compile_commands.json -> $dbFile"
        else
            if [[ -f "$dbFile" ]]; then
                echo -e "$USER_NOTATION ${CYAN}Linking compile database for clangd...${RESET}"
                ln -sf "$dbFile" "$targetLink"
                echo -e "$USER_NOTATION Created: ${GREEN}compile_commands.json${RESET} -> ${BLUE}$dbFile${RESET}"
            else
                echo -e "$USER_NOTATION ${RED}Warning: Compile database not found: $dbFile${RESET}"
            fi
        fi
    else
        if [[ -f "$dbFile" ]]; then
            echo -e "$USER_NOTATION ${CYAN}Linking compile database for clangd...${RESET}"
            ln -sf "$dbFile" "$targetLink"
            echo -e "$USER_NOTATION Created: ${GREEN}compile_commands.json${RESET} -> ${BLUE}$dbFile${RESET}"
        else
            echo -e "$USER_NOTATION ${RED}Warning: Compile database not found: $dbFile${RESET}"
        fi
    fi

    # Link .clangd config
    if [[ -L "$clangdTarget" && "$(readlink "$clangdTarget")" == "$clangdSource" ]]; then
        echo -e "$USER_NOTATION ${GREEN}Link already exists:${RESET} .clangd -> $clangdSource"
    elif [[ -f "$clangdSource" ]]; then
        ln -sf "$clangdSource" "$clangdTarget"
        echo -e "$USER_NOTATION Created: ${GREEN}.clangd${RESET} -> ${BLUE}$clangdSource${RESET}"
    else
        echo -e "$USER_NOTATION ${RED}Warning: .clangd config not found: $clangdSource${RESET}"
    fi
}

removeWriteFromJson() {
    [ -z "$fNeedBuild" ] && return
    cd "$fWorkingDir" || exit

    # Operate on the actual target file, not the symlink
    local dbFile="bin/build_tools/compile_db/compile_commands_${fBuildModel}_irisc.json"
    if [[ -f "$dbFile" ]]; then
        if [[ -w "$dbFile" ]]; then
            echo -e "$USER_NOTATION ${CYAN}Removing write privilege from $dbFile${RESET}"
            chmod u-w "$dbFile"
        else
            echo -e "$USER_NOTATION ${GREY}$dbFile is already read-only${RESET}"
        fi
    fi
}

###############################################################################
# FORTINET-SPECIFIC FUNCTIONS (Reserved for future use)
# These functions are not called for GOLAN platform
###############################################################################

checkCmdAvailability() {
    if ! command -v "$1" &> /dev/null; then
        echo -e "$USER_NOTATION ${RED}Error: Command $1 not found.${RESET}"
        exit 1
    fi
}

# Run Fortinet Configure with expect automation
runFortnetConfigure() {
    [[ "$fPlatform" != "FORTINET" ]] && return
    [[ -z "$fRunConfigure" ]] && return

    checkCmdAvailability "expect"
    checkCmdAvailability "get_credentials"

    if ! credentials_output=$(eval get_credentials); then
        echo -e "$USER_NOTATION ${RED}Error: Failed to get credentials.${RESET}"
        exit 1
    fi

    mapfile -t credentials <<< "$credentials_output"
    ftntUser=${credentials[0]}
    ftntPasswd=${credentials[1]}
    if [[ -z "$ftntUser" || -z "$ftntPasswd" ]]; then
        echo -e "$USER_NOTATION ${RED}Error: Failed to get credentials.${RESET}"
        exit 1
    fi

    COLOR=$BLUE
    local configParams="-m $fBuildModel -d y -c"
    CONFIGURE_CMD="./Configure $configParams"
    echo -e "$USER_NOTATION Running Configure: ${COLOR}$CONFIGURE_CMD${RESET}"
    COLOR=$MAGENTA
    echo -e "$USER_NOTATION ${COLOR}Spawning a new bash session${RESET}"
    sleep 1

    expect -c "
        set config_bash_prompt \"$ \"
        log_user 1
        spawn -noecho bash

        expect \"\$config_bash_prompt\"
        send \"cd $fWorkingDir\r\"
        expect \"\$config_bash_prompt\"
        send \"$CONFIGURE_CMD\r\"

        set timeout 300
        expect {
            {Username} {
                send \"$ftntUser\r\"
                exp_continue
            }
            {Password for '$ftntUser':} {
                send \"$ftntPasswd\r\"
                exp_continue
            }
            {Please select a region: van, ott, sjc:} {
                send \"van\r\"
                exp_continue
            }
            \"\$config_bash_prompt\" {
                send \"\x04\r\"
            }
            {\[Yn\]:} {
                send \"y\r\"
                exp_continue
            }
            {yes/no} {
                send \"yes\r\"
                exp_continue
            }
            timeout {
                puts stderr \"$USER_NOTATION Timeout. Action aborted.\n\"
                exit 1
            }
        }
    "

    COLOR=$MAGENTA
    if [[ $? -ne 0 ]]; then
        echo -e "$USER_NOTATION ${COLOR}Failed to run Configure.${RESET}"
        exit 1
    else
        echo -e "$USER_NOTATION ${COLOR}Configure completed successfully.${RESET}"
    fi
}

# Sync image to Fortinet device with expect automation
runFortinetSync() {
    [[ "$fPlatform" != "FORTINET" ]] && return
    [[ -z "$fSyncTarget" ]] && return

    if ! ping -c 1 -W 1 "$fSyncTarget" &> /dev/null; then
        echo -e "$USER_NOTATION ${MAGENTA}Host $fSyncTarget not reachable${RESET}"
        exit 1
    fi

    local syncFile=
    local syncFiles=()
    if [[ "$fSyncFile" == */* ]]; then
        if [[ -f "$fSyncFile" ]]; then
            syncFile="$fSyncFile"
        else
            echo -e "$USER_NOTATION ${MAGENTA}$fSyncFile not found at path: $fSyncFile${RESET}"
            exit 1
        fi
    else
        mapfile -t syncFiles < <(find "$fWorkingDir" -name "$fSyncFile")
        if [[ ${#syncFiles[@]} -eq 0 ]]; then
            echo -e "$USER_NOTATION ${MAGENTA}$fSyncFile not found in $fWorkingDir${RESET}"
            exit 1
        fi
        syncFile="${syncFiles[0]}"
    fi

    COLOR="$BLUE"
    echo '----------------------------------------------------'
    echo -e "$USER_NOTATION Syncing ${COLOR}$syncFile${RESET} to ${COLOR}$fSyncTarget${RESET} ..."

    maxSyncRetries=3
    ESUCCESS=0
    EMAXTRIES=$(($maxSyncRetries + 1))
    ETIMEOUT=$(($maxSyncRetries + 2))
    EFAILED=$(($maxSyncRetries + 3))
    EPERMDENIED=$(($maxSyncRetries + 4))

    expect -c "
        set defaultTimeout 1200
        set adjustTimeout 0
        set waitBeforeRetry 10
        set passwd_prompt_cnt 0

        set RESET       \"\033\[0m\"
        set MAGENTA     \"\033\[35m\"
        set COLOR       \$MAGENTA

        for {set i 1} {\$i <= $maxSyncRetries} {incr i} {
            puts stderr \"$USER_NOTATION Sync attempt \${COLOR}\$i/$maxSyncRetries\${RESET}\"
            spawn -noecho scp -P $fSyncPort $syncFile ${fSyncUsername}@${fSyncTarget}:/fgt-image
            if {\$adjustTimeout != 0} {
                set timeout \$adjustTimeout
            } else {
                set timeout \$defaultTimeout
            }

            expect {
                \"bad port\" {
                    puts stderr \"$USER_NOTATION Bad port. Connecting aborted.\"
                    exit $EFAILED
                }
                {yes/no} {
                    send \"yes\r\"
                    exp_continue
                }
                -nocase {Password:} {
                    incr passwd_prompt_cnt
                    if {\$passwd_prompt_cnt > 1} {
                        puts stderr \"\n$USER_NOTATION Permission Denied. Please specify the login credentials.\"
                        exit $EFAILED
                    }
                    send \"$fSyncPassword\r\"
                    exp_continue
                }
                \"Host key verification failed.\" {
                    puts stderr \"$USER_NOTATION Host key verification failed. Updating known_hosts ...\"
                    system \"ssh-keygen -R $fSyncTarget\"
                    puts stderr \"$USER_NOTATION Host key removed. Retrying...\"
                    continue
                }
                -re {Connection refused|No route to host} {
                    set adjustTimeout -1
                    puts stderr \"$USER_NOTATION Waiting for \$waitBeforeRetry seconds before retrying ...\"
                    sleep \$waitBeforeRetry
                    set waitBeforeRetry [expr {\$waitBeforeRetry * 2}]
                    continue
                }
                \"501-Permission Denied\" {
                    puts stderr \"$USER_NOTATION Permission Denied. Please enable admin-scp under config system global\"
                    exit $EPERMDENIED
                }
                \"100-update image completed\" {
                    puts stderr \"$USER_NOTATION 100-update image completed. Action completed.\"
                    exit $ESUCCESS
                }
                \"Command fail\" {
                    puts stderr \"$USER_NOTATION Command fail. Action aborted.\"
                    exit $EFAILED
                }
                timeout {
                    puts stderr \"$USER_NOTATION Timeout. Action aborted.\"
                    exit $ETIMEOUT
                }
                eof {
                    puts stderr \"$USER_NOTATION Reaching EOF.\"
                    exit $ESUCCESS
                }
            }
        }
        exit \$i
    "

    retValue=$?
    case $retValue in
        "$ESUCCESS")
            COLOR=$MAGENTA
            echo -e "$USER_NOTATION You have synced $fSyncFile to $fSyncTarget successfully at $(getCurrentTime)"
            ;;
        "$EMAXTRIES")
            echo "$USER_NOTATION Failed to sync after $maxSyncRetries attempts"
            exit $EMAXTRIES
            ;;
        "$ETIMEOUT")
            echo "$USER_NOTATION Timeout syncing to $fSyncTarget"
            exit $ETIMEOUT
            ;;
        *)
            echo "$USER_NOTATION Failed to sync to $fSyncTarget"
            exit $EFAILED
            ;;
    esac
}

###############################################################################
# END OF FORTINET-SPECIFIC FUNCTIONS
###############################################################################

main() {
    preConfigure "$@"
    showLogo
    printBuildFlags
    cleanTheRepo
    updateSubmodules
    runBuildCommands
    linkCompileDatabase
    removeWriteFromJson
}

main "$@"
