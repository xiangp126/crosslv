#!/usr/bin/env bash
# shellcheck disable=SC2155 disable=SC2120 disable=SC2024
# set -x

# Build flags & Options
fBuildModel=
fBuildCommand=
fModels=()
fModelsSkip=()
fModelsSkipped=()
fModelsVerified=()
fModelsCurrent=
fModelsPending=()
fNumOfJobs=$(nproc)
fWorkingDir=$(pwd)
fMaxBuildAttempt=1
fGenerateCompileCmds=
fLinkCompileDb=
fNeedBuild=
fPrintBuildFlags=
fClean=
fGitClean=
fNoVerbose=
fNicx=
fContinue=
fScratch=
fInputCmd=
fBuildTimeFormatted=
# Git associated variables
fCompileCommandsJson="compile_commands.json"
fRMCompileCommandsJson=

# Colors
CYAN='\033[36m'
RED='\033[31m'
BOLD='\033[1m'
GREEN='\033[32m'
MAGENTA='\033[35m'
BLUE='\033[34m'
GREY='\033[90m'
YELLOW='\033[33m'
LIGHTYELLOW='\033[93m'
RESET='\033[0m'
# Common Constants
COLOR=$MAGENTA
SCRIPT_NAME=$(basename $0)
NOTATION="${CYAN}▸${RESET}"
SEPARATOR="==================================================="
BUILD_SCRIPT="./build.sh"
STATE_FILE=".${SCRIPT_NAME}_state"

# GOLAN supported models
# Model to hardware device mapping (ordered by hardware generation)
declare -A MODEL_HARDWARE=(
    [arava]="CX6DX"
    [tamar]="CX6LX"
    [viper]="BF2"
    [mustang]="BF3"
    [carmel]="CX7"
    [gilboa]="CX8"
    [argaman]="CX9"
    [alpine]="CX10"
)

# GOLAN supported models (same order as MODEL_HARDWARE)
# GOLAN_MODELS="arava tamar viper mustang carmel gilboa argaman alpine"
# Due to a compilation bug, carmel must be built immediately before argaman
GOLAN_MODELS="arava tamar viper mustang gilboa carmel argaman alpine"
DEFAULT_MODEL="gilboa"

# Get model display name with hardware info: "model (HW)"
getModelDisplayName() {
    local model="$1"
    local hw="${MODEL_HARDWARE[$model]}"
    if [[ -n "$hw" ]]; then
        echo "$model ($hw)"
    else
        echo "$model"
    fi
}

# Format array of models with hardware info, comma-separated
formatModelsWithHardware() {
    local -n arr=$1
    local result=""
    for model in "${arr[@]}"; do
        [[ -n "$result" ]] && result+=","
        result+="$(getModelDisplayName "$model")"
    done
    echo "$result"
}

# Save build state to file for --continue support
saveLoopState() {
    local stateFile="$fWorkingDir/$STATE_FILE"
    cat > "$stateFile" << EOF
# jmake loop build state - $(date)
# Do not edit this file manually
VERIFIED=${fModelsVerified[*]}
FAILED=$fModelsCurrent
PENDING=${fModelsPending[*]}
SKIPPED=${fModelsSkipped[*]}
EOF
    echo -e "$NOTATION State saved to ${CYAN}$stateFile${RESET}"
    echo -e "$NOTATION Run ${YELLOW}jmake -a --continue${RESET} to resume after fixing the issue"
}

# Load build state from file
loadLoopState() {
    local stateFile="$fWorkingDir/$STATE_FILE"
    if [[ ! -f "$stateFile" ]]; then
        echo -e "$NOTATION ${RED}Error: No saved state found. Run jmake -a first.${RESET}"
        exit 1
    fi

    # Read state file
    local verified failed pending skipped
    while IFS='=' read -r key value; do
        [[ "$key" =~ ^#.*$ || -z "$key" ]] && continue
        case "$key" in
            VERIFIED) verified="$value" ;;
            FAILED) failed="$value" ;;
            PENDING) pending="$value" ;;
            SKIPPED) skipped="$value" ;;
        esac
    done < "$stateFile"

    # Restore fModels from saved state (failed + pending)
    fModels=()
    [[ -n "$failed" ]] && fModels+=("$failed")
    for m in $pending; do
        fModels+=("$m")
    done

    # Restore skipped models
    fModelsSkip=()
    for m in $skipped; do
        fModelsSkip+=("$m")
    done

    # Restore verified models (will be shown in summary)
    fModelsVerified=()
    for m in $verified; do
        fModelsVerified+=("$m")
    done

    echo $SEPARATOR
    echo -e "$NOTATION ${CYAN}Resuming from saved state:${RESET}"
    echo -e "$NOTATION ${GREEN}✓ Previously verified:${RESET} ${verified:-none}"
    echo -e "$NOTATION ${YELLOW}○ Resuming from:${RESET} $failed"
    [[ -n "$pending" ]] && echo -e "$NOTATION${GREY}○ Pending:${RESET} $pending"
    echo $SEPARATOR
}

# Delete state file
deleteLoopState() {
    local stateFile="$fWorkingDir/$STATE_FILE"
    if [[ -f "$stateFile" ]]; then
        rm -f "$stateFile"
        echo -e "$NOTATION Cleared saved state file: ${LIGHTYELLOW}$stateFile${RESET}"
    fi
}

# https://patorjk.com/software/taag/
showLogo() {
    cat << _EOF
      _              __
     (_)__ _  ___ _ / /__ ___
    / //  ' \/ _ '//  '_// -_)
 __/ //_/_/_/\_,_//_/\_\ \__/
|___/
_EOF
}

usage() {
    cat << _EOF
Usage: $SCRIPT_NAME [OPTIONS]

Build tool for NVIDIA golan_fw firmware.

Build Flags:
    -D, --debug                 Enable debug mode
    -c, --clean                 Run make clean ($BUILD_SCRIPT -C)
        --clean-db              Also remove $fCompileCommandsJson during clean
        --git-clean             Deep clean using git clean -fdx (preserves submodules)
    -o, --build                 Run build commands
        --no-verbose            Suppress full compilation output (default: verbose)

Build Options:
    -a, --all, --models-all     Build all models one by one (loop mode)
    -b, --bear                  Generate compile_commands.json (implies -c --clean-db -o)
    -m, --models <models>       Build specified models (comma-separated, loop if multiple)
        --models-skip <models>  Skip these models when building (comma-separated)
    -N, --nicx                  Build with NICX=1 flag
    -j, --jobs                  Set the number of parallel jobs (default: $fNumOfJobs)
    -w, --working-dir           Set working directory (default: current dir)
    --attempt                   Set max build attempts (default: $fMaxBuildAttempt)
        --continue              Resume from last failed model (like git rebase --continue)
        --scratch               Clear saved state and start from first model

Other Options:
    -h, --help                  Print this help message
    -l, --list                  List available models
        --link                  Link compile_commands.json for clangd (use with -m)

Supported Models:
    $GOLAN_MODELS

Examples:
    $SCRIPT_NAME -o                           # Build ${DEFAULT_MODEL:-} (default, verbose)
    $SCRIPT_NAME --models argaman,alpine      # Build argaman and alpine (separated by comma)
    $SCRIPT_NAME -a                           # Build all models one by one
    $SCRIPT_NAME -a --models-skip arava,viper # Build all except arava and viper
    $SCRIPT_NAME -a --continue                # Resume from last failed model
    $SCRIPT_NAME -a --scratch                 # Clear state and start fresh
    $SCRIPT_NAME -c -o                        # Clean and build the default ${DEFAULT_MODEL:-}
    $SCRIPT_NAME --no-verbose -o              # Build with quiet mode
    $SCRIPT_NAME --bear --models gilboa       # Build gilboa with compile_commands.json

_EOF
    exit 0
}

[[ $# -eq 0 ]] && usage
fInputCmd="$SCRIPT_NAME $*"

# Detect and use GNU getopt if available (required for long options on macOS)
GETOPT_BIN="getopt"
if command -v /opt/homebrew/opt/gnu-getopt/bin/getopt &> /dev/null; then
    GETOPT_BIN="/opt/homebrew/opt/gnu-getopt/bin/getopt"
elif command -v /usr/local/opt/gnu-getopt/bin/getopt &> /dev/null; then
    GETOPT_BIN="/usr/local/opt/gnu-getopt/bin/getopt"
fi

SHORTOPTS="hcoaj:w:Dlbm:N"
LONGOPTS="help,clean,debug,bear,build,clean-db,git-clean,jobs:,working-dir:,attempt:,no-verbose,list,link,all,models:,models-all,models-skip:,nicx,continue,scratch"

if ! PARSED=$("$GETOPT_BIN" --options $SHORTOPTS --longoptions $LONGOPTS --name "$0" -- "$@"); then
    echo -e "${MAGENTA}Error: Failed to parse command-line options.${RESET}" >&2
    exit 1
fi

eval set -- "$PARSED"

while true; do
    case "$1" in
        -h|--help)
            usage
            shift
            ;;
        -D|--debug)
            set -x
            shift
            ;;
        -w|--working-dir)
            fWorkingDir="$2"
            fNeedBuild=true
            shift 2
            ;;
        -j|--jobs)
            fNumOfJobs="$2"
            fNeedBuild=true
            shift 2
            ;;
        --attempt)
            fMaxBuildAttempt="$2"
            fNeedBuild=true
            shift 2
            ;;
        -o|--build)
            fNeedBuild=true
            shift
            ;;
        -c|--clean)
            fClean=true
            shift
            ;;
        --clean-db)
            fClean=true
            fRMCompileCommandsJson=true
            shift
            ;;
        --git-clean)
            fGitClean=true
            fClean=true
            shift
            ;;
        -b|--bear)
            fGenerateCompileCmds=true
            fNeedBuild=true
            fClean=true
            fRMCompileCommandsJson=true  # -b/--bear implies -c --clean-db -o
            shift
            ;;
        --no-verbose)
            fNoVerbose=true
            shift
            ;;
        -N|--nicx)
            fNicx=true
            shift
            ;;
        --continue)
            fContinue=true
            fNeedBuild=true
            shift
            ;;
        --scratch)
            fScratch=true
            shift
            ;;
        -l|--list)
            echo -e "${BOLD}Available models:${RESET}"
            for model in $GOLAN_MODELS; do
                hw="${MODEL_HARDWARE[$model]}"
                if [[ -n "$hw" ]]; then
                    printf "  ${GREEN}%-10s${RESET} → ${CYAN}%s${RESET}\n" "$model" "$hw"
                else
                    printf "  ${GREEN}%s${RESET}\n" "$model"
                fi
            done
            exit 0
            ;;
        --link)
            fLinkCompileDb=true
            shift
            ;;
        -a|--all|--models-all)
            IFS=' ' read -ra _models <<< "$GOLAN_MODELS"
            fModels+=("${_models[@]}")
            fNeedBuild=true
            shift
            ;;
        -m|--models)
            IFS=', ' read -ra _models <<< "$2"
            fModels+=("${_models[@]}")
            fNeedBuild=true
            shift 2
            ;;
        --models-skip)
            IFS=', ' read -ra _skipModels <<< "$2"
            fModelsSkip+=("${_skipModels[@]}")
            fNeedBuild=true
            shift 2
            ;;
        --)
            shift
            break
            ;;
        *)
            echo -e "$NOTATION ${MAGENTA}Invalid option: $1${RESET}"
            exit 1
            ;;
    esac
done

if [[ $# -gt 0 ]]; then
    echo -e "$NOTATION ${COLOR}Illegal non-option arguments: $*${RESET}"
    exit 1
fi

# Auto-set flags:
# --bear implies -o and -C (already set above)

getCurrentTime() {
    COLOR="$RED"
    echo -e "${COLOR}$(date +"%m/%d/%Y %H:%M:%S")${RESET}"
}

# $1: available models, $2: target model
searchBuildModel() {
    matchedModels=()
    local availModels="$1"
    local targetModel="$2"

    for model in $availModels; do
        if [[ "$model" == *"$targetModel"* ]]; then
            matchedModels+=("$model")
            if [[ "$model" == "$targetModel" ]]; then
                fBuildModel="$model"
            fi
        fi
    done

    COLOR="$RED"
    case ${#matchedModels[@]} in
        0)
            echo -e "$NOTATION No matched model found for ${COLOR}$targetModel${RESET}"
            echo -e "$NOTATION Available models: ${CYAN}$GOLAN_MODELS${RESET}"
            exit 1
            ;;
        1)
            fBuildModel="${matchedModels[0]}"
            ;;
        *)
            echo "$NOTATION Multiple matched models found for $targetModel"
            echo "$NOTATION Please specify the model from the following list:"
            for model in "${matchedModels[@]}"; do
                echo -e "${COLOR}$model${RESET}"
            done
            exit 1
            ;;
    esac
}

preConfigure() {
    [ -n "$fClean" ] || [ -n "$fNeedBuild" ] || [ -n "$fGenerateCompileCmds" ] || [ -n "$fRMCompileCommandsJson" ] || [ -n "$fLinkCompileDb" ] && fPrintBuildFlags=true
    [ -z "$fPrintBuildFlags" ] && return

    fWorkingDir=$(realpath "$fWorkingDir")
    cd "$fWorkingDir" || exit 1

    # Verify this is a golan_fw project
    if [[ ! -x "$BUILD_SCRIPT" ]]; then
        echo -e "$NOTATION ${RED}Error: $BUILD_SCRIPT not found. Are you in a golan_fw directory?${RESET}"
        exit 1
    fi

    # Lower case the build model
    fBuildModel=$(echo "$fBuildModel" | tr '[:upper:]' '[:lower:]')
    if [ -z "$fBuildModel" ]; then
        fBuildModel="$DEFAULT_MODEL"
    else
        searchBuildModel "$GOLAN_MODELS" "$fBuildModel"
    fi
}

validateArguments() {
    if [[ ${#fModelsSkip[@]} -gt 0 && ${#fModels[@]} -eq 0 ]]; then
        echo -e "$NOTATION ${RED}Error: --models-skip requires --models${RESET}"
        exit 1
    fi
}

printBuildFlags() {
    echo $SEPARATOR
    if [ -n "$fPrintBuildFlags" ]; then
        COLOR="$GREEN"
        echo -e "${BOLD}Build Flags:${RESET}"
        [ -n "$fClean" ]                 && echo -e "[C] ${COLOR}Clean${RESET} the build"
        [ -n "$fGitClean" ]              && echo -e "[G] ${COLOR}Git deep clean${RESET} (git clean -fdx)"
        [ -n "$fNeedBuild" ]             && echo -e "[o] ${COLOR}Build${RESET} the project"
        [ -n "$fNoVerbose" ]             && echo -e "[V] ${COLOR}No Verbose${RESET} mode"
        [ -n "$fRMCompileCommandsJson" ] && echo -e "[/] ${COLOR}Remove${RESET} existing $fCompileCommandsJson"
        [ -n "$fGenerateCompileCmds" ]   && echo -e "[g] ${COLOR}Generate${RESET} compile_commands.json"
        [ -n "$fLinkCompileDb" ]         && echo -e "[L] ${COLOR}Link${RESET} compile_commands.json for clangd"
    fi

    if [ -n "$fNeedBuild" ]; then
        echo -e "${BOLD}Build Options:${RESET}"
        COLOR="$RED"
        if [[ ${#fModels[@]} -gt 1 || ${#fModelsSkip[@]} -gt 0 ]]; then
            echo -e "[L] Build Mode:   ${COLOR}Loop Mode${RESET} (models one by one)"
            if [[ ${#fModels[@]} -gt 0 ]]; then
                echo -e "[I] Include Only: ${GREEN}${fModels[*]}${RESET}"
            fi
            if [[ ${#fModelsSkip[@]} -gt 0 ]]; then
                echo -e "[S] Skip Models:  ${YELLOW}${fModelsSkip[*]}${RESET}"
            fi
        elif [[ ${#fModels[@]} -eq 1 ]]; then
            echo -e "[m] Build Model:  ${COLOR}$(getModelDisplayName "${fModels[0]}")${RESET}"
        else
            echo -e "[m] Build Model:  ${COLOR}$(getModelDisplayName "$fBuildModel")${RESET}"
        fi
        COLOR="$CYAN"
        echo -e "[w] Build Directory: ${COLOR}$fWorkingDir${RESET}"
        echo -e "[T] Maximum Build Attempts: ${COLOR}$fMaxBuildAttempt${RESET}"
        echo -e "[j] Parallel Jobs: ${COLOR}$fNumOfJobs${RESET}"
    fi
    echo "$SEPARATOR"
    echo -en "${BOLD}Input Command: ${RESET}" >&2
    echo -e "${LIGHTYELLOW}$fInputCmd${RESET}" >&2
}

cleanTheRepo() {
    [ -z "$fClean" ] && return
    cd "$fWorkingDir" || exit
    echo -e "$NOTATION ${CYAN}Cleaning the build...${RESET}"

    if [ -n "$fGitClean" ]; then
        # Deep clean using git clean -fdx
        echo -e "$NOTATION ${CYAN}Deep cleaning with git clean -fdx...${RESET}"

        # Build exclude options
        # Always exclude *.code-workspace files and state file by default
        local excludeOpts="--exclude=*.code-workspace --exclude=$STATE_FILE"
        if [ -z "$fRMCompileCommandsJson" ]; then
            if [ -L "$fCompileCommandsJson" ]; then
                # It's a symlink, exclude the real file instead of the symlink itself
                realFile=$(readlink -f "$fCompileCommandsJson")
                excludeOpts="$excludeOpts --exclude=$(basename "$realFile")"
            else
                excludeOpts="$excludeOpts --exclude=$fCompileCommandsJson"
            fi
        fi

        local cleanCmd="git clean -fdx $excludeOpts"
        echo -e "$NOTATION Running: ${BLUE}$cleanCmd${RESET}"
        echo $SEPARATOR
        eval "$cleanCmd"

        # Also clean submodules
        echo -e "$NOTATION ${CYAN}Cleaning submodules...${RESET}"
        git submodule foreach --recursive git clean -fdx "$excludeOpts"

        echo -e "$NOTATION ${MAGENTA}Deep clean completed.${RESET}"
    else
        # Standard make clean
        local cleanCmd="$BUILD_SCRIPT -C"
        echo -e "$NOTATION Running: ${BLUE}$cleanCmd${RESET}"
        echo $SEPARATOR
        sleep 1
        COLOR=$MAGENTA
        eval "$cleanCmd"
        if [[ $? -ne 0 ]]; then
            echo -e "$NOTATION ${COLOR}There seems to be some errors during the clean process${RESET}"
            echo -e "$NOTATION ${RESET}But going on anyway${RESET}"
        else
            echo -e "$NOTATION ${COLOR}Cleaned the build successfully.${RESET}"
        fi

        # Remove compile_commands.json if requested
        if [ -n "$fRMCompileCommandsJson" ]; then
            if [ -L "$fCompileCommandsJson" ]; then
                # It's a symlink - remove both the symlink and the real file it points to
                local realFile
                realFile=$(readlink -f "$fCompileCommandsJson")
                echo -e "$NOTATION Removing symlink ${CYAN}$fCompileCommandsJson${RESET}"
                rm -f "$fCompileCommandsJson"
                if [ -f "$realFile" ]; then
                    echo -e "$NOTATION Removing real file ${CYAN}$realFile${RESET}"
                    rm -f "$realFile"
                fi
            elif [ -f "$fCompileCommandsJson" ]; then
                # It's a regular file - just remove it
                echo -e "$NOTATION Removing ${CYAN}$fCompileCommandsJson${RESET}"
                rm -f "$fCompileCommandsJson"
            fi
        fi
    fi
}

updateSubmodules() {
    # Only update submodules when building
    [ -z "$fNeedBuild" ] && return
    cd "$fWorkingDir" || exit

    # Check if submodules are initialized by looking for a key file
    if [[ ! -f "shared/glib/glib.mak" ]]; then
        echo -e "$NOTATION ${CYAN}Initializing submodules with: ${YELLOW}git submodule update --init --recursive${RESET}"
        eval "git submodule update --init --recursive"
    else
        echo -e "$NOTATION ${CYAN}Updating submodules with: ${YELLOW}git submodule update --recursive${RESET}"
        eval "git submodule update --recursive"
    fi

    if [[ $? -ne 0 ]]; then
        echo -e "$NOTATION ${RED}Error: Submodule update failed${RESET}"
        exit 1
    else
        echo -e "$NOTATION ${GREEN}Submodules updated successfully.${RESET}"
    fi
}

printLoopStatusChart() {
    echo "$SEPARATOR"
    echo -e "$NOTATION ${BOLD}${RED}Build Failed - Loop Status Chart:${RESET}"
    echo -e "  ${RED}✗ Failed:${RESET}      $fModelsCurrent"
    if [[ ${#fModelsVerified[@]} -gt 0 ]]; then
        echo -e "  ${GREEN}✓ Verified:${RESET}    $(IFS=','; echo "${fModelsVerified[*]}")"
    else
        echo -e "  ${GREEN}✓ Verified:${RESET}    (none)"
    fi
    if [[ ${#fModelsSkipped[@]} -gt 0 ]]; then
        echo -e "  ${CYAN}⊘ Skipped:${RESET}     $(IFS=','; echo "${fModelsSkipped[*]}")"
    fi
    if [[ ${#fModelsPending[@]} -gt 0 ]]; then
        echo -e "  ${YELLOW}○ Pending:${RESET}     $(IFS=','; echo "${fModelsPending[*]}")"
    else
        echo -e "  ${YELLOW}○ Pending:${RESET}     (none)"
    fi
    echo "$SEPARATOR"
}

makeBuildCommand() {
    fBuildCommand="$BUILD_SCRIPT"
    fBuildCommand+=" -d $fBuildModel"
    fBuildCommand+=" -c $fNumOfJobs"
    [ -z "$fNoVerbose" ] && fBuildCommand+=" --verbose"
    [ -n "$fGenerateCompileCmds" ] && fBuildCommand+=" --bear"
    [ -n "$fNicx" ] && fBuildCommand+=" -D NICX=1"
}

runBuildCommands() {
    [ -z "$fNeedBuild" ] && return
    cd "$fWorkingDir" || exit

    makeBuildCommand # set fBuildCommand

    local currAttempt=1
    local maxAttempt=$fMaxBuildAttempt
    local buildStartTime buildEndTime
    local eval_status=1

    while [[ $currAttempt -le $maxAttempt ]]; do
        buildStartTime=$(date +%s)
        COLOR="$GREEN"
        echo -e "$NOTATION Running: ${LIGHTYELLOW}$fBuildCommand${RESET}"
        echo -e "$NOTATION ${COLOR}Build attempt $currAttempt/$maxAttempt${RESET}"
        sleep 1

        eval "$fBuildCommand"
        eval_status=$?

        if [[ $eval_status -eq 0 ]]; then
            break
        else
            currAttempt=$((currAttempt + 1))
        fi
    done
    buildEndTime=$(date +%s)

    if [[ $eval_status -ne 0 ]]; then
        echo -e "$NOTATION ${RED}✗ $(getModelDisplayName "$fBuildModel") build failed${RESET}"
        # Only save state and show chart when building multiple models
        if [[ ${#fModels[@]} -gt 1 || ${#fModelsSkip[@]} -gt 0 ]]; then
            printLoopStatusChart
            saveLoopState
        fi
        exit 1
    fi

    local buildTime=$((buildEndTime - buildStartTime))
    local hours=$((buildTime / 3600))
    local minutes=$((buildTime % 3600 / 60))
    local seconds=$((buildTime % 60))
    fBuildTimeFormatted="${seconds}s"

    if [[ $minutes -gt 0 ]]; then
        fBuildTimeFormatted="${minutes}m${fBuildTimeFormatted}"
    fi

    if [[ $hours -gt 0 ]]; then
        fBuildTimeFormatted="${hours}h${fBuildTimeFormatted}"
    fi

    echo -e "$NOTATION Build completed successfully at $(getCurrentTime) in $fBuildTimeFormatted"
}

isModelSkipped() {
    local model="$1"
    for skip in "${fModelsSkip[@]}"; do
        [[ "$model" == "$skip" ]] && return 0
    done
    return 1
}

isModelInList() {
    local model="$1"
    for item in "${fModels[@]}"; do
        [[ "$model" == "$item" ]] && return 0
    done
    return 1
}

runLoopModels() {
    # Handle --scratch: delete saved state
    if [[ -n "$fScratch" ]]; then
        deleteLoopState
    fi

    # Only run if --models or --models-all is specified
    [[ ${#fModels[@]} -eq 0 ]] && return 1

    local totalStartTime=$(date +%s)
    local isLoopMode=$([[ ${#fModels[@]} -gt 1 || ${#fModelsSkip[@]} -gt 0 ]] && echo 1 || echo 0)
    [[ -z "$fContinue" ]] && fModelsSkipped=()

    # Apply --models-skip filter to fModels (ignore skip models not in the list)
    if [[ ${#fModelsSkip[@]} -gt 0 ]]; then
        local filteredModels=()
        for model in "${fModels[@]}"; do
            if ! isModelSkipped "$model"; then
                filteredModels+=("$model")
            else
                fModelsSkipped+=("$model")
            fi
        done
        fModels=("${filteredModels[@]}")
    fi

    # Check if all models were skipped
    if [[ ${#fModels[@]} -eq 0 ]]; then
        echo -e "$NOTATION ${YELLOW}All models were skipped. Nothing to build.${RESET}"
        return 0
    fi
    echo "$SEPARATOR"

    for i in "${!fModels[@]}"; do
        local model="${fModels[$i]}"

        # Set current model and calculate pending models
        fModelsCurrent="$model"
        fModelsPending=("${fModels[@]:$((i+1))}")
        fBuildModel="$model"

        echo -e "$NOTATION ${BOLD}Current Building: ${GREEN}$(getModelDisplayName "$model")${RESET}"
        runBuildCommands  # exits on failure with status chart

        # If we get here, build succeeded
        fModelsVerified+=("$model")
        echo -e "$NOTATION ${GREEN}✓ $(getModelDisplayName "$model") build succeeded${RESET}"
    done

    local totalEndTime=$(date +%s)
    local totalTime=$((totalEndTime - totalStartTime))
    local hours=$((totalTime / 3600))
    local minutes=$((totalTime % 3600 / 60))
    local seconds=$((totalTime % 60))
    local totalTimeFormatted="${seconds}s"
    [[ $minutes -gt 0 ]] && totalTimeFormatted="${minutes}m${totalTimeFormatted}"
    [[ $hours -gt 0 ]] && totalTimeFormatted="${hours}h${totalTimeFormatted}"

    echo "$SEPARATOR"
    if [[ $isLoopMode -eq 1 ]]; then
        echo -e "$NOTATION ${BOLD}Loop Build Summary:${RESET}"
    else
        echo -e "$NOTATION ${BOLD}Build Summary:${RESET}"
    fi
    echo -e "$NOTATION Total time: ${CYAN}$totalTimeFormatted${RESET}"
    echo -e "$NOTATION ${GREEN}✓ Verified (${#fModelsVerified[@]}):${RESET} $(IFS=','; echo "${fModelsVerified[*]}")"
    if [[ ${#fModelsSkipped[@]} -gt 0 ]]; then
        echo -e "$NOTATION ${CYAN}⊘ Skipped (${#fModelsSkipped[@]}):${RESET} $(IFS=','; echo "${fModelsSkipped[*]}")"
    fi
    echo "$SEPARATOR"

    # Delete state file only if no models were skipped (all completed)
    if [[ ${#fModelsSkipped[@]} -eq 0 ]]; then
        deleteLoopState
    else
        echo -e "$NOTATION ${YELLOW}State file kept (skipped models can be built later)${RESET}"
    fi
    return 0
}

linkCompileDatabase() {
    [ -z "$fGenerateCompileCmds" ] && [ -z "$fLinkCompileDb" ] && return
    # Skip linking when in loop mode (multiple models)
    if [[ ${#fModels[@]} -gt 1 ]]; then
        echo -e "$NOTATION ${GREY}Skipping compile database link (loop mode with multiple models)${RESET}"
        return
    fi

    # Use first model from --models if specified, otherwise use fBuildModel (defaults to mustang)
    if [[ ${#fModels[@]} -gt 0 ]]; then
        fBuildModel="${fModels[0]}"
    fi

    cd "$fWorkingDir" || exit

    local dbFile="bin/build_tools/compile_db/compile_commands_${fBuildModel}_irisc.json"
    local targetLink="$fWorkingDir/compile_commands.json"
    local clangdSource="/labhome/pexiang/myGit/crosslv/assets/.clangd"
    local clangdTarget="$fWorkingDir/.clangd"

    # Link compile_commands.json
    # Skip if link already exists and points to correct target (only for --link, not --bear)
    if [ -n "$fLinkCompileDb" ] && [ -z "$fGenerateCompileCmds" ]; then
        if [[ -L "$targetLink" && "$(readlink "$targetLink")" == "$dbFile" ]]; then
            echo -e "$NOTATION ${GREEN}Link already exists:${RESET} compile_commands.json -> $dbFile"
        else
            if [[ -f "$dbFile" ]]; then
                echo -e "$NOTATION ${CYAN}Linking compile database for clangd...${RESET}"
                ln -sf "$dbFile" "$targetLink"
                echo -e "$NOTATION Created: ${GREEN}compile_commands.json${RESET} -> ${BLUE}$dbFile${RESET}"
            else
                echo -e "$NOTATION ${RED}Warning: Compile database not found: $dbFile${RESET}"
            fi
        fi
    else
        if [[ -f "$dbFile" ]]; then
            echo -e "$NOTATION ${CYAN}Linking compile database for clangd...${RESET}"
            ln -sf "$dbFile" "$targetLink"
            echo -e "$NOTATION Created: ${GREEN}compile_commands.json${RESET} -> ${BLUE}$dbFile${RESET}"
        else
            echo -e "$NOTATION ${RED}Warning: Compile database not found: $dbFile${RESET}"
        fi
    fi

    # Link .clangd config
    if [[ -L "$clangdTarget" && "$(readlink "$clangdTarget")" == "$clangdSource" ]]; then
        echo -e "$NOTATION ${GREEN}Link already exists:${RESET} .clangd -> $clangdSource"
    elif [[ -f "$clangdSource" ]]; then
        ln -sf "$clangdSource" "$clangdTarget"
        echo -e "$NOTATION Created: ${GREEN}.clangd${RESET} -> ${BLUE}$clangdSource${RESET}"
    else
        echo -e "$NOTATION ${RED}Warning: .clangd config not found: $clangdSource${RESET}"
    fi
}

removeWriteFromJson() {
    [ -z "$fNeedBuild" ] && return
    # Skip when in loop mode (multiple models)
    [[ ${#fModels[@]} -gt 1 ]] && return
    cd "$fWorkingDir" || exit

    # Operate on the actual target file, not the symlink
    local dbFile="bin/build_tools/compile_db/compile_commands_${fBuildModel}_irisc.json"
    if [[ -f "$dbFile" ]]; then
        if [[ -w "$dbFile" ]]; then
            echo -e "$NOTATION ${CYAN}Removing write privilege from ${YELLOW}$dbFile${RESET}"
            chmod u-w "$dbFile"
        else
            echo -e "$NOTATION ${GREY}$dbFile is already read-only${RESET}"
        fi
    fi
}

main() {
    preConfigure "$@"
    [[ -n "$fContinue" ]] && loadLoopState # load state file to populate fModels

    # Handle --link standalone: link and exit (skip if --bear is also specified)
    if [[ -n "$fLinkCompileDb" && -z "$fGenerateCompileCmds" ]]; then
        linkCompileDatabase
        exit 0
    fi

    validateArguments
    showLogo
    printBuildFlags
    cleanTheRepo
    updateSubmodules
    # Handle models mode (--models) or regular build
    if [[ ${#fModels[@]} -gt 0 ]]; then
        runLoopModels
    else
        runBuildCommands
    fi
    linkCompileDatabase
    removeWriteFromJson
}

main "$@"
